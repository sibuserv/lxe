$ git describe --tags
v2.3.0-42-gc2d8084


diff --git a/CMakeLists.txt b/CMakeLists.txt
index 65a7f25..41e38fd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -2,14 +2,20 @@ cmake_minimum_required(VERSION 2.8.4)
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/CMakeModules/")
 project(signal-protocol-c)
 
+if(POLICY CMP0042)
+	cmake_policy(SET CMP0042 NEW)
+endif()
+
 SET(SIGNAL_PROTOCOL_C_VERSION_MAJOR 2)
 SET(SIGNAL_PROTOCOL_C_VERSION_MINOR 3)
 SET(SIGNAL_PROTOCOL_C_VERSION_PATCH 1)
 SET(SIGNAL_PROTOCOL_C_VERSION ${SIGNAL_PROTOCOL_C_VERSION_MAJOR}.${SIGNAL_PROTOCOL_C_VERSION_MINOR}.${SIGNAL_PROTOCOL_C_VERSION_PATCH})
 
 SET(LIB_SUFFIX "" CACHE STRING "Define suffix of directory name (32/64)")
-SET(LIB_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}" CACHE STRING "Directory where lib will install")
+SET(BIN_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/bin" CACHE STRING "The directory the binaries are installed in")
+SET(LIB_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}" CACHE STRING "The directory the libraries are installed in")
 SET(INCLUDE_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/include" CACHE PATH "The directory the headers are installed in")
+SET(INSTALL_PKGCONFIG_DIR "${LIB_INSTALL_DIR}/pkgconfig" CACHE PATH "Installation directory for pkgconfig (.pc) files")
 
 INCLUDE(CheckSymbolExists)
 INCLUDE(CheckCCompilerFlag)
diff --git a/CMakeModules/iOS.toolchain.cmake b/CMakeModules/iOS.toolchain.cmake
index df2e3fa..549ff43 100644
--- a/CMakeModules/iOS.toolchain.cmake
+++ b/CMakeModules/iOS.toolchain.cmake
@@ -45,7 +45,7 @@ if (CMAKE_UNAME)
 	string (REGEX REPLACE "^([0-9]+)\\.([0-9]+).*$" "\\1" DARWIN_MAJOR_VERSION "${CMAKE_HOST_SYSTEM_VERSION}")
 endif (CMAKE_UNAME)
 
-# Force the compilers to gcc for iOS
+# Force the compilers to clang for iOS
 include (CMakeForceCompiler)
 CMAKE_FORCE_C_COMPILER (/usr/bin/clang Apple)
 CMAKE_FORCE_CXX_COMPILER (/usr/bin/clang++ Apple)
diff --git a/ISSUE_TEMPLATE.md b/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000..fa9c2da
--- /dev/null
+++ b/ISSUE_TEMPLATE.md
@@ -0,0 +1,38 @@
+<!-- This is a bug report template. By following the instructions below and filling out the sections with your information, you will help the developers to get all the necessary data to fix your issue.
+You can also preview your report before submitting it. You may remove sections that aren't relevant to your particular case.
+
+Before we begin, please note that this tracker is only for issues, not questions or comments.
+
+If you are looking for support, please see our support center instead:
+https://support.whispersystems.org/
+or email support@whispersystems.org
+
+If you are looking for discussion, please see the mailing list or online forums.
+
+Let's begin with a checklist: replace the empty checkboxes [ ] below with checked ones [x] accordingly -->
+
+I have:
+- [ ] searched open and closed issues for duplicates
+
+----------------------------------------
+
+### Bug description
+Describe here the issue that you are experiencing.
+
+### Steps to reproduce
+- using hyphens as bullet points
+- list the steps
+- that reproduce the bug
+
+**Actual result:** Describe here what happens after you run the steps above (i.e. the buggy behaviour)
+**Expected result:** Describe here what should happen after you run the steps above (i.e. what would be the correct behaviour)
+
+### Device info
+<!-- replace the examples with your info -->
+**Device:** Manufacturer Model XVI
+**Android version:** 0.0.0
+**Signal version:** 0.0.0
+
+### Link to logs
+<!-- Any additional logging information that might help us diagnose your problem -->
+
diff --git a/README.md b/README.md
index f3089cd..f1c5474 100644
--- a/README.md
+++ b/README.md
@@ -81,33 +81,35 @@ of functions used across the library that need client-specific implementations.
 Refer to "signal_protocol.h" for detailed documentation on these functions, and the unit
 tests for example implementations.
 
-    signal_context *global_context;    
-    signal_context_create(&global_context, user_data);
-    signal_context_set_crypto_provider(global_context, &provider);
-    signal_context_set_locking_functions(global_context, lock_function, unlock_function);
+```c
+signal_context *global_context;
+signal_context_create(&global_context, user_data);
+signal_context_set_crypto_provider(global_context, &provider);
+signal_context_set_locking_functions(global_context, lock_function, unlock_function);
+```
 
 ## Client install time
 
 At install time, a libsignal-protocol-c client needs to generate its identity keys,
 registration id, and prekeys.
 
-    ratchet_identity_key_pair *identity_key_pair;
-    uint32_t registration_id;
-    signal_protocol_key_helper_pre_key_list_node *pre_keys_head;
-    session_pre_key *last_resort_key;
-    session_signed_pre_key *signed_pre_key;
+```c
+ratchet_identity_key_pair *identity_key_pair;
+uint32_t registration_id;
+signal_protocol_key_helper_pre_key_list_node *pre_keys_head;
+session_signed_pre_key *signed_pre_key;
 
-    signal_protocol_key_helper_generate_identity_key_pair(&identity_key_pair, global_context);
-    signal_protocol_key_helper_generate_registration_id(&registration_id, 0, global_context);
-    signal_protocol_key_helper_generate_pre_keys(&pre_keys_head, start_id, 100, global_context);
-    signal_protocol_key_helper_generate_last_resort_pre_key(&last_resort_key, global_context);
-    signal_protocol_key_helper_generate_signed_pre_key(&signed_pre_key, identity_key_pair, 5, timestamp, global_context);
+signal_protocol_key_helper_generate_identity_key_pair(&identity_key_pair, global_context);
+signal_protocol_key_helper_generate_registration_id(&registration_id, 0, global_context);
+signal_protocol_key_helper_generate_pre_keys(&pre_keys_head, start_id, 100, global_context);
+signal_protocol_key_helper_generate_signed_pre_key(&signed_pre_key, identity_key_pair, 5, timestamp, global_context);
 
-    /* Store identity_key_pair somewhere durable and safe. */
-    /* Store registration_id somewhere durable and safe. */
+/* Store identity_key_pair somewhere durable and safe. */
+/* Store registration_id somewhere durable and safe. */
 
-    /* Store pre keys in the pre key store. */
-    /* Store signed pre key in the signed pre key store. */
+/* Store pre keys in the pre key store. */
+/* Store signed pre key in the signed pre key store. */
+```
 
 The above example is simplified for the sake of clarity. All of these functions return errors
 on failure, and those errors should be checked for in real usage.
@@ -133,41 +135,43 @@ declared in "signal_protocol.h" for these data stores.
 Once the callbacks for these data stores are implemented, building a session
 is fairly straightforward:
 
-    /* Create the data store context, and add all the callbacks to it */
-    signal_protocol_store_context *store_context;
-    signal_protocol_store_context_create(&store_context, context);
-    signal_protocol_store_context_set_session_store(store_context, &session_store);
-    signal_protocol_store_context_set_pre_key_store(store_context, &pre_key_store);
-    signal_protocol_store_context_set_signed_pre_key_store(store_context, &signed_pre_key_store);
-    signal_protocol_store_context_set_identity_key_store(store_context, &identity_key_store);
-
-    /* Instantiate a session_builder for a recipient address. */
-    signal_protocol_address address = {
-        "+14159998888", 12, 1
-    };
-    session_builder *builder;
-    session_builder_create(&builder, store_context, &address, global_context);
-
-    /* Build a session with a pre key retrieved from the server. */
-    session_builder_process_pre_key_bundle(builder, retrieved_pre_key);
-
-    /* Create the session cipher and encrypt the message */
-    session_cipher *cipher;
-    session_cipher_create(&cipher, store_context, &address, global_context);
-    
-    ciphertext_message *encrypted_message;
-    session_cipher_encrypt(cipher, message, message_len, &encrypted_message);
-
-    /* Get the serialized content and deliver it */
-    signal_buffer *serialized = ciphertext_message_get_serialized(encrypted_message);
-    
-    deliver(signal_buffer_data(serialized), signal_buffer_len(serialized));
-
-    /* Cleanup */
-    SIGNAL_UNREF(encrypted_message);
-    session_cipher_free(cipher);
-    session_builder_free(builder);
-    signal_protocol_store_context_destroy(store_context);
+```c
+/* Create the data store context, and add all the callbacks to it */
+signal_protocol_store_context *store_context;
+signal_protocol_store_context_create(&store_context, context);
+signal_protocol_store_context_set_session_store(store_context, &session_store);
+signal_protocol_store_context_set_pre_key_store(store_context, &pre_key_store);
+signal_protocol_store_context_set_signed_pre_key_store(store_context, &signed_pre_key_store);
+signal_protocol_store_context_set_identity_key_store(store_context, &identity_key_store);
+
+/* Instantiate a session_builder for a recipient address. */
+signal_protocol_address address = {
+    "+14159998888", 12, 1
+};
+session_builder *builder;
+session_builder_create(&builder, store_context, &address, global_context);
+
+/* Build a session with a pre key retrieved from the server. */
+session_builder_process_pre_key_bundle(builder, retrieved_pre_key);
+
+/* Create the session cipher and encrypt the message */
+session_cipher *cipher;
+session_cipher_create(&cipher, store_context, &address, global_context);
+
+ciphertext_message *encrypted_message;
+session_cipher_encrypt(cipher, message, message_len, &encrypted_message);
+
+/* Get the serialized content and deliver it */
+signal_buffer *serialized = ciphertext_message_get_serialized(encrypted_message);
+
+deliver(signal_buffer_data(serialized), signal_buffer_len(serialized));
+
+/* Cleanup */
+SIGNAL_UNREF(encrypted_message);
+session_cipher_free(cipher);
+session_builder_free(builder);
+signal_protocol_store_context_destroy(store_context);
+```
 
 The above example is simplified for the sake of clarity. All of these functions return errors
 on failure, and those errors should be checked for in real usage.
diff --git a/protobuf/FingerprintProtocol.proto b/protobuf/FingerprintProtocol.proto
index 8aeacd8..ac5a890 100644
--- a/protobuf/FingerprintProtocol.proto
+++ b/protobuf/FingerprintProtocol.proto
@@ -3,13 +3,13 @@ package textsecure;
 option java_package = "org.whispersystems.libsignal.fingerprint";
 option java_outer_classname = "FingerprintProtos";
 
-message FingerprintData {
-  optional bytes publicKey  = 1;
-  optional bytes identifier = 2;
+message LogicalFingerprint {
+  optional bytes content = 1;
+  optional bytes identifier = 2; // Version 0
 }
 
-message CombinedFingerprint {
-  optional uint32          version           = 1;
-  optional FingerprintData localFingerprint  = 2;
-  optional FingerprintData remoteFingerprint = 3;
-}
\ No newline at end of file
+message CombinedFingerprints {
+  optional uint32             version           = 1;
+  optional LogicalFingerprint localFingerprint  = 2;
+  optional LogicalFingerprint remoteFingerprint = 3;
+}
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index f929788..a4ede65 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -103,4 +103,13 @@ INSTALL(
 	DESTINATION ${INCLUDE_INSTALL_DIR}/signal
 )
 
-INSTALL(TARGETS signal-protocol-c DESTINATION ${LIB_INSTALL_DIR})
+INSTALL(TARGETS signal-protocol-c
+	LIBRARY DESTINATION ${LIB_INSTALL_DIR}
+	RUNTIME DESTINATION ${BIN_INSTALL_DIR}
+	ARCHIVE DESTINATION ${LIB_INSTALL_DIR}
+)
+
+configure_file( ${CMAKE_CURRENT_SOURCE_DIR}/libsignal-protocol-c.pc.in
+		${CMAKE_CURRENT_BINARY_DIR}/libsignal-protocol-c.pc @ONLY)
+
+INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/libsignal-protocol-c.pc DESTINATION "${INSTALL_PKGCONFIG_DIR}")
diff --git a/src/FingerprintProtocol.pb-c.c b/src/FingerprintProtocol.pb-c.c
index f5e62e0..421ee2f 100644
--- a/src/FingerprintProtocol.pb-c.c
+++ b/src/FingerprintProtocol.pb-c.c
@@ -7,101 +7,101 @@
 #endif
 
 #include "FingerprintProtocol.pb-c.h"
-void   textsecure__fingerprint_data__init
-                     (Textsecure__FingerprintData         *message)
+void   textsecure__logical_fingerprint__init
+                     (Textsecure__LogicalFingerprint         *message)
 {
-  static Textsecure__FingerprintData init_value = TEXTSECURE__FINGERPRINT_DATA__INIT;
+  static Textsecure__LogicalFingerprint init_value = TEXTSECURE__LOGICAL_FINGERPRINT__INIT;
   *message = init_value;
 }
-size_t textsecure__fingerprint_data__get_packed_size
-                     (const Textsecure__FingerprintData *message)
+size_t textsecure__logical_fingerprint__get_packed_size
+                     (const Textsecure__LogicalFingerprint *message)
 {
-  assert(message->base.descriptor == &textsecure__fingerprint_data__descriptor);
+  assert(message->base.descriptor == &textsecure__logical_fingerprint__descriptor);
   return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
 }
-size_t textsecure__fingerprint_data__pack
-                     (const Textsecure__FingerprintData *message,
+size_t textsecure__logical_fingerprint__pack
+                     (const Textsecure__LogicalFingerprint *message,
                       uint8_t       *out)
 {
-  assert(message->base.descriptor == &textsecure__fingerprint_data__descriptor);
+  assert(message->base.descriptor == &textsecure__logical_fingerprint__descriptor);
   return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
 }
-size_t textsecure__fingerprint_data__pack_to_buffer
-                     (const Textsecure__FingerprintData *message,
+size_t textsecure__logical_fingerprint__pack_to_buffer
+                     (const Textsecure__LogicalFingerprint *message,
                       ProtobufCBuffer *buffer)
 {
-  assert(message->base.descriptor == &textsecure__fingerprint_data__descriptor);
+  assert(message->base.descriptor == &textsecure__logical_fingerprint__descriptor);
   return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
 }
-Textsecure__FingerprintData *
-       textsecure__fingerprint_data__unpack
+Textsecure__LogicalFingerprint *
+       textsecure__logical_fingerprint__unpack
                      (ProtobufCAllocator  *allocator,
                       size_t               len,
                       const uint8_t       *data)
 {
-  return (Textsecure__FingerprintData *)
-     protobuf_c_message_unpack (&textsecure__fingerprint_data__descriptor,
+  return (Textsecure__LogicalFingerprint *)
+     protobuf_c_message_unpack (&textsecure__logical_fingerprint__descriptor,
                                 allocator, len, data);
 }
-void   textsecure__fingerprint_data__free_unpacked
-                     (Textsecure__FingerprintData *message,
+void   textsecure__logical_fingerprint__free_unpacked
+                     (Textsecure__LogicalFingerprint *message,
                       ProtobufCAllocator *allocator)
 {
-  assert(message->base.descriptor == &textsecure__fingerprint_data__descriptor);
+  assert(message->base.descriptor == &textsecure__logical_fingerprint__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
-void   textsecure__combined_fingerprint__init
-                     (Textsecure__CombinedFingerprint         *message)
+void   textsecure__combined_fingerprints__init
+                     (Textsecure__CombinedFingerprints         *message)
 {
-  static Textsecure__CombinedFingerprint init_value = TEXTSECURE__COMBINED_FINGERPRINT__INIT;
+  static Textsecure__CombinedFingerprints init_value = TEXTSECURE__COMBINED_FINGERPRINTS__INIT;
   *message = init_value;
 }
-size_t textsecure__combined_fingerprint__get_packed_size
-                     (const Textsecure__CombinedFingerprint *message)
+size_t textsecure__combined_fingerprints__get_packed_size
+                     (const Textsecure__CombinedFingerprints *message)
 {
-  assert(message->base.descriptor == &textsecure__combined_fingerprint__descriptor);
+  assert(message->base.descriptor == &textsecure__combined_fingerprints__descriptor);
   return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
 }
-size_t textsecure__combined_fingerprint__pack
-                     (const Textsecure__CombinedFingerprint *message,
+size_t textsecure__combined_fingerprints__pack
+                     (const Textsecure__CombinedFingerprints *message,
                       uint8_t       *out)
 {
-  assert(message->base.descriptor == &textsecure__combined_fingerprint__descriptor);
+  assert(message->base.descriptor == &textsecure__combined_fingerprints__descriptor);
   return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
 }
-size_t textsecure__combined_fingerprint__pack_to_buffer
-                     (const Textsecure__CombinedFingerprint *message,
+size_t textsecure__combined_fingerprints__pack_to_buffer
+                     (const Textsecure__CombinedFingerprints *message,
                       ProtobufCBuffer *buffer)
 {
-  assert(message->base.descriptor == &textsecure__combined_fingerprint__descriptor);
+  assert(message->base.descriptor == &textsecure__combined_fingerprints__descriptor);
   return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
 }
-Textsecure__CombinedFingerprint *
-       textsecure__combined_fingerprint__unpack
+Textsecure__CombinedFingerprints *
+       textsecure__combined_fingerprints__unpack
                      (ProtobufCAllocator  *allocator,
                       size_t               len,
                       const uint8_t       *data)
 {
-  return (Textsecure__CombinedFingerprint *)
-     protobuf_c_message_unpack (&textsecure__combined_fingerprint__descriptor,
+  return (Textsecure__CombinedFingerprints *)
+     protobuf_c_message_unpack (&textsecure__combined_fingerprints__descriptor,
                                 allocator, len, data);
 }
-void   textsecure__combined_fingerprint__free_unpacked
-                     (Textsecure__CombinedFingerprint *message,
+void   textsecure__combined_fingerprints__free_unpacked
+                     (Textsecure__CombinedFingerprints *message,
                       ProtobufCAllocator *allocator)
 {
-  assert(message->base.descriptor == &textsecure__combined_fingerprint__descriptor);
+  assert(message->base.descriptor == &textsecure__combined_fingerprints__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
-static const ProtobufCFieldDescriptor textsecure__fingerprint_data__field_descriptors[2] =
+static const ProtobufCFieldDescriptor textsecure__logical_fingerprint__field_descriptors[2] =
 {
   {
-    "publicKey",
+    "content",
     1,
     PROTOBUF_C_LABEL_OPTIONAL,
     PROTOBUF_C_TYPE_BYTES,
-    offsetof(Textsecure__FingerprintData, has_publickey),
-    offsetof(Textsecure__FingerprintData, publickey),
+    offsetof(Textsecure__LogicalFingerprint, has_content),
+    offsetof(Textsecure__LogicalFingerprint, content),
     NULL,
     NULL,
     0,             /* flags */
@@ -112,47 +112,47 @@ static const ProtobufCFieldDescriptor textsecure__fingerprint_data__field_descri
     2,
     PROTOBUF_C_LABEL_OPTIONAL,
     PROTOBUF_C_TYPE_BYTES,
-    offsetof(Textsecure__FingerprintData, has_identifier),
-    offsetof(Textsecure__FingerprintData, identifier),
+    offsetof(Textsecure__LogicalFingerprint, has_identifier),
+    offsetof(Textsecure__LogicalFingerprint, identifier),
     NULL,
     NULL,
     0,             /* flags */
     0,NULL,NULL    /* reserved1,reserved2, etc */
   },
 };
-static const unsigned textsecure__fingerprint_data__field_indices_by_name[] = {
+static const unsigned textsecure__logical_fingerprint__field_indices_by_name[] = {
+  0,   /* field[0] = content */
   1,   /* field[1] = identifier */
-  0,   /* field[0] = publicKey */
 };
-static const ProtobufCIntRange textsecure__fingerprint_data__number_ranges[1 + 1] =
+static const ProtobufCIntRange textsecure__logical_fingerprint__number_ranges[1 + 1] =
 {
   { 1, 0 },
   { 0, 2 }
 };
-const ProtobufCMessageDescriptor textsecure__fingerprint_data__descriptor =
+const ProtobufCMessageDescriptor textsecure__logical_fingerprint__descriptor =
 {
   PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
-  "textsecure.FingerprintData",
-  "FingerprintData",
-  "Textsecure__FingerprintData",
+  "textsecure.LogicalFingerprint",
+  "LogicalFingerprint",
+  "Textsecure__LogicalFingerprint",
   "textsecure",
-  sizeof(Textsecure__FingerprintData),
+  sizeof(Textsecure__LogicalFingerprint),
   2,
-  textsecure__fingerprint_data__field_descriptors,
-  textsecure__fingerprint_data__field_indices_by_name,
-  1,  textsecure__fingerprint_data__number_ranges,
-  (ProtobufCMessageInit) textsecure__fingerprint_data__init,
+  textsecure__logical_fingerprint__field_descriptors,
+  textsecure__logical_fingerprint__field_indices_by_name,
+  1,  textsecure__logical_fingerprint__number_ranges,
+  (ProtobufCMessageInit) textsecure__logical_fingerprint__init,
   NULL,NULL,NULL    /* reserved[123] */
 };
-static const ProtobufCFieldDescriptor textsecure__combined_fingerprint__field_descriptors[3] =
+static const ProtobufCFieldDescriptor textsecure__combined_fingerprints__field_descriptors[3] =
 {
   {
     "version",
     1,
     PROTOBUF_C_LABEL_OPTIONAL,
     PROTOBUF_C_TYPE_UINT32,
-    offsetof(Textsecure__CombinedFingerprint, has_version),
-    offsetof(Textsecure__CombinedFingerprint, version),
+    offsetof(Textsecure__CombinedFingerprints, has_version),
+    offsetof(Textsecure__CombinedFingerprints, version),
     NULL,
     NULL,
     0,             /* flags */
@@ -164,8 +164,8 @@ static const ProtobufCFieldDescriptor textsecure__combined_fingerprint__field_de
     PROTOBUF_C_LABEL_OPTIONAL,
     PROTOBUF_C_TYPE_MESSAGE,
     0,   /* quantifier_offset */
-    offsetof(Textsecure__CombinedFingerprint, localfingerprint),
-    &textsecure__fingerprint_data__descriptor,
+    offsetof(Textsecure__CombinedFingerprints, localfingerprint),
+    &textsecure__logical_fingerprint__descriptor,
     NULL,
     0,             /* flags */
     0,NULL,NULL    /* reserved1,reserved2, etc */
@@ -176,35 +176,35 @@ static const ProtobufCFieldDescriptor textsecure__combined_fingerprint__field_de
     PROTOBUF_C_LABEL_OPTIONAL,
     PROTOBUF_C_TYPE_MESSAGE,
     0,   /* quantifier_offset */
-    offsetof(Textsecure__CombinedFingerprint, remotefingerprint),
-    &textsecure__fingerprint_data__descriptor,
+    offsetof(Textsecure__CombinedFingerprints, remotefingerprint),
+    &textsecure__logical_fingerprint__descriptor,
     NULL,
     0,             /* flags */
     0,NULL,NULL    /* reserved1,reserved2, etc */
   },
 };
-static const unsigned textsecure__combined_fingerprint__field_indices_by_name[] = {
+static const unsigned textsecure__combined_fingerprints__field_indices_by_name[] = {
   1,   /* field[1] = localFingerprint */
   2,   /* field[2] = remoteFingerprint */
   0,   /* field[0] = version */
 };
-static const ProtobufCIntRange textsecure__combined_fingerprint__number_ranges[1 + 1] =
+static const ProtobufCIntRange textsecure__combined_fingerprints__number_ranges[1 + 1] =
 {
   { 1, 0 },
   { 0, 3 }
 };
-const ProtobufCMessageDescriptor textsecure__combined_fingerprint__descriptor =
+const ProtobufCMessageDescriptor textsecure__combined_fingerprints__descriptor =
 {
   PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
-  "textsecure.CombinedFingerprint",
-  "CombinedFingerprint",
-  "Textsecure__CombinedFingerprint",
+  "textsecure.CombinedFingerprints",
+  "CombinedFingerprints",
+  "Textsecure__CombinedFingerprints",
   "textsecure",
-  sizeof(Textsecure__CombinedFingerprint),
+  sizeof(Textsecure__CombinedFingerprints),
   3,
-  textsecure__combined_fingerprint__field_descriptors,
-  textsecure__combined_fingerprint__field_indices_by_name,
-  1,  textsecure__combined_fingerprint__number_ranges,
-  (ProtobufCMessageInit) textsecure__combined_fingerprint__init,
+  textsecure__combined_fingerprints__field_descriptors,
+  textsecure__combined_fingerprints__field_indices_by_name,
+  1,  textsecure__combined_fingerprints__number_ranges,
+  (ProtobufCMessageInit) textsecure__combined_fingerprints__init,
   NULL,NULL,NULL    /* reserved[123] */
 };
diff --git a/src/FingerprintProtocol.pb-c.h b/src/FingerprintProtocol.pb-c.h
index ecf6067..dfc3c60 100644
--- a/src/FingerprintProtocol.pb-c.h
+++ b/src/FingerprintProtocol.pb-c.h
@@ -10,13 +10,13 @@ PROTOBUF_C__BEGIN_DECLS
 
 #if PROTOBUF_C_VERSION_NUMBER < 1000000
 # error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
-#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
+#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
 # error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
 #endif
 
 
-typedef struct _Textsecure__FingerprintData Textsecure__FingerprintData;
-typedef struct _Textsecure__CombinedFingerprint Textsecure__CombinedFingerprint;
+typedef struct _Textsecure__LogicalFingerprint Textsecure__LogicalFingerprint;
+typedef struct _Textsecure__CombinedFingerprints Textsecure__CombinedFingerprints;
 
 
 /* --- enums --- */
@@ -24,77 +24,80 @@ typedef struct _Textsecure__CombinedFingerprint Textsecure__CombinedFingerprint;
 
 /* --- messages --- */
 
-struct  _Textsecure__FingerprintData
+struct  _Textsecure__LogicalFingerprint
 {
   ProtobufCMessage base;
-  protobuf_c_boolean has_publickey;
-  ProtobufCBinaryData publickey;
+  protobuf_c_boolean has_content;
+  ProtobufCBinaryData content;
+  /*
+   * Version 0
+   */
   protobuf_c_boolean has_identifier;
   ProtobufCBinaryData identifier;
 };
-#define TEXTSECURE__FINGERPRINT_DATA__INIT \
- { PROTOBUF_C_MESSAGE_INIT (&textsecure__fingerprint_data__descriptor) \
+#define TEXTSECURE__LOGICAL_FINGERPRINT__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&textsecure__logical_fingerprint__descriptor) \
     , 0,{0,NULL}, 0,{0,NULL} }
 
 
-struct  _Textsecure__CombinedFingerprint
+struct  _Textsecure__CombinedFingerprints
 {
   ProtobufCMessage base;
   protobuf_c_boolean has_version;
   uint32_t version;
-  Textsecure__FingerprintData *localfingerprint;
-  Textsecure__FingerprintData *remotefingerprint;
+  Textsecure__LogicalFingerprint *localfingerprint;
+  Textsecure__LogicalFingerprint *remotefingerprint;
 };
-#define TEXTSECURE__COMBINED_FINGERPRINT__INIT \
- { PROTOBUF_C_MESSAGE_INIT (&textsecure__combined_fingerprint__descriptor) \
+#define TEXTSECURE__COMBINED_FINGERPRINTS__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&textsecure__combined_fingerprints__descriptor) \
     , 0,0, NULL, NULL }
 
 
-/* Textsecure__FingerprintData methods */
-void   textsecure__fingerprint_data__init
-                     (Textsecure__FingerprintData         *message);
-size_t textsecure__fingerprint_data__get_packed_size
-                     (const Textsecure__FingerprintData   *message);
-size_t textsecure__fingerprint_data__pack
-                     (const Textsecure__FingerprintData   *message,
+/* Textsecure__LogicalFingerprint methods */
+void   textsecure__logical_fingerprint__init
+                     (Textsecure__LogicalFingerprint         *message);
+size_t textsecure__logical_fingerprint__get_packed_size
+                     (const Textsecure__LogicalFingerprint   *message);
+size_t textsecure__logical_fingerprint__pack
+                     (const Textsecure__LogicalFingerprint   *message,
                       uint8_t             *out);
-size_t textsecure__fingerprint_data__pack_to_buffer
-                     (const Textsecure__FingerprintData   *message,
+size_t textsecure__logical_fingerprint__pack_to_buffer
+                     (const Textsecure__LogicalFingerprint   *message,
                       ProtobufCBuffer     *buffer);
-Textsecure__FingerprintData *
-       textsecure__fingerprint_data__unpack
+Textsecure__LogicalFingerprint *
+       textsecure__logical_fingerprint__unpack
                      (ProtobufCAllocator  *allocator,
                       size_t               len,
                       const uint8_t       *data);
-void   textsecure__fingerprint_data__free_unpacked
-                     (Textsecure__FingerprintData *message,
+void   textsecure__logical_fingerprint__free_unpacked
+                     (Textsecure__LogicalFingerprint *message,
                       ProtobufCAllocator *allocator);
-/* Textsecure__CombinedFingerprint methods */
-void   textsecure__combined_fingerprint__init
-                     (Textsecure__CombinedFingerprint         *message);
-size_t textsecure__combined_fingerprint__get_packed_size
-                     (const Textsecure__CombinedFingerprint   *message);
-size_t textsecure__combined_fingerprint__pack
-                     (const Textsecure__CombinedFingerprint   *message,
+/* Textsecure__CombinedFingerprints methods */
+void   textsecure__combined_fingerprints__init
+                     (Textsecure__CombinedFingerprints         *message);
+size_t textsecure__combined_fingerprints__get_packed_size
+                     (const Textsecure__CombinedFingerprints   *message);
+size_t textsecure__combined_fingerprints__pack
+                     (const Textsecure__CombinedFingerprints   *message,
                       uint8_t             *out);
-size_t textsecure__combined_fingerprint__pack_to_buffer
-                     (const Textsecure__CombinedFingerprint   *message,
+size_t textsecure__combined_fingerprints__pack_to_buffer
+                     (const Textsecure__CombinedFingerprints   *message,
                       ProtobufCBuffer     *buffer);
-Textsecure__CombinedFingerprint *
-       textsecure__combined_fingerprint__unpack
+Textsecure__CombinedFingerprints *
+       textsecure__combined_fingerprints__unpack
                      (ProtobufCAllocator  *allocator,
                       size_t               len,
                       const uint8_t       *data);
-void   textsecure__combined_fingerprint__free_unpacked
-                     (Textsecure__CombinedFingerprint *message,
+void   textsecure__combined_fingerprints__free_unpacked
+                     (Textsecure__CombinedFingerprints *message,
                       ProtobufCAllocator *allocator);
 /* --- per-message closures --- */
 
-typedef void (*Textsecure__FingerprintData_Closure)
-                 (const Textsecure__FingerprintData *message,
+typedef void (*Textsecure__LogicalFingerprint_Closure)
+                 (const Textsecure__LogicalFingerprint *message,
                   void *closure_data);
-typedef void (*Textsecure__CombinedFingerprint_Closure)
-                 (const Textsecure__CombinedFingerprint *message,
+typedef void (*Textsecure__CombinedFingerprints_Closure)
+                 (const Textsecure__CombinedFingerprints *message,
                   void *closure_data);
 
 /* --- services --- */
@@ -102,8 +105,8 @@ typedef void (*Textsecure__CombinedFingerprint_Closure)
 
 /* --- descriptors --- */
 
-extern const ProtobufCMessageDescriptor textsecure__fingerprint_data__descriptor;
-extern const ProtobufCMessageDescriptor textsecure__combined_fingerprint__descriptor;
+extern const ProtobufCMessageDescriptor textsecure__logical_fingerprint__descriptor;
+extern const ProtobufCMessageDescriptor textsecure__combined_fingerprints__descriptor;
 
 PROTOBUF_C__END_DECLS
 
diff --git a/src/LocalStorageProtocol.pb-c.h b/src/LocalStorageProtocol.pb-c.h
index cbf2532..43b5bce 100644
--- a/src/LocalStorageProtocol.pb-c.h
+++ b/src/LocalStorageProtocol.pb-c.h
@@ -10,7 +10,7 @@ PROTOBUF_C__BEGIN_DECLS
 
 #if PROTOBUF_C_VERSION_NUMBER < 1000000
 # error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
-#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
+#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
 # error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
 #endif
 
diff --git a/src/WhisperTextProtocol.pb-c.h b/src/WhisperTextProtocol.pb-c.h
index 8dab74a..bcab2c5 100644
--- a/src/WhisperTextProtocol.pb-c.h
+++ b/src/WhisperTextProtocol.pb-c.h
@@ -10,7 +10,7 @@ PROTOBUF_C__BEGIN_DECLS
 
 #if PROTOBUF_C_VERSION_NUMBER < 1000000
 # error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
-#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
+#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
 # error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
 #endif
 
diff --git a/src/curve.c b/src/curve.c
index 531cc2d..3be9b41 100644
--- a/src/curve.c
+++ b/src/curve.c
@@ -7,7 +7,8 @@
 
 #include "curve25519/curve25519-donna.h"
 #include "curve25519/ed25519/additions/curve_sigs.h"
-#include "curve25519/ed25519/additions/vxeddsa.h"
+#include "curve25519/ed25519/additions/generalized/gen_x.h"
+#include "curve25519/ed25519/tests/internal_fast_tests.h"
 #include "signal_protocol_internal.h"
 #include "signal_utarray.h"
 
@@ -39,6 +40,13 @@ struct ec_public_key_list
     UT_array *values;
 };
 
+int curve_internal_fast_tests()
+{
+    if (all_fast_tests(1) != 0)
+        return SG_ERR_UNKNOWN;
+    return 0;
+}
+
 int curve_decode_point(ec_public_key **public_key, const uint8_t *key_data, size_t key_len, signal_context *global_context)
 {
     ec_public_key *key = 0;
@@ -535,7 +543,7 @@ int curve_verify_signature(const ec_public_key *signing_key,
         const uint8_t *message_data, size_t message_len,
         const uint8_t *signature_data, size_t signature_len)
 {
-    if(signature_len != 64) {
+    if(signature_len != CURVE_SIGNATURE_LEN) {
         return SG_ERR_INVAL;
     }
 
@@ -589,7 +597,7 @@ int curve_verify_vrf_signature(signal_context *context,
         return SG_ERR_INVAL;
     }
 
-    if(!message_data || !signature_data || signature_len != 96) {
+    if(!message_data || !signature_data || signature_len != VRF_SIGNATURE_LEN) {
         signal_log(context, SG_LOG_ERROR, "Invalid message or signature format");
         return SG_ERR_VRF_SIG_VERIF_FAILED;
     }
@@ -600,9 +608,9 @@ int curve_verify_vrf_signature(signal_context *context,
         goto complete;
     }
 
-    result = vxed25519_verify(signal_buffer_data(buffer),
+    result = generalized_xveddsa_25519_verify(signal_buffer_data(buffer),
             signature_data, signing_key->data,
-            message_data, message_len);
+            message_data, message_len, NULL, 0);
     if(result != 0) {
         signal_log(context, SG_LOG_ERROR, "Invalid signature");
         result = SG_ERR_VRF_SIG_VERIF_FAILED;
@@ -638,9 +646,9 @@ int curve_calculate_vrf_signature(signal_context *context,
         goto complete;
     }
 
-    result = vxed25519_sign(signal_buffer_data(buffer),
+    result = generalized_xveddsa_25519_sign(signal_buffer_data(buffer),
             signing_key->data,
-            message_data, message_len, random_data);
+            message_data, message_len, random_data, NULL, 0);
     if(result != 0) {
         signal_log(context, SG_LOG_ERROR, "Signature failed!");
         result = SG_ERR_UNKNOWN;
diff --git a/src/curve.h b/src/curve.h
index 9401f88..d9cbd03 100644
--- a/src/curve.h
+++ b/src/curve.h
@@ -12,6 +12,8 @@ extern "C" {
 #define CURVE_SIGNATURE_LEN 64
 #define VRF_SIGNATURE_LEN 96
 
+int curve_internal_fast_tests();
+
 int curve_decode_point(ec_public_key **public_key, const uint8_t *key_data, size_t key_len, signal_context *global_context);
 int ec_public_key_compare(const ec_public_key *key1, const ec_public_key *key2);
 int ec_public_key_memcmp(const ec_public_key *key1, const ec_public_key *key2);
@@ -124,7 +126,7 @@ void ec_public_key_list_free(ec_public_key_list *list);
  * @param shared_key_data Set to a 32-byte shared secret on success.
  * @param public_key The Curve25519 (typically remote party's) public key.
  * @param private_key The Curve25519 (typically yours) private key.
- * @return 0 on success, negative on failure
+ * @return length of the shared secret on success, negative on failure
  */
 int curve_calculate_agreement(uint8_t **shared_key_data, const ec_public_key *public_key, const ec_private_key *private_key);
 
diff --git a/src/curve25519/CMakeLists.txt b/src/curve25519/CMakeLists.txt
index 54eb094..f71b351 100644
--- a/src/curve25519/CMakeLists.txt
+++ b/src/curve25519/CMakeLists.txt
@@ -16,7 +16,9 @@ ENDIF(CMAKE_C_COMPILER_ID MATCHES "Clang")
 include_directories(
     ed25519/nacl_includes
     ed25519/additions
+    ed25519/additions/generalized
     ed25519/sha512
+    ed25519/tests
     ed25519
 )
 
@@ -67,12 +69,11 @@ set(ed25519_SRCS
     ed25519/additions/curve_sigs.c
     ed25519/additions/elligator.c
     ed25519/additions/fe_isequal.c
+    ed25519/additions/fe_isreduced.c
     ed25519/additions/fe_mont_rhs.c
     ed25519/additions/fe_montx_to_edy.c
     ed25519/additions/fe_sqrt.c
-    ed25519/additions/ge_is_small_order.c
     ed25519/additions/ge_isneutral.c
-    ed25519/additions/ge_montx_to_p2.c
     ed25519/additions/ge_montx_to_p3.c
     ed25519/additions/ge_neg.c
     ed25519/additions/ge_p3_to_montx.c
@@ -84,16 +85,19 @@ set(ed25519_SRCS
     ed25519/additions/sc_cmov.c
     ed25519/additions/sc_neg.c
     ed25519/additions/sign_modified.c
-    ed25519/additions/uopen_modified.c
-    ed25519/additions/usign_modified.c
     ed25519/additions/utility.c
-    ed25519/additions/vopen_modified.c
-    ed25519/additions/vsign_modified.c
-    ed25519/additions/vxeddsa.c
+    ed25519/additions/generalized/ge_p3_add.c
+    ed25519/additions/generalized/gen_eddsa.c
+    ed25519/additions/generalized/gen_labelset.c
+    ed25519/additions/generalized/gen_veddsa.c
+    ed25519/additions/generalized/gen_x.c
+    ed25519/additions/generalized/point_isreduced.c
+    ed25519/additions/generalized/sc_isreduced.c
     ed25519/additions/xeddsa.c
     ed25519/additions/zeroize.c
     ed25519/nacl_sha512/blocks.c
     ed25519/nacl_sha512/hash.c
+    ed25519/tests/internal_fast_tests.c
 )
 
 add_library(curve25519 OBJECT ${curve25519_SRCS} ${ed25519_SRCS})
diff --git a/src/curve25519/ed25519/additions/crypto_additions.h b/src/curve25519/ed25519/additions/crypto_additions.h
index da4a1cd..5c4b8f4 100644
--- a/src/curve25519/ed25519/additions/crypto_additions.h
+++ b/src/curve25519/ed25519/additions/crypto_additions.h
@@ -12,11 +12,11 @@ void sc_neg(unsigned char *b, const unsigned char *a);
 void sc_cmov(unsigned char* f, const unsigned char* g, unsigned char b);
 
 int fe_isequal(const fe f, const fe g);
+int fe_isreduced(const unsigned char* s);
 void fe_mont_rhs(fe v2, const fe u);
 void fe_montx_to_edy(fe y, const fe u);
 void fe_sqrt(fe b, const fe a);
 
-int ge_is_small_order(const ge_p3 *p);
 int ge_isneutral(const ge_p3* q);
 void ge_neg(ge_p3* r, const ge_p3 *p);
 void ge_montx_to_p3(ge_p3* p, const fe u, const unsigned char ed_sign_bit);
@@ -26,16 +26,6 @@ void ge_scalarmult_cofactor(ge_p3 *q, const ge_p3 *p);
 
 void elligator(fe u, const fe r);
 void hash_to_point(ge_p3* p, const unsigned char* msg, const unsigned long in_len);
-void calculate_Bv(ge_p3* Bv,
-                  unsigned char* buf,
-                  const unsigned char* A,
-                  const unsigned char* msg, const unsigned long msg_len);
-void calculate_Bv_and_V(ge_p3* Bv,
-                        unsigned char* V,
-                        unsigned char* buf,
-                        const unsigned char* a,
-                        const unsigned char* A,
-                        const unsigned char* msg, const unsigned long msg_len);
 
 int crypto_sign_modified(
   unsigned char *sm,
@@ -51,19 +41,5 @@ int crypto_sign_open_modified(
   const unsigned char *pk
   );
 
-int crypto_vsign_modified(
-  unsigned char *sm,
-  const unsigned char *M,unsigned long Mlen,
-  const unsigned char *a, 
-  const unsigned char *A,
-  const unsigned char *random,
-  const ge_p3 *Bu,
-  const unsigned char *U);
-
-int crypto_vsign_open_modified(
-  unsigned char *m,
-  const unsigned char *sm,unsigned long long smlen,
-  const unsigned char *pk, const ge_p3* Bu);
-
 
 #endif
diff --git a/src/curve25519/ed25519/additions/curve_sigs.c b/src/curve25519/ed25519/additions/curve_sigs.c
index 7a49b18..3254724 100644
--- a/src/curve25519/ed25519/additions/curve_sigs.c
+++ b/src/curve25519/ed25519/additions/curve_sigs.c
@@ -1,5 +1,5 @@
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
 #include "ge.h"
 #include "curve_sigs.h"
 #include "crypto_sign.h"
diff --git a/src/curve25519/ed25519/additions/elligator.c b/src/curve25519/ed25519/additions/elligator.c
index 6feb96b..17b03a7 100644
--- a/src/curve25519/ed25519/additions/elligator.c
+++ b/src/curve25519/ed25519/additions/elligator.c
@@ -78,34 +78,3 @@ void hash_to_point(ge_p3* p, const unsigned char* in, const unsigned long in_len
 }
 
 
-void calculate_Bv(ge_p3* Bv, 
-                 unsigned char* buf,
-                 const unsigned char* A,
-                 const unsigned char* msg, const unsigned long msg_len)
-{
-  int count;
-
-  /* Calculate SHA512(label(2) || A || msg) */
-  buf[0] = 0xFD;
-  for (count = 1; count < 32; count++)
-    buf[count] = 0xFF;
-  memmove(buf+32, A, 32);
-  memmove(buf+64, msg, msg_len); 
-
-  hash_to_point(Bv, buf, 64 + msg_len);
-}
-
-
-void calculate_Bv_and_V(ge_p3* Bv, 
-                       unsigned char* V, 
-                       unsigned char* buf,
-                       const unsigned char* a,
-                       const unsigned char* A,
-                       const unsigned char* msg, const unsigned long msg_len)
-{
-  ge_p3 p3;
-
-  calculate_Bv(Bv, buf, A, msg, msg_len);
-  ge_scalarmult(&p3, a, Bv);
-  ge_p3_tobytes(V, &p3);
-}
diff --git a/src/curve25519/ed25519/additions/fe_isreduced.c b/src/curve25519/ed25519/additions/fe_isreduced.c
new file mode 100644
index 0000000..6fbb3be
--- /dev/null
+++ b/src/curve25519/ed25519/additions/fe_isreduced.c
@@ -0,0 +1,14 @@
+#include "fe.h"
+#include "crypto_verify_32.h"
+
+int fe_isreduced(const unsigned char* s)
+{
+  fe f;
+  unsigned char strict[32];
+
+  fe_frombytes(f, s);
+  fe_tobytes(strict, f);
+  if (crypto_verify_32(strict, s) != 0)
+    return 0;
+  return 1;
+}
diff --git a/src/curve25519/ed25519/additions/ge_is_small_order.c b/src/curve25519/ed25519/additions/ge_is_small_order.c
deleted file mode 100644
index 845941b..0000000
--- a/src/curve25519/ed25519/additions/ge_is_small_order.c
+++ /dev/null
@@ -1,30 +0,0 @@
-#include "crypto_additions.h"
-#include "ge.h"
-#include "utility.h"
-#include "stdio.h"
-
-/*
-return 1 if f == g
-return 0 if f != g
-*/
-
-int ge_is_small_order(const ge_p3 *p)
-{
-  ge_p1p1 p1p1;
-  ge_p2 p2;
-  fe zero;
-
-  ge_p3_dbl(&p1p1, p);
-  ge_p1p1_to_p2(&p2, &p1p1);
-
-  ge_p2_dbl(&p1p1, &p2);
-  ge_p1p1_to_p2(&p2, &p1p1);
-
-  ge_p2_dbl(&p1p1, &p2);
-  ge_p1p1_to_p2(&p2, &p1p1);
-
-  fe_0(zero);
-
-  /* Check if 8*p == neutral element == (0, 1) */
-  return (fe_isequal(p2.X, zero) & fe_isequal(p2.Y, p2.Z));
-}
diff --git a/src/curve25519/ed25519/additions/ge_montx_to_p2.c b/src/curve25519/ed25519/additions/ge_montx_to_p2.c
deleted file mode 100644
index d123d03..0000000
--- a/src/curve25519/ed25519/additions/ge_montx_to_p2.c
+++ /dev/null
@@ -1,69 +0,0 @@
-#include "fe.h"
-#include "ge.h"
-#include "assert.h"
-#include "crypto_additions.h"
-#include "utility.h"
-
-/* sqrt(-(A+2)) */
-static unsigned char A_bytes[32] = {
-  0x06, 0x7e, 0x45, 0xff, 0xaa, 0x04, 0x6e, 0xcc, 
-  0x82, 0x1a, 0x7d, 0x4b, 0xd1, 0xd3, 0xa1, 0xc5, 
-  0x7e, 0x4f, 0xfc, 0x03, 0xdc, 0x08, 0x7b, 0xd2, 
-  0xbb, 0x06, 0xa0, 0x60, 0xf4, 0xed, 0x26, 0x0f
-};
-
-void ge_montx_to_p2(ge_p2* p, const fe u, const unsigned char ed_sign_bit)
-{
-  fe x, y, A, v, v2, iv, nx;
-
-  fe_frombytes(A, A_bytes); 
-
-  /* given u, recover edwards y */
-  /* given u, recover v */
-  /* given u and v, recover edwards x */
-
-  fe_montx_to_edy(y, u);       /* y = (u - 1) / (u + 1) */
-
-  fe_mont_rhs(v2, u);          /* v^2 = u(u^2 + Au + 1) */
-  fe_sqrt(v, v2);              /* v = sqrt(v^2) */
-
-  fe_mul(x, u, A);             /* x = u * sqrt(-(A+2)) */
-  fe_invert(iv, v);            /* 1/v */
-  fe_mul(x, x, iv);            /* x = (u/v) * sqrt(-(A+2)) */
-
-  fe_neg(nx, x);               /* negate x to match sign bit */
-  fe_cmov(x, nx, fe_isnegative(x) ^ ed_sign_bit);
-
-  fe_copy(p->X, x);
-  fe_copy(p->Y, y);
-  fe_1(p->Z);
-
- /* POSTCONDITION: check that p->X and p->Y satisfy the Ed curve equation */
- /* -x^2 + y^2 = 1 + dx^2y^2 */
-#ifndef NDEBUG
-  {
-  fe one, d, x2, y2, x2y2, dx2y2;
-
-  unsigned char dbytes[32] = {
-  0xa3, 0x78, 0x59, 0x13, 0xca, 0x4d, 0xeb, 0x75,
-  0xab, 0xd8, 0x41, 0x41, 0x4d, 0x0a, 0x70, 0x00,
-  0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
-  0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
-  };
-  
-  fe_frombytes(d, dbytes);
-  fe_1(one);
-  fe_sq(x2, p->X);                /* x^2 */
-  fe_sq(y2, p->Y);                /* y^2 */
-
-  fe_mul(dx2y2, x2, y2);           /* x^2y^2 */
-  fe_mul(dx2y2, dx2y2, d);         /* dx^2y^2 */
-  fe_add(dx2y2, dx2y2, one);       /* dx^2y^2 + 1 */
-
-  fe_neg(x2y2, x2);                /* -x^2 */
-  fe_add(x2y2, x2y2, y2);          /* -x^2 + y^2 */
-
-  assert(fe_isequal(x2y2, dx2y2));
-  }
-#endif
-}
diff --git a/src/curve25519/ed25519/additions/generalized/ge_p3_add.c b/src/curve25519/ed25519/additions/generalized/ge_p3_add.c
new file mode 100644
index 0000000..75d9673
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/ge_p3_add.c
@@ -0,0 +1,15 @@
+#include "ge.h"
+
+/*
+r = p + q
+*/
+
+void ge_p3_add(ge_p3 *r, const ge_p3 *p, const ge_p3 *q)
+{
+  ge_cached p_cached;
+  ge_p1p1 r_p1p1;
+
+  ge_p3_to_cached(&p_cached, p);
+  ge_add(&r_p1p1, q, &p_cached);
+  ge_p1p1_to_p3(r, &r_p1p1);
+}
diff --git a/src/curve25519/ed25519/additions/generalized/gen_constants.h b/src/curve25519/ed25519/additions/generalized/gen_constants.h
new file mode 100644
index 0000000..392a88e
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_constants.h
@@ -0,0 +1,19 @@
+#ifndef _GEN_CONSTANTS_H__
+#define _GEN_CONSTANTS_H__
+
+#define LABELSETMAXLEN 512
+#define LABELMAXLEN 128
+#define BUFLEN 1024
+#define BLOCKLEN 128 /* SHA512 */
+#define HASHLEN 64   /* SHA512 */
+#define POINTLEN 32
+#define SCALARLEN 32
+#define RANDLEN 32
+#define SIGNATURELEN 64
+#define VRFSIGNATURELEN 96
+#define VRFOUTPUTLEN 32
+#define MSTART 2048
+#define MSGMAXLEN 1048576
+
+#endif
+
diff --git a/src/curve25519/ed25519/additions/generalized/gen_crypto_additions.h b/src/curve25519/ed25519/additions/generalized/gen_crypto_additions.h
new file mode 100644
index 0000000..569ae26
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_crypto_additions.h
@@ -0,0 +1,16 @@
+
+#ifndef __GEN_CRYPTO_ADDITIONS__
+#define __GEN_CRYPTO_ADDITIONS__
+
+#include "crypto_uint32.h"
+#include "fe.h"
+#include "ge.h"
+
+int sc_isreduced(const unsigned char* s);
+
+int point_isreduced(const unsigned char* p);
+
+void ge_p3_add(ge_p3 *r, const ge_p3 *p, const ge_p3 *q);
+
+#endif
+
diff --git a/src/curve25519/ed25519/additions/generalized/gen_eddsa.c b/src/curve25519/ed25519/additions/generalized/gen_eddsa.c
new file mode 100644
index 0000000..9755d28
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_eddsa.c
@@ -0,0 +1,349 @@
+#include <string.h>
+#include "gen_eddsa.h"
+#include "gen_labelset.h"
+#include "gen_constants.h"
+#include "gen_crypto_additions.h"
+#include "crypto_hash_sha512.h"
+#include "crypto_verify_32.h"
+#include "zeroize.h"
+#include "ge.h"
+#include "sc.h"
+#include "crypto_additions.h"
+#include "utility.h"
+
+/* B: base point 
+ * R: commitment (point), 
+   r: private nonce (scalar)
+   K: encoded public key
+   k: private key (scalar)
+   Z: 32-bytes random
+   M: buffer containing message, message starts at M_start, continues for M_len
+
+   r = hash(B || labelset || Z || pad1 || k || pad2 || labelset || K || extra || M) (mod q)
+*/
+int generalized_commit(unsigned char* R_bytes, unsigned char* r_scalar,
+            const unsigned char* labelset, const unsigned long labelset_len,
+            const unsigned char* extra, const unsigned long extra_len,
+            const unsigned char* K_bytes, const unsigned char* k_scalar, 
+            const unsigned char* Z,
+            unsigned char* M_buf, const unsigned long M_start, const unsigned long M_len)
+{
+  ge_p3 R_point;
+  unsigned char hash[HASHLEN];
+  unsigned char* bufstart = NULL;
+  unsigned char* bufptr = NULL;
+  unsigned char* bufend = NULL;
+  unsigned long prefix_len = 0;
+
+  if (labelset_validate(labelset, labelset_len) != 0)
+    goto err;
+  if (R_bytes == NULL || r_scalar == NULL || 
+      K_bytes == NULL || k_scalar == NULL || 
+      Z == NULL || M_buf == NULL)
+    goto err;
+  if (extra == NULL && extra_len != 0)
+    goto err;
+  if (extra != NULL && extra_len == 0)
+    goto err;
+  if (extra != NULL && labelset_is_empty(labelset, labelset_len))
+    goto err;
+  if (HASHLEN != 64)
+    goto err;
+
+  prefix_len = 0;
+  prefix_len += POINTLEN + labelset_len + RANDLEN;
+  prefix_len += ((BLOCKLEN - (prefix_len % BLOCKLEN)) % BLOCKLEN);
+  prefix_len += SCALARLEN;
+  prefix_len += ((BLOCKLEN - (prefix_len % BLOCKLEN)) % BLOCKLEN);
+  prefix_len += labelset_len + POINTLEN + extra_len;
+  if (prefix_len > M_start)
+    goto err;
+
+  bufstart = M_buf + M_start - prefix_len;
+  bufptr = bufstart;
+  bufend = M_buf + M_start;
+  bufptr = buffer_add(bufptr, bufend, B_bytes, POINTLEN);
+  bufptr = buffer_add(bufptr, bufend, labelset, labelset_len);
+  bufptr = buffer_add(bufptr, bufend, Z, RANDLEN);
+  bufptr = buffer_pad(bufstart, bufptr, bufend);
+  bufptr = buffer_add(bufptr, bufend, k_scalar, SCALARLEN);
+  bufptr = buffer_pad(bufstart, bufptr, bufend);
+  bufptr = buffer_add(bufptr, bufend, labelset, labelset_len);
+  bufptr = buffer_add(bufptr, bufend, K_bytes, POINTLEN);
+  bufptr = buffer_add(bufptr, bufend, extra, extra_len);
+  if (bufptr != bufend || bufptr != M_buf + M_start || bufptr - bufstart != prefix_len)
+    goto err;
+
+  crypto_hash_sha512(hash, M_buf + M_start - prefix_len, prefix_len + M_len);
+  sc_reduce(hash);
+  ge_scalarmult_base(&R_point, hash);
+  ge_p3_tobytes(R_bytes, &R_point);
+  memcpy(r_scalar, hash, SCALARLEN);
+
+  zeroize(hash, HASHLEN);
+  zeroize(bufstart, prefix_len);
+  return 0;
+
+err:
+  zeroize(hash, HASHLEN);
+  zeroize(M_buf, M_start);
+  return -1;
+}
+
+/* if is_labelset_empty(labelset):
+       return hash(R || K || M) (mod q)
+   else:
+       return hash(B || labelset || R || labelset || K || extra || M) (mod q)
+*/
+int generalized_challenge(unsigned char* h_scalar,
+              const unsigned char* labelset, const unsigned long labelset_len,
+              const unsigned char* extra, const unsigned long extra_len,
+              const unsigned char* R_bytes,
+              const unsigned char* K_bytes,
+              unsigned char* M_buf, const unsigned long M_start, const unsigned long M_len)
+{
+  unsigned char hash[HASHLEN];
+  unsigned char* bufstart = NULL;
+  unsigned char* bufptr = NULL;
+  unsigned char* bufend = NULL;
+  unsigned long prefix_len = 0;
+
+  if (h_scalar == NULL)
+    goto err;
+  memset(h_scalar, 0, SCALARLEN);
+
+  if (labelset_validate(labelset, labelset_len) != 0)
+    goto err;
+  if (R_bytes == NULL || K_bytes == NULL || M_buf == NULL)
+    goto err;
+  if (extra == NULL && extra_len != 0)
+    goto err;
+  if (extra != NULL && extra_len == 0)
+    goto err;
+  if (extra != NULL && labelset_is_empty(labelset, labelset_len))
+    goto err;
+  if (HASHLEN != 64)
+    goto err;
+
+  if (labelset_is_empty(labelset, labelset_len)) {
+    if (2*POINTLEN > M_start)
+      goto err;
+    if (extra != NULL || extra_len != 0)
+      goto err;
+    memcpy(M_buf + M_start - (2*POINTLEN),  R_bytes, POINTLEN);
+    memcpy(M_buf + M_start - (1*POINTLEN),  K_bytes, POINTLEN);
+    prefix_len = 2*POINTLEN;
+  } else {
+    prefix_len = 3*POINTLEN + 2*labelset_len + extra_len; 
+    if (prefix_len > M_start)
+      goto err;
+
+    bufstart = M_buf + M_start - prefix_len;
+    bufptr = bufstart;
+    bufend = M_buf + M_start;
+    bufptr = buffer_add(bufptr, bufend, B_bytes, POINTLEN);
+    bufptr = buffer_add(bufptr, bufend, labelset, labelset_len);
+    bufptr = buffer_add(bufptr, bufend, R_bytes, POINTLEN);
+    bufptr = buffer_add(bufptr, bufend, labelset, labelset_len);
+    bufptr = buffer_add(bufptr, bufend, K_bytes, POINTLEN);
+    bufptr = buffer_add(bufptr, bufend, extra, extra_len);
+
+    if (bufptr == NULL)
+      goto err;
+    if (bufptr != bufend || bufptr != M_buf + M_start || bufptr - bufstart != prefix_len)
+      goto err;
+  }
+
+  crypto_hash_sha512(hash, M_buf + M_start - prefix_len, prefix_len + M_len);
+  sc_reduce(hash);
+  memcpy(h_scalar, hash, SCALARLEN);
+  return 0;
+
+err:
+  return -1;
+}
+
+/* return r + kh (mod q) */
+int generalized_prove(unsigned char* out_scalar, 
+    const unsigned char* r_scalar, const unsigned char* k_scalar, const unsigned char* h_scalar)
+{
+  sc_muladd(out_scalar, h_scalar, k_scalar, r_scalar);
+  zeroize_stack();
+  return 0;
+}
+
+/* R = s*B - h*K */
+int generalized_solve_commitment(unsigned char* R_bytes_out,  ge_p3* K_point_out, 
+                                 const ge_p3* B_point, const unsigned char* s_scalar,
+                                 const unsigned char* K_bytes, const unsigned char* h_scalar)
+{
+
+  ge_p3 Kneg_point;
+  ge_p2 R_calc_point_p2;
+
+  ge_p3 sB;
+  ge_p3 hK;
+  ge_p3 R_calc_point_p3;
+
+  if (ge_frombytes_negate_vartime(&Kneg_point, K_bytes) != 0) 
+    return -1;
+
+  if (B_point == NULL) {
+    ge_double_scalarmult_vartime(&R_calc_point_p2, h_scalar, &Kneg_point, s_scalar);
+    ge_tobytes(R_bytes_out, &R_calc_point_p2); 
+  }
+  else {
+    // s * Bv
+    ge_scalarmult(&sB, s_scalar, B_point);
+
+    // h * -K
+    ge_scalarmult(&hK, h_scalar, &Kneg_point);
+
+    // R = sB - hK
+    ge_p3_add(&R_calc_point_p3, &sB, &hK);
+    ge_p3_tobytes(R_bytes_out, &R_calc_point_p3);
+  }
+
+  if (K_point_out) {
+    ge_neg(K_point_out, &Kneg_point);
+  }
+
+  return 0;
+}
+    
+
+int generalized_eddsa_25519_sign(
+                  unsigned char* signature_out,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* eddsa_25519_privkey_scalar,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* random,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char labelset[LABELSETMAXLEN];
+  unsigned long labelset_len = 0;
+  unsigned char R_bytes[POINTLEN];
+  unsigned char r_scalar[SCALARLEN];
+  unsigned char h_scalar[SCALARLEN];
+  unsigned char s_scalar[SCALARLEN];
+  unsigned char* M_buf = NULL;
+
+  if (signature_out == NULL)
+    goto err;
+  memset(signature_out, 0, SIGNATURELEN);
+
+  if (eddsa_25519_pubkey_bytes == NULL)
+    goto err;
+  if (eddsa_25519_privkey_scalar == NULL)
+    goto err;
+  if (msg == NULL)
+    goto err;
+  if (customization_label == NULL && customization_label_len != 0)
+    goto err;
+  if (customization_label_len > LABELMAXLEN)
+    goto err;
+  if (msg_len > MSGMAXLEN)
+    goto err;
+
+  if ((M_buf = malloc(msg_len + MSTART)) == 0)
+    goto err;
+  memcpy(M_buf + MSTART, msg, msg_len);
+
+  if (labelset_new(labelset, &labelset_len, LABELSETMAXLEN, NULL, 0, 
+                   customization_label, customization_label_len) != 0)
+    goto err;
+
+  if (generalized_commit(R_bytes, r_scalar, labelset, labelset_len, NULL, 0, 
+                         eddsa_25519_pubkey_bytes, eddsa_25519_privkey_scalar, 
+                         random, M_buf, MSTART, msg_len) != 0)
+    goto err;
+
+  if (generalized_challenge(h_scalar, labelset, labelset_len, NULL, 0, 
+                            R_bytes, eddsa_25519_pubkey_bytes, M_buf, MSTART, msg_len) != 0)
+    goto err;
+
+  if (generalized_prove(s_scalar, r_scalar, eddsa_25519_privkey_scalar, h_scalar) != 0)
+    goto err;
+
+  memcpy(signature_out, R_bytes, POINTLEN);
+  memcpy(signature_out + POINTLEN, s_scalar, SCALARLEN);
+
+  zeroize(r_scalar, SCALARLEN);
+  zeroize_stack();
+  free(M_buf);
+  return 0;
+
+err:
+  zeroize(r_scalar, SCALARLEN);
+  zeroize_stack();
+  free(M_buf);
+  return -1;
+}
+
+int generalized_eddsa_25519_verify(
+                  const unsigned char* signature,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char labelset[LABELSETMAXLEN];
+  unsigned long labelset_len = 0;
+  const unsigned char* R_bytes = NULL;
+  const unsigned char* s_scalar = NULL;
+  unsigned char h_scalar[SCALARLEN];
+  unsigned char* M_buf = NULL;
+  unsigned char R_calc_bytes[POINTLEN];
+
+  if (signature == NULL)
+    goto err;
+  if (eddsa_25519_pubkey_bytes == NULL)
+    goto err;
+  if (msg == NULL)
+    goto err;
+  if (customization_label == NULL && customization_label_len != 0)
+    goto err;
+  if (customization_label_len > LABELMAXLEN)
+    goto err;
+  if (msg_len > MSGMAXLEN)
+    goto err;
+
+  if ((M_buf = malloc(msg_len + MSTART)) == 0)
+    goto err;
+  memcpy(M_buf + MSTART, msg, msg_len);
+
+  if (labelset_new(labelset, &labelset_len, LABELSETMAXLEN, NULL, 0, 
+                   customization_label, customization_label_len) != 0)
+    goto err;
+
+  R_bytes = signature;
+  s_scalar = signature + POINTLEN;
+
+  if (!point_isreduced(eddsa_25519_pubkey_bytes))
+    goto err;
+  if (!point_isreduced(R_bytes))
+    goto err;
+  if (!sc_isreduced(s_scalar))
+    goto err;
+
+  if (generalized_challenge(h_scalar, labelset, labelset_len, 
+                            NULL, 0, R_bytes, eddsa_25519_pubkey_bytes, M_buf, MSTART, msg_len) != 0)
+    goto err;
+
+  if (generalized_solve_commitment(R_calc_bytes, NULL, NULL, 
+                                   s_scalar, eddsa_25519_pubkey_bytes, h_scalar) != 0)
+    goto err;
+
+  if (crypto_verify_32(R_bytes, R_calc_bytes) != 0)
+    goto err;
+
+  free(M_buf);
+  return 0;
+
+err:
+  free(M_buf);
+  return -1;
+}
diff --git a/src/curve25519/ed25519/additions/generalized/gen_eddsa.h b/src/curve25519/ed25519/additions/generalized/gen_eddsa.h
new file mode 100644
index 0000000..0c281bc
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_eddsa.h
@@ -0,0 +1,65 @@
+#ifndef __GEN_EDDSA_H__
+#define __GEN_EDDSA_H__
+
+#include "ge.h"
+
+/* B: base point 
+   R: commitment (point), 
+   r: private nonce (scalar)
+   K: encoded public key
+   k: private key (scalar)
+   Z: 32-bytes random
+   M: buffer containing message, message starts at M_start, continues for M_len
+
+   r = hash(B || labelset || Z || pad1 || k || pad2 || labelset || K || extra || M) (mod q)
+*/
+int generalized_commit(unsigned char* R_bytes, unsigned char* r_scalar,
+            const unsigned char* labelset, const unsigned long labelset_len,
+            const unsigned char* extra, const unsigned long extra_len,
+            const unsigned char* K_bytes, const unsigned char* k_scalar, 
+            const unsigned char* Z,
+            unsigned char* M_buf, const unsigned long M_start, const unsigned long M_len);
+
+/* if is_labelset_empty(labelset):
+       return hash(R || K || M) (mod q)
+   else:
+       return hash(B || labelset || R || labelset || K || extra || M) (mod q)
+*/
+int generalized_challenge(unsigned char* h_scalar,
+              const unsigned char* labelset, const unsigned long labelset_len,
+              const unsigned char* extra, const unsigned long extra_len,
+              const unsigned char* R_bytes,
+              const unsigned char* K_bytes,
+              unsigned char* M_buf, const unsigned long M_start, const unsigned long M_len);
+
+/* return r + kh (mod q) */
+int generalized_prove(unsigned char* out_scalar, 
+    const unsigned char* r_scalar, 
+    const unsigned char* k_scalar, 
+    const unsigned char* h_scalar);
+
+/* R = B^s / K^h */
+int generalized_solve_commitment(unsigned char* R_bytes_out,  ge_p3* K_point_out, 
+                     const ge_p3* B_point, const unsigned char* s_scalar,
+                     const unsigned char* K_bytes, const unsigned char* h_scalar);
+  
+
+int generalized_eddsa_25519_sign(
+                  unsigned char* signature_out,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* eddsa_25519_privkey_scalar,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* random,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+int generalized_eddsa_25519_verify(
+                  const unsigned char* signature,
+                  const unsigned char* eddsa_25519_pubkey,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+#endif
diff --git a/src/curve25519/ed25519/additions/generalized/gen_labelset.c b/src/curve25519/ed25519/additions/generalized/gen_labelset.c
new file mode 100644
index 0000000..b181cad
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_labelset.c
@@ -0,0 +1,157 @@
+#include <stdlib.h>
+#include <string.h>
+#include "gen_labelset.h"
+#include "gen_constants.h"
+
+const unsigned char B_bytes[] = {
+  0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+};
+
+unsigned char* buffer_add(unsigned char* bufptr, const unsigned char* bufend,
+                          const unsigned char* in, const unsigned long in_len)
+{
+  unsigned long count = 0;
+
+  if (bufptr == NULL || bufend == NULL || bufptr > bufend)
+    return NULL;
+  if (in == NULL && in_len != 0)
+    return NULL;
+  if (bufend - bufptr < in_len)
+    return NULL;
+
+  for (count=0; count < in_len; count++) {
+    if (bufptr >= bufend)
+      return NULL;
+    *bufptr++ = *in++;
+  }
+  return bufptr;
+}
+
+unsigned char* buffer_pad(const unsigned char* buf, unsigned char* bufptr, const unsigned char* bufend)
+{
+  unsigned long count = 0;
+  unsigned long pad_len = 0;
+
+  if (buf == NULL || bufptr == NULL || bufend == NULL || bufptr >= bufend || bufptr < buf)
+    return NULL;
+
+  pad_len = (BLOCKLEN - ((bufptr-buf) % BLOCKLEN)) % BLOCKLEN;
+  if (bufend - bufptr < pad_len)
+    return NULL;
+
+  for (count=0; count < pad_len; count++) {
+    if (bufptr >= bufend)
+      return NULL;
+    *bufptr++ = 0;
+  }
+  return bufptr;
+}
+
+int labelset_new(unsigned char* labelset, unsigned long* labelset_len, const unsigned long labelset_maxlen,
+                 const unsigned char* protocol_name, const unsigned char protocol_name_len,
+                 const unsigned char* customization_label, const unsigned char customization_label_len)
+{
+  unsigned char* bufptr;
+
+  *labelset_len = 0;
+  if (labelset == NULL)
+    return -1;
+  if (labelset_len == NULL)
+    return -1;
+  if (labelset_maxlen > LABELSETMAXLEN)
+    return -1;
+  if (labelset_maxlen < 3 + protocol_name_len + customization_label_len)
+    return -1;
+  if (protocol_name == NULL && protocol_name_len != 0)
+    return -1;
+  if (customization_label == NULL && customization_label_len != 0)
+    return -1;
+  if (protocol_name_len > LABELMAXLEN)
+    return -1;
+  if (customization_label_len > LABELMAXLEN)
+    return -1;
+
+  bufptr = labelset;
+  *bufptr++ = 2;
+  *bufptr++ = protocol_name_len;
+  bufptr = buffer_add(bufptr, labelset + labelset_maxlen, protocol_name, protocol_name_len); 
+  if (bufptr != NULL && bufptr < labelset + labelset_maxlen)
+    *bufptr++ = customization_label_len;
+  bufptr = buffer_add(bufptr, labelset + labelset_maxlen, 
+                      customization_label, customization_label_len);
+
+  if (bufptr != NULL && bufptr - labelset == 3 + protocol_name_len + customization_label_len) {
+    *labelset_len = bufptr - labelset;
+    return 0;
+  }
+  return -1;
+}
+
+
+int labelset_add(unsigned char* labelset, unsigned long* labelset_len, const unsigned long labelset_maxlen,
+              const unsigned char* label, const unsigned char label_len)
+{
+  unsigned char* bufptr;
+  if (labelset_len == NULL)
+    return -1;
+  if (*labelset_len > LABELSETMAXLEN || labelset_maxlen > LABELSETMAXLEN)
+    return -1;
+  if (*labelset_len >= labelset_maxlen || *labelset_len + label_len + 1 > labelset_maxlen)
+    return -1;
+  if (*labelset_len < 3 || labelset_maxlen < 4)
+    return -1;
+  if (label_len > LABELMAXLEN)
+    return -1;
+
+  labelset[0]++;
+  labelset[*labelset_len] = label_len;
+  bufptr = labelset + *labelset_len + 1;
+  bufptr = buffer_add(bufptr, labelset + labelset_maxlen, label, label_len);
+  if (bufptr == NULL)
+    return -1;
+  if (bufptr - labelset >= labelset_maxlen)
+    return -1;
+  if (bufptr - labelset != *labelset_len + 1 + label_len)
+    return -1;
+
+  *labelset_len += (1 + label_len);
+  return 0;
+}
+
+int labelset_validate(const unsigned char* labelset, const unsigned long labelset_len)
+{
+  unsigned char num_labels = 0;
+  unsigned char count = 0;
+  unsigned long offset = 0;
+  unsigned char label_len = 0;
+
+  if (labelset == NULL)
+    return -1;
+  if (labelset_len < 3 || labelset_len > LABELSETMAXLEN)
+    return -1;
+
+  num_labels = labelset[0];
+  offset = 1;
+  for (count = 0; count < num_labels; count++) {
+    label_len = labelset[offset];
+    if (label_len > LABELMAXLEN)
+      return -1;
+    offset += 1 + label_len;
+    if (offset > labelset_len)
+      return -1;
+  }
+  if (offset != labelset_len)
+    return -1;
+  return 0;
+}
+
+int labelset_is_empty(const unsigned char* labelset, const unsigned long labelset_len)
+{
+  if (labelset_len != 3)
+    return 0;
+  return 1;
+}
+
diff --git a/src/curve25519/ed25519/additions/generalized/gen_labelset.h b/src/curve25519/ed25519/additions/generalized/gen_labelset.h
new file mode 100644
index 0000000..6ac40da
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_labelset.h
@@ -0,0 +1,23 @@
+#ifndef __GEN_LABELSET_H__
+#define __GEN_LABELSET_H__
+
+extern const unsigned char B_bytes[];
+
+unsigned char* buffer_add(unsigned char* bufptr, const unsigned char* bufend,
+                          const unsigned char* in, const unsigned long in_len);
+
+unsigned char* buffer_pad(const unsigned char* buf, unsigned char* bufptr, const unsigned char* bufend);
+
+
+int labelset_new(unsigned char* labelset, unsigned long* labelset_len, const unsigned long labelset_maxlen,
+                 const unsigned char* protocol_name, const unsigned char protocol_name_len,
+                 const unsigned char* customization_label, const unsigned char customization_label_len);
+
+int labelset_add(unsigned char* labelset, unsigned long* labelset_len, const unsigned long labelset_maxlen,
+              const unsigned char* label, const unsigned char label_len);
+
+int labelset_validate(const unsigned char* labelset, const unsigned long labelset_len);
+
+int labelset_is_empty(const unsigned char* labelset, const unsigned long labelset_len);
+
+#endif
diff --git a/src/curve25519/ed25519/additions/generalized/gen_veddsa.c b/src/curve25519/ed25519/additions/generalized/gen_veddsa.c
new file mode 100644
index 0000000..4e79b48
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_veddsa.c
@@ -0,0 +1,312 @@
+#include <string.h>
+#include "gen_eddsa.h"
+#include "gen_veddsa.h"
+#include "gen_constants.h"
+#include "gen_labelset.h"
+#include "gen_crypto_additions.h"
+#include "crypto_hash_sha512.h"
+#include "crypto_verify_32.h"
+#include "crypto_additions.h"
+#include "zeroize.h"
+#include "ge.h"
+#include "sc.h"
+#include "utility.h"
+
+static int generalized_calculate_Bv(ge_p3* Bv_point, 
+                              const unsigned char* labelset, const unsigned long labelset_len,
+                              const unsigned char* K_bytes,
+                              unsigned char* M_buf, const unsigned long M_start, const unsigned long M_len)
+{
+  unsigned char* bufptr;
+  unsigned long prefix_len = 0;
+
+  if (labelset_validate(labelset, labelset_len) != 0)
+    return -1;
+  if (Bv_point == NULL || K_bytes == NULL || M_buf == NULL)
+    return -1;
+
+  prefix_len = 2*POINTLEN + labelset_len;
+  if (prefix_len > M_start)
+    return -1;
+
+  bufptr = M_buf + M_start - prefix_len;
+  bufptr = buffer_add(bufptr, M_buf + M_start, B_bytes, POINTLEN);
+  bufptr = buffer_add(bufptr, M_buf + M_start, labelset, labelset_len);
+  bufptr = buffer_add(bufptr, M_buf + M_start, K_bytes, POINTLEN);
+  if (bufptr == NULL || bufptr != M_buf + M_start)
+    return -1;
+
+  hash_to_point(Bv_point, M_buf + M_start - prefix_len, prefix_len + M_len);
+  if (ge_isneutral(Bv_point))
+    return -1;
+  return 0;
+}
+
+static int generalized_calculate_vrf_output(unsigned char* vrf_output,
+                                     const unsigned char* labelset, const unsigned long labelset_len,
+                                     const ge_p3* cKv_point)
+{
+  unsigned char buf[BUFLEN];
+  unsigned char* bufptr = buf;
+  unsigned char* bufend = buf + BUFLEN;
+  unsigned char cKv_bytes[POINTLEN];
+  unsigned char hash[HASHLEN];
+
+  if (vrf_output == NULL)
+    return -1;
+  memset(vrf_output, 0, VRFOUTPUTLEN);
+
+  if (labelset_len + 2*POINTLEN > BUFLEN)
+    return -1;
+  if (labelset_validate(labelset, labelset_len) != 0)
+    return -1;
+  if (cKv_point == NULL)
+    return -1;
+  if (VRFOUTPUTLEN > HASHLEN)
+    return -1;
+
+  ge_p3_tobytes(cKv_bytes, cKv_point);
+
+  bufptr = buffer_add(bufptr, bufend, B_bytes, POINTLEN);
+  bufptr = buffer_add(bufptr, bufend, labelset, labelset_len);
+  bufptr = buffer_add(bufptr, bufend, cKv_bytes, POINTLEN);
+  if (bufptr == NULL)
+    return -1;
+  if (bufptr - buf > BUFLEN)
+    return -1;
+  crypto_hash_sha512(hash, buf, bufptr - buf);
+  memcpy(vrf_output, hash, VRFOUTPUTLEN);
+  return 0;
+}
+
+int generalized_veddsa_25519_sign(
+                  unsigned char* signature_out,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* eddsa_25519_privkey_scalar,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* random,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char labelset[LABELSETMAXLEN];
+  unsigned long labelset_len = 0;
+  ge_p3 Bv_point;
+  ge_p3 Kv_point;
+  ge_p3 Rv_point;
+  unsigned char Bv_bytes[POINTLEN];
+  unsigned char Kv_bytes[POINTLEN];
+  unsigned char Rv_bytes[POINTLEN];
+  unsigned char R_bytes[POINTLEN];
+  unsigned char r_scalar[SCALARLEN];
+  unsigned char h_scalar[SCALARLEN];
+  unsigned char s_scalar[SCALARLEN];
+  unsigned char extra[3*POINTLEN];
+  unsigned char* M_buf = NULL;
+  char* protocol_name = "VEdDSA_25519_SHA512_Elligator2";
+
+  if (signature_out == NULL)
+    goto err;
+  memset(signature_out, 0, VRFSIGNATURELEN);
+
+  if (eddsa_25519_pubkey_bytes == NULL)
+    goto err;
+  if (eddsa_25519_privkey_scalar == NULL)
+    goto err;
+  if (msg == NULL)
+    goto err;
+  if (customization_label == NULL && customization_label_len != 0)
+    goto err;
+  if (customization_label_len > LABELMAXLEN)
+    goto err;
+  if (msg_len > MSGMAXLEN)
+    goto err;
+
+  if ((M_buf = malloc(msg_len + MSTART)) == 0) {
+    goto err;
+  }
+  memcpy(M_buf + MSTART, msg, msg_len);
+
+  //  labelset = new_labelset(protocol_name, customization_label)
+  if (labelset_new(labelset, &labelset_len, LABELSETMAXLEN, 
+                   (unsigned char*)protocol_name, strlen(protocol_name), 
+                   customization_label, customization_label_len) != 0)
+    goto err;
+
+  //  labelset1 = add_label(labels, "1")
+  //  Bv = hash(hash(labelset1 || K) || M)
+  //  Kv = k * Bv
+  labelset_add(labelset, &labelset_len, LABELSETMAXLEN, (unsigned char*)"1", 1);
+  if (generalized_calculate_Bv(&Bv_point, labelset, labelset_len, 
+                               eddsa_25519_pubkey_bytes, M_buf, MSTART, msg_len) != 0)
+    goto err;
+  ge_scalarmult(&Kv_point, eddsa_25519_privkey_scalar, &Bv_point);
+  ge_p3_tobytes(Bv_bytes, &Bv_point);
+  ge_p3_tobytes(Kv_bytes, &Kv_point);
+
+  //  labelset2 = add_label(labels, "2")
+  //  R, r = commit(labelset2, (Bv || Kv), (K,k), Z, M) 
+  labelset[labelset_len-1] = (unsigned char)'2';
+  memcpy(extra, Bv_bytes, POINTLEN);
+  memcpy(extra + POINTLEN, Kv_bytes, POINTLEN);
+  if (generalized_commit(R_bytes, r_scalar, 
+                         labelset, labelset_len, 
+                         extra, 2*POINTLEN, 
+                         eddsa_25519_pubkey_bytes, eddsa_25519_privkey_scalar, 
+                         random, M_buf, MSTART, msg_len) != 0)
+    goto err;
+
+  //  Rv = r * Bv
+  ge_scalarmult(&Rv_point, r_scalar, &Bv_point);
+  ge_p3_tobytes(Rv_bytes, &Rv_point);
+
+  //  labelset3 = add_label(labels, "3")
+  //  h = challenge(labelset3, (Bv || Kv || Rv), R, K, M)  
+  labelset[labelset_len-1] = (unsigned char)'3';
+  memcpy(extra + 2*POINTLEN, Rv_bytes, POINTLEN);
+  if (generalized_challenge(h_scalar, 
+                            labelset, labelset_len, 
+                            extra, 3*POINTLEN, 
+                            R_bytes, eddsa_25519_pubkey_bytes, 
+                            M_buf, MSTART, msg_len) != 0)
+    goto err;
+
+  //  s = prove(r, k, h)
+  if (generalized_prove(s_scalar, r_scalar, eddsa_25519_privkey_scalar, h_scalar) != 0)
+    goto err;
+
+  //  return (Kv || h || s)
+  memcpy(signature_out, Kv_bytes, POINTLEN);
+  memcpy(signature_out + POINTLEN, h_scalar, SCALARLEN);
+  memcpy(signature_out + POINTLEN + SCALARLEN, s_scalar, SCALARLEN);
+
+  zeroize(r_scalar, SCALARLEN);
+  zeroize_stack();
+  free(M_buf);
+  return 0;
+
+err:
+  zeroize(r_scalar, SCALARLEN);
+  zeroize_stack();
+  free(M_buf);
+  return -1;
+}
+
+int generalized_veddsa_25519_verify(
+                  unsigned char* vrf_out,
+                  const unsigned char* signature,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char labelset[LABELSETMAXLEN];
+  unsigned long labelset_len = 0;
+  const unsigned char* Kv_bytes;
+  const unsigned char* h_scalar;
+  const unsigned char* s_scalar;
+  ge_p3 Bv_point, K_point, Kv_point, cK_point, cKv_point;
+  unsigned char Bv_bytes[POINTLEN];
+  unsigned char R_calc_bytes[POINTLEN];
+  unsigned char Rv_calc_bytes[POINTLEN];
+  unsigned char h_calc_scalar[SCALARLEN];
+  unsigned char extra[3*POINTLEN];
+  unsigned char* M_buf = NULL;
+  char* protocol_name = "VEdDSA_25519_SHA512_Elligator2";
+
+  if (vrf_out == NULL)
+    goto err;
+  memset(vrf_out, 0, VRFOUTPUTLEN);
+
+  if (signature == NULL)
+    goto err;
+  if (eddsa_25519_pubkey_bytes == NULL)
+    goto err;
+  if (msg == NULL)
+    goto err;
+  if (customization_label == NULL && customization_label_len != 0)
+    goto err;
+  if (customization_label_len > LABELMAXLEN)
+    goto err;
+  if (msg_len > MSGMAXLEN)
+    goto err;
+
+  if ((M_buf = malloc(msg_len + MSTART)) == 0) {
+    goto err;
+  }
+  memcpy(M_buf + MSTART, msg, msg_len);
+
+  Kv_bytes = signature;
+  h_scalar = signature + POINTLEN;
+  s_scalar = signature + POINTLEN + SCALARLEN;
+
+  if (!point_isreduced(eddsa_25519_pubkey_bytes))
+    goto err;
+  if (!point_isreduced(Kv_bytes))
+    goto err;
+  if (!sc_isreduced(h_scalar))
+    goto err;
+  if (!sc_isreduced(s_scalar))
+    goto err;
+
+  //  labelset = new_labelset(protocol_name, customization_label)
+  if (labelset_new(labelset, &labelset_len, LABELSETMAXLEN, 
+                   (unsigned char*)protocol_name, strlen(protocol_name), 
+                   customization_label, customization_label_len) != 0)
+    goto err;
+
+  //  labelset1 = add_label(labels, "1")
+  //  Bv = hash(hash(labelset1 || K) || M)
+  labelset_add(labelset, &labelset_len, LABELSETMAXLEN, (unsigned char*)"1", 1);
+  if (generalized_calculate_Bv(&Bv_point, labelset, labelset_len, 
+                               eddsa_25519_pubkey_bytes, M_buf, MSTART, msg_len) != 0)
+    goto err;
+  ge_p3_tobytes(Bv_bytes, &Bv_point);
+
+  //  R = solve_commitment(B, s, K, h)
+  if (generalized_solve_commitment(R_calc_bytes, &K_point, NULL, 
+                                   s_scalar, eddsa_25519_pubkey_bytes, h_scalar) != 0)
+    goto err;
+
+  //  Rv = solve_commitment(Bv, s, Kv, h)
+  if (generalized_solve_commitment(Rv_calc_bytes, &Kv_point, &Bv_point, 
+                                   s_scalar, Kv_bytes, h_scalar) != 0)
+    goto err;
+
+  ge_scalarmult_cofactor(&cK_point, &K_point);
+  ge_scalarmult_cofactor(&cKv_point, &Kv_point);
+  if (ge_isneutral(&cK_point) || ge_isneutral(&cKv_point) || ge_isneutral(&Bv_point))
+    goto err;
+
+  //  labelset3 = add_label(labels, "3")
+  //  h = challenge(labelset3, (Bv || Kv || Rv), R, K, M)  
+  labelset[labelset_len-1] = (unsigned char)'3';
+  memcpy(extra, Bv_bytes, POINTLEN);
+  memcpy(extra + POINTLEN, Kv_bytes, POINTLEN);
+  memcpy(extra + 2*POINTLEN, Rv_calc_bytes, POINTLEN);
+  if (generalized_challenge(h_calc_scalar, 
+                            labelset, labelset_len, 
+                            extra, 3*POINTLEN, 
+                            R_calc_bytes, eddsa_25519_pubkey_bytes, 
+                            M_buf, MSTART, msg_len) != 0)
+    goto err;
+
+  // if bytes_equal(h, h')
+  if (crypto_verify_32(h_scalar, h_calc_scalar) != 0)
+    goto err;
+
+  //  labelset4 = add_label(labels, "4")
+  //  v = hash(labelset4 || c*Kv)
+  labelset[labelset_len-1] = (unsigned char)'4';
+  if (generalized_calculate_vrf_output(vrf_out, labelset, labelset_len, &cKv_point) != 0)
+    goto err;
+
+  free(M_buf);
+  return 0;
+
+err:
+  free(M_buf);
+  return -1;
+}
+
diff --git a/src/curve25519/ed25519/additions/generalized/gen_veddsa.h b/src/curve25519/ed25519/additions/generalized/gen_veddsa.h
new file mode 100644
index 0000000..1bc27a6
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_veddsa.h
@@ -0,0 +1,23 @@
+#ifndef __GEN_VEDDSA_H__
+#define __GEN_VEDDSA_H__
+
+int generalized_veddsa_25519_sign(
+                  unsigned char* signature_out,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* eddsa_25519_privkey_scalar,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* random,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+int generalized_veddsa_25519_verify(
+                  unsigned char* vrf_out,
+                  const unsigned char* signature,
+                  const unsigned char* eddsa_25519_pubkey_bytes,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+#endif
diff --git a/src/curve25519/ed25519/additions/generalized/gen_x.c b/src/curve25519/ed25519/additions/generalized/gen_x.c
new file mode 100644
index 0000000..d4df5c1
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_x.c
@@ -0,0 +1,131 @@
+#include <string.h>
+#include "crypto_additions.h"
+#include "gen_x.h"
+#include "gen_constants.h"
+#include "gen_eddsa.h"
+#include "gen_veddsa.h"
+#include "gen_crypto_additions.h"
+#include "zeroize.h"
+
+static int convert_25519_pubkey(unsigned char* ed_pubkey_bytes, const unsigned char* x25519_pubkey_bytes) {
+  fe u;
+  fe y;
+
+  /* Convert the X25519 public key into an Ed25519 public key.
+
+     y = (u - 1) / (u + 1)
+
+     NOTE: u=-1 is converted to y=0 since fe_invert is mod-exp
+  */
+  if (!fe_isreduced(x25519_pubkey_bytes))
+      return -1;
+  fe_frombytes(u, x25519_pubkey_bytes);
+  fe_montx_to_edy(y, u);
+  fe_tobytes(ed_pubkey_bytes, y);
+  return 0;
+}
+
+static int calculate_25519_keypair(unsigned char* K_bytes, unsigned char* k_scalar, 
+                            const unsigned char* x25519_privkey_scalar)
+{
+  unsigned char kneg[SCALARLEN];
+  ge_p3 ed_pubkey_point;
+  unsigned char sign_bit = 0;
+
+  if (SCALARLEN != 32)
+    return -1;
+
+  /* Convert the Curve25519 privkey to an Ed25519 public key */
+  ge_scalarmult_base(&ed_pubkey_point, x25519_privkey_scalar);
+  ge_p3_tobytes(K_bytes, &ed_pubkey_point);
+
+  /* Force Edwards sign bit to zero */
+  sign_bit = (K_bytes[31] & 0x80) >> 7;
+  memcpy(k_scalar, x25519_privkey_scalar, 32);
+  sc_neg(kneg, k_scalar);
+  sc_cmov(k_scalar, kneg, sign_bit); 
+  K_bytes[31] &= 0x7F;
+
+  zeroize(kneg, SCALARLEN);
+  return 0;
+}
+
+int generalized_xeddsa_25519_sign(unsigned char* signature_out,
+                              const unsigned char* x25519_privkey_scalar,
+                              const unsigned char* msg, const unsigned long msg_len,
+                              const unsigned char* random,
+                              const unsigned char* customization_label,
+                              const unsigned long customization_label_len)
+{
+  unsigned char K_bytes[POINTLEN];
+  unsigned char k_scalar[SCALARLEN];
+  int retval = -1;
+
+  if (calculate_25519_keypair(K_bytes, k_scalar, x25519_privkey_scalar) != 0)
+    return -1;
+
+  retval = generalized_eddsa_25519_sign(signature_out, 
+                                        K_bytes, k_scalar,
+                                        msg, msg_len, random, 
+                                        customization_label, customization_label_len);
+  zeroize(k_scalar, SCALARLEN);
+  return retval;
+}
+
+int generalized_xveddsa_25519_sign(
+                  unsigned char* signature_out,
+                  const unsigned char* x25519_privkey_scalar,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* random,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char K_bytes[POINTLEN];
+  unsigned char k_scalar[SCALARLEN];
+  int retval = -1;
+
+  if (calculate_25519_keypair(K_bytes, k_scalar, x25519_privkey_scalar) != 0)
+    return -1;
+
+  retval = generalized_veddsa_25519_sign(signature_out, K_bytes, k_scalar, 
+                                         msg, msg_len, random, 
+                                         customization_label, customization_label_len);
+  zeroize(k_scalar, SCALARLEN);
+  return retval;
+}
+
+int generalized_xeddsa_25519_verify(
+                  const unsigned char* signature,
+                  const unsigned char* x25519_pubkey_bytes,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char K_bytes[POINTLEN];
+
+  if (convert_25519_pubkey(K_bytes, x25519_pubkey_bytes) != 0)
+      return -1;
+
+  return generalized_eddsa_25519_verify(signature, K_bytes, msg, msg_len, 
+                                        customization_label, customization_label_len);
+}
+
+int generalized_xveddsa_25519_verify(
+                  unsigned char* vrf_out,
+                  const unsigned char* signature,
+                  const unsigned char* x25519_pubkey_bytes,
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len)
+{
+  unsigned char K_bytes[POINTLEN];
+
+  if (convert_25519_pubkey(K_bytes, x25519_pubkey_bytes) != 0)
+      return -1;
+
+  return generalized_veddsa_25519_verify(vrf_out, signature, K_bytes, msg, msg_len, 
+                                         customization_label, customization_label_len);
+}
diff --git a/src/curve25519/ed25519/additions/generalized/gen_x.h b/src/curve25519/ed25519/additions/generalized/gen_x.h
new file mode 100644
index 0000000..3c4c04c
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/gen_x.h
@@ -0,0 +1,37 @@
+#ifndef __GEN_X_H
+#define __GEN_X_H
+
+int generalized_xeddsa_25519_sign(unsigned char* signature_out, /* 64 bytes */
+                              const unsigned char* x25519_privkey_scalar, /* 32 bytes */
+                              const unsigned char* msg, const unsigned long msg_len,
+                              const unsigned char* random, /* 32 bytes */
+                              const unsigned char* customization_label,
+                              const unsigned long customization_label_len);
+
+int generalized_xeddsa_25519_verify(
+                  const unsigned char* signature, /* 64 bytes */
+                  const unsigned char* x25519_pubkey_bytes, /* 32 bytes */
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+int generalized_xveddsa_25519_sign(
+                  unsigned char* signature_out, /* 96 bytes */
+                  const unsigned char* x25519_privkey_scalar, /* 32 bytes */
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* random, /* 32 bytes */
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+int generalized_xveddsa_25519_verify(
+                  unsigned char* vrf_out, /* 32 bytes */
+                  const unsigned char* signature, /* 96 bytes */
+                  const unsigned char* x25519_pubkey_bytes, /* 32 bytes */
+                  const unsigned char* msg, 
+                  const unsigned long msg_len,
+                  const unsigned char* customization_label,
+                  const unsigned long customization_label_len);
+
+#endif
diff --git a/src/curve25519/ed25519/additions/generalized/point_isreduced.c b/src/curve25519/ed25519/additions/generalized/point_isreduced.c
new file mode 100644
index 0000000..5541ffe
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/point_isreduced.c
@@ -0,0 +1,12 @@
+#include<string.h>
+#include "fe.h"
+#include "crypto_additions.h"
+
+int point_isreduced(const unsigned char* p)
+{
+  unsigned char strict[32];
+ 
+  memmove(strict, p, 32);
+  strict[31] &= 0x7F; /* mask off sign bit */
+  return fe_isreduced(strict);
+}
diff --git a/src/curve25519/ed25519/additions/generalized/sc_isreduced.c b/src/curve25519/ed25519/additions/generalized/sc_isreduced.c
new file mode 100644
index 0000000..2419380
--- /dev/null
+++ b/src/curve25519/ed25519/additions/generalized/sc_isreduced.c
@@ -0,0 +1,17 @@
+#include <string.h>
+#include "fe.h"
+#include "sc.h"
+#include "crypto_additions.h"
+#include "crypto_verify_32.h"
+
+int sc_isreduced(const unsigned char* s)
+{
+  unsigned char strict[64];
+
+  memset(strict, 0, 64);
+  memmove(strict, s, 32);
+  sc_reduce(strict);
+  if (crypto_verify_32(strict, s) != 0)
+    return 0;
+  return 1;
+}
diff --git a/src/curve25519/ed25519/additions/uopen_modified.c b/src/curve25519/ed25519/additions/uopen_modified.c
deleted file mode 100644
index 412f8c4..0000000
--- a/src/curve25519/ed25519/additions/uopen_modified.c
+++ /dev/null
@@ -1,100 +0,0 @@
-#include <string.h>
-#include "sc.h"
-#include "ge.h"
-#include "crypto_hash_sha512.h"
-#include "crypto_verify_32.h"
-#include "crypto_additions.h"
-#include "crypto_sign.h"
-
-int crypto_usign_open_modified(
-  unsigned char *m,unsigned long long *mlen,
-  const unsigned char *sm,unsigned long long smlen,
-  const unsigned char *pk, const ge_p3* Bu
-)
-{
-  ge_p3 U;
-  unsigned char h[64];
-  unsigned char s[64];
-  unsigned char strict[64];
-  ge_p3 A;
-  ge_p2 R;
-  unsigned char hcheck[64];
-  int count;
-
-  if (smlen < 96) goto badsig;
-  if (sm[63] & 224) goto badsig; /* strict parsing of h */
-  if (sm[95] & 224) goto badsig; /* strict parsing of s */
-
-  /* Load -A */
-  if (ge_frombytes_negate_vartime(&A,pk) != 0) goto badsig;
-
-  /* Load -U, h, s */
-  ge_frombytes_negate_vartime(&U, sm);
-  memset(h, 0, 64);
-  memset(s, 0, 64);
-  memmove(h, sm + 32, 32); 
-  memmove(s, sm + 64, 32); 
-
-  /* Insist that s and h are reduced scalars (strict parsing) */
-  memcpy(strict, h, 64);
-  sc_reduce(strict);
-  if (memcmp(strict, h, 32) != 0)
-    goto badsig;
-  memcpy(strict, s, 64);
-  sc_reduce(strict);
-  if (memcmp(strict, s, 32) != 0)
-    goto badsig;
-
-  /* Reject U (actually -U) if small order */
-  if (ge_is_small_order(&U))
-    goto badsig;
-
-  // R = sB + h(-A)
-  ge_double_scalarmult_vartime(&R,h,&A,s);
-
-  // Ru = sBu + h(-U)
-  ge_p3 sBu, hU;
-
-  // sBu
-  ge_scalarmult(&sBu, s, Bu);
-
-  // h(-U)
-  ge_scalarmult(&hU, h, &U);
-
-  // Ru = sBu + h(-U)
-  ge_p1p1 Rp1p1;
-  ge_p3 Ru;
-  ge_cached hUcached;
-  ge_p3_to_cached(&hUcached, &hU);
-  ge_add(&Rp1p1, &sBu, &hUcached);
-  ge_p1p1_to_p3(&Ru, &Rp1p1);
-
-
-  // Check h == SHA512(label(4) || A || U || R || Ru || M)
-  m[0] = 0xFB;
-  for (count = 1; count < 32; count++)
-    m[count] = 0xFF;
-  memmove(m+32, pk, 32);
-  /* undo the negation for U */
-  fe_neg(U.X, U.X);
-  fe_neg(U.T, U.T);
-  ge_p3_tobytes(m+64, &U);
-  ge_tobytes(m+96, &R);
-  ge_p3_tobytes(m+128, &Ru);
-  memmove(m+160, sm+96, smlen - 96);
-
-  crypto_hash_sha512(hcheck, m, smlen + 64);
-  sc_reduce(hcheck);
-
-  if (crypto_verify_32(hcheck, h) == 0) {
-    memmove(m,m + 64,smlen - 64);
-    memset(m + smlen - 64,0,64);
-    *mlen = smlen - 64;
-    return 0;
-  }
-
-badsig:
-  *mlen = -1;
-  memset(m,0,smlen);
-  return -1;
-}
diff --git a/src/curve25519/ed25519/additions/usign_modified.c b/src/curve25519/ed25519/additions/usign_modified.c
deleted file mode 100644
index 3bbd871..0000000
--- a/src/curve25519/ed25519/additions/usign_modified.c
+++ /dev/null
@@ -1,62 +0,0 @@
-#include <string.h>
-#include "crypto_sign.h"
-#include "crypto_hash_sha512.h"
-#include "ge.h"
-#include "sc.h"
-#include "zeroize.h"
-#include "crypto_additions.h"
-
-/* NEW: Compare to pristine crypto_sign() 
-   Uses explicit private key for nonce derivation and as scalar,
-   instead of deriving both from a master key.
-*/
-int crypto_usign_modified(
-  unsigned char *sm,
-  const unsigned char *M,unsigned long Mlen,
-  const unsigned char *a, 
-  const unsigned char *A,
-  const unsigned char *random,
-  const ge_p3 *Bu,
-  const unsigned char *U
-)
-{
-  unsigned char r[64];
-  unsigned char h[64];
-  ge_p3 R, Ru;
-  int count=0;
-
-  /* r = SHA512(label(3) || a || U || random(64)) */
-  sm[0] = 0xFC;
-  for (count = 1; count < 32; count++)
-    sm[count] = 0xFF;
-
-  memmove(sm + 32, a, 32); /* Use privkey directly for nonce derivation */
-  memmove(sm + 64, U, 32);
-
-  memmove(sm + 96, random, 64); /* Add suffix of random data */
-  crypto_hash_sha512(r, sm, 160);
-
-  sc_reduce(r);
-  ge_scalarmult_base(&R, r);
-  ge_scalarmult(&Ru, r, Bu);
-
-  /* h = SHA512(label(4) || A || U || R || Ru || M) */
-  sm[0] = 0xFB;
-  memmove(sm + 32, A, 32);
-  memmove(sm + 64, U, 32);
-  ge_p3_tobytes(sm+96, &R);
-  ge_p3_tobytes(sm+128, &Ru);
-  memmove(sm + 160, M, Mlen);
-
-  crypto_hash_sha512(h, sm, Mlen + 160);
-  sc_reduce(h);
-
-  memmove(sm, h, 32);               /* Write h */
-  sc_muladd(sm + 32, h, a, r);      /* Write s */
-
-  /* Erase any traces of private scalar or
-     nonce left in the stack from sc_muladd. */
-  zeroize_stack();
-  zeroize(r, 64);
-  return 0;
-}
diff --git a/src/curve25519/ed25519/additions/vopen_modified.c b/src/curve25519/ed25519/additions/vopen_modified.c
deleted file mode 100644
index 20b85bb..0000000
--- a/src/curve25519/ed25519/additions/vopen_modified.c
+++ /dev/null
@@ -1,85 +0,0 @@
-#include <string.h>
-#include "sc.h"
-#include "ge.h"
-#include "crypto_hash_sha512.h"
-#include "crypto_verify_32.h"
-#include "crypto_additions.h"
-#include "crypto_sign.h"
-
-int crypto_vsign_open_modified(
-  unsigned char *m,
-  const unsigned char *sm,unsigned long long smlen,
-  const unsigned char *pk, const ge_p3* Bv
-)
-{
-  ge_p3 Vneg, V, Aneg, A, c_V, c_A, h_Vneg, s_Bv;
-  unsigned char h[32];
-  unsigned char s[32];
-  ge_p2 R;
-  unsigned char hcheck[64];
-  unsigned char vrf_output[64];
-  int count;
-  ge_p1p1 Rp1p1;
-  ge_p3 Rv;
-  ge_cached h_Vnegcached;
-
-  if (smlen < 96) goto badsig;
-  if (sm[63] & 224) goto badsig; /* strict parsing of h */
-  if (sm[95] & 224) goto badsig; /* strict parsing of s */
-
-  /* Load -A */
-  if (ge_frombytes_negate_vartime(&Aneg,pk) != 0) goto badsig;
-
-  /* Load -V, h, s */
-  if (ge_frombytes_negate_vartime(&Vneg, sm) != 0) goto badsig;
-  memmove(h, sm + 32, 32); 
-  memmove(s, sm + 64, 32); 
-  if (h[31] & 224) goto badsig; /* strict parsing of h */
-  if (s[31] & 224) goto badsig; /* strict parsing of s */
-
-  ge_neg(&A, &Aneg);
-  ge_neg(&V, &Vneg);
-  ge_scalarmult_cofactor(&c_A, &A);
-  ge_scalarmult_cofactor(&c_V, &V);
-  if (ge_isneutral(&c_A) || ge_isneutral(&c_V) || ge_isneutral(Bv))
-    goto badsig;
-
-  // R = (s*B) + (h * -A))
-  ge_double_scalarmult_vartime(&R, h, &Aneg, s);
-
-  // s * Bv
-  ge_scalarmult(&s_Bv, s, Bv);
-
-  // h * -V
-  ge_scalarmult(&h_Vneg, h, &Vneg);
-
-  // Rv = (sc * Bv) + (hc * (-V))
-  ge_p3_to_cached(&h_Vnegcached, &h_Vneg);
-  ge_add(&Rp1p1, &s_Bv, &h_Vnegcached);
-  ge_p1p1_to_p3(&Rv, &Rp1p1);
-
-  // Check h == SHA512(label(4) || A || V || R || Rv || M)
-  m[0] = 0xFB;  // label 4
-  for (count = 1; count < 32; count++)
-    m[count] = 0xFF;
-  memmove(m+32, pk, 32);
-  ge_p3_tobytes(m+64, &V);
-  ge_tobytes(m+96, &R);
-  ge_p3_tobytes(m+128, &Rv);
-  memmove(m+160, sm+96, smlen - 96);
-
-  crypto_hash_sha512(hcheck, m, smlen + 64);
-  sc_reduce(hcheck);
-
-  if (crypto_verify_32(hcheck, h) == 0) {
-    ge_p3_tobytes(m+32, &c_V);
-    m[0] = 0xFA; // label 5
-    crypto_hash_sha512(vrf_output, m, 64);
-    memmove(m, vrf_output, 32);
-    return 0;
-  }
-
-badsig:
-  memset(m, 0, 32);
-  return -1;
-}
diff --git a/src/curve25519/ed25519/additions/vsign_modified.c b/src/curve25519/ed25519/additions/vsign_modified.c
deleted file mode 100644
index 518b851..0000000
--- a/src/curve25519/ed25519/additions/vsign_modified.c
+++ /dev/null
@@ -1,62 +0,0 @@
-#include <string.h>
-#include "crypto_sign.h"
-#include "crypto_hash_sha512.h"
-#include "ge.h"
-#include "sc.h"
-#include "zeroize.h"
-#include "crypto_additions.h"
-
-/* NEW: Compare to pristine crypto_sign() 
-   Uses explicit private key for nonce derivation and as scalar,
-   instead of deriving both from a master key.
-*/
-int crypto_vsign_modified(
-  unsigned char *sm,
-  const unsigned char *M,unsigned long Mlen,
-  const unsigned char *a, 
-  const unsigned char *A,
-  const unsigned char *random,
-  const ge_p3 *Bv,
-  const unsigned char *V
-)
-{
-  unsigned char r[64];
-  unsigned char h[64];
-  ge_p3 R, Rv;
-  int count=0;
-
-  /* r = SHA512(label(3) || a || V || random(64)) */
-  sm[0] = 0xFC;
-  for (count = 1; count < 32; count++)
-    sm[count] = 0xFF;
-
-  memmove(sm + 32, a, 32); /* Use privkey directly for nonce derivation */
-  memmove(sm + 64, V, 32);
-
-  memmove(sm + 96, random, 64); /* Add suffix of random data */
-  crypto_hash_sha512(r, sm, 160);
-
-  sc_reduce(r);
-  ge_scalarmult_base(&R, r);
-  ge_scalarmult(&Rv, r, Bv);
-
-  /* h = SHA512(label(4) || A || V || R || Rv || M) */
-  sm[0] = 0xFB;
-  memmove(sm + 32, A, 32);
-  memmove(sm + 64, V, 32);
-  ge_p3_tobytes(sm+96, &R);
-  ge_p3_tobytes(sm+128, &Rv);
-  memmove(sm + 160, M, Mlen);
-
-  crypto_hash_sha512(h, sm, Mlen + 160);
-  sc_reduce(h);
-
-  memmove(sm, h, 32);               /* Write h */
-  sc_muladd(sm + 32, h, a, r);      /* Write s */
-
-  /* Erase any traces of private scalar or
-     nonce left in the stack from sc_muladd. */
-  zeroize_stack();
-  zeroize(r, 64);
-  return 0;
-}
diff --git a/src/curve25519/ed25519/additions/vxeddsa.c b/src/curve25519/ed25519/additions/vxeddsa.c
deleted file mode 100644
index 802a735..0000000
--- a/src/curve25519/ed25519/additions/vxeddsa.c
+++ /dev/null
@@ -1,91 +0,0 @@
-#include <string.h>
-#include "ge.h"
-#include "crypto_additions.h"
-#include "zeroize.h"
-#include "vxeddsa.h"
-#include "crypto_verify_32.h"
-
-int vxed25519_sign(unsigned char* signature_out,
-                   const unsigned char* curve25519_privkey,
-                   const unsigned char* msg, const unsigned long msg_len,
-                   const unsigned char* random)
-{
-  unsigned char a[32], aneg[32];
-  unsigned char A[32];
-  ge_p3 Bv, ed_pubkey_point;
-  unsigned char sigbuf[MAX_MSG_LEN + 160]; /* working buffer */
-  unsigned char sign_bit = 0;
-
-  if (msg_len > MAX_MSG_LEN) {
-    memset(signature_out, 0, 96);
-    return -1;
-  }
-  /* Convert the Curve25519 privkey to an Ed25519 public key */
-  ge_scalarmult_base(&ed_pubkey_point, curve25519_privkey);
-  ge_p3_tobytes(A, &ed_pubkey_point);
-
-  /* Force Edwards sign bit to zero */
-  sign_bit = (A[31] & 0x80) >> 7;
-  memcpy(a, curve25519_privkey, 32);
-  sc_neg(aneg, a);
-  sc_cmov(a, aneg, sign_bit); 
-  A[31] &= 0x7F;
-  
-  calculate_Bv_and_V(&Bv, signature_out, sigbuf, a, A, msg, msg_len);
-
-  /* Perform an Ed25519 signature with explicit private key */
-  crypto_vsign_modified(sigbuf, msg, msg_len, a, A, random, &Bv, signature_out /*V*/);
-  memmove(signature_out+32, sigbuf, 64);
-
-  zeroize(a, 32);
-  zeroize(aneg, 32);
-  return 0;
-}
-
-int vxed25519_verify(unsigned char* vrf_out,
-                     const unsigned char* signature,
-                     const unsigned char* curve25519_pubkey,
-                     const unsigned char* msg, const unsigned long msg_len)
-{
-  fe u; 
-  fe y;
-  unsigned char ed_pubkey[32];
-  unsigned char strict[32];
-  unsigned char verifybuf[MAX_MSG_LEN + 160]; /* working buffer */
-  unsigned char verifybuf2[MAX_MSG_LEN + 160]; /* working buffer #2 ?? !!! */
-  ge_p3 Bv;
-
-  if (msg_len > MAX_MSG_LEN) {
-    return -1;
-  }
-
-  /* Convert the Curve25519 public key (u) into an Ed25519 public key.  
-
-     y = (u - 1) / (u + 1)
-
-     NOTE: u=-1 is converted to y=0 since fe_invert is mod-exp
-  */
-  fe_frombytes(u, curve25519_pubkey);
-  fe_tobytes(strict, u);
-  if (crypto_verify_32(strict, curve25519_pubkey) != 0)
-    return 0;
-  fe_montx_to_edy(y, u);
-  fe_tobytes(ed_pubkey, y);
-
-  calculate_Bv(&Bv, verifybuf, ed_pubkey, msg, msg_len);
-
-  memmove(verifybuf, signature, 96);
-  memmove(verifybuf+96, msg, msg_len);
-
-  /* Then perform a signature verification, return 0 on success */
-  /* The below call has a strange API: */
-  /* verifybuf = V || h || s || message */
-  /* verifybuf2 = used as buffer, gets the VRF output if success */
-  if (crypto_vsign_open_modified(verifybuf2, verifybuf, 96 + msg_len, ed_pubkey, &Bv) == 0) {
-    memmove(vrf_out, verifybuf2, 32);
-    return 0;
-  } else {
-    memset(vrf_out, 0, 32);
-    return -1;
-  }
-}
diff --git a/src/curve25519/ed25519/additions/vxeddsa.h b/src/curve25519/ed25519/additions/vxeddsa.h
deleted file mode 100644
index 4e48844..0000000
--- a/src/curve25519/ed25519/additions/vxeddsa.h
+++ /dev/null
@@ -1,18 +0,0 @@
-
-#ifndef __VXEDDSA_H__
-#define __VXEDDSA_H__
-
-/* returns 0 on success */
-int vxed25519_sign(unsigned char* signature_out, /* 96 bytes */
-                   const unsigned char* curve25519_privkey, /* 32 bytes */
-                   const unsigned char* msg, const unsigned long msg_len, /* <= 256 bytes */
-                   const unsigned char* random); /* 64 bytes */
-
-/* returns 0 on success */
-int vxed25519_verify(unsigned char* vrf_out, /* 32 bytes */
-                     const unsigned char* signature, /* 96 bytes */
-                     const unsigned char* curve25519_pubkey, /* 32 bytes */
-                     const unsigned char* msg, const unsigned long msg_len); /* <= 256 bytes */
-
-
-#endif
diff --git a/src/curve25519/ed25519/additions/xeddsa.c b/src/curve25519/ed25519/additions/xeddsa.c
index ee2964a..63b73bf 100644
--- a/src/curve25519/ed25519/additions/xeddsa.c
+++ b/src/curve25519/ed25519/additions/xeddsa.c
@@ -49,7 +49,6 @@ int xed25519_verify(const unsigned char* signature,
   fe u;
   fe y;
   unsigned char ed_pubkey[32];
-  unsigned char strict[32];
   unsigned char verifybuf[MAX_MSG_LEN + 64]; /* working buffer */
   unsigned char verifybuf2[MAX_MSG_LEN + 64]; /* working buffer #2 */
 
@@ -63,10 +62,9 @@ int xed25519_verify(const unsigned char* signature,
 
      NOTE: u=-1 is converted to y=0 since fe_invert is mod-exp
   */
+  if (!fe_isreduced(curve25519_pubkey))
+      return -1;
   fe_frombytes(u, curve25519_pubkey);
-  fe_tobytes(strict, u);
-  if (crypto_verify_32(strict, curve25519_pubkey) != 0)
-    return 0;
   fe_montx_to_edy(y, u);
   fe_tobytes(ed_pubkey, y);
 
diff --git a/src/curve25519/ed25519/main/main.c b/src/curve25519/ed25519/main/main.c
deleted file mode 100644
index a6ff569..0000000
--- a/src/curve25519/ed25519/main/main.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include "tests.h"
-
-
-int main(int argc, char* argv[])
-{
-  all_fast_tests(0);
-  curvesigs_slow_test(0,           10000);
-  xeddsa_slow_test(0,              10000);
-  xeddsa_to_curvesigs_slow_test(0, 10000);
-  vxeddsa_slow_test(0,             10000000);
-
-  return 0;
-}
diff --git a/src/curve25519/ed25519/tests/internal_fast_tests.c b/src/curve25519/ed25519/tests/internal_fast_tests.c
new file mode 100644
index 0000000..6566e25
--- /dev/null
+++ b/src/curve25519/ed25519/tests/internal_fast_tests.c
@@ -0,0 +1,469 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "crypto_hash_sha512.h"
+#include "keygen.h"
+#include "curve_sigs.h"
+#include "xeddsa.h"
+#include "crypto_additions.h"
+#include "ge.h"
+#include "utility.h"
+#include "gen_crypto_additions.h"
+#include "gen_x.h"
+#include "internal_fast_tests.h"
+#include <assert.h>
+
+
+#define ERROR(...) do {if (!silent) { printf(__VA_ARGS__); abort(); } else return -1; } while (0)
+#define INFO(...) do {if (!silent) printf(__VA_ARGS__);} while (0)
+
+#define TEST(msg, cond) \
+  do {  \
+    if ((cond)) { \
+      INFO("%s good\n", msg); \
+    } \
+    else { \
+      ERROR("%s BAD!!!\n", msg); \
+    } \
+  } while (0)
+
+
+int sha512_fast_test(int silent)
+{
+  unsigned char sha512_input[112] =   
+    "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
+  unsigned char sha512_correct_output[64] =
+    {
+    0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA,
+    0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F,
+    0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1,
+    0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18,
+    0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4,
+    0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A,
+    0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54,
+    0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09
+    };
+  unsigned char sha512_actual_output[64];
+
+  crypto_hash_sha512(sha512_actual_output, sha512_input, sizeof(sha512_input));
+  TEST("SHA512 #1", memcmp(sha512_actual_output, sha512_correct_output, 64) == 0);
+
+  sha512_input[111] ^= 1;
+
+  crypto_hash_sha512(sha512_actual_output, sha512_input, sizeof(sha512_input));
+  TEST("SHA512 #2", memcmp(sha512_actual_output, sha512_correct_output, 64) != 0);
+
+  return 0;
+}
+
+int strict_fast_test(int silent)
+{
+  unsigned char unreduced1[32] = {
+  0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F,
+  };
+  unsigned char unreduced2[32] = {
+  0xED, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F,
+  };
+  unsigned char unreduced3[32] = {
+  0xEC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F,
+  };
+
+  unsigned char q[32] = {
+  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 
+  0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
+  };
+  unsigned char qminus1[32] = {
+  0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 
+  0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
+  };
+  unsigned char qplus1[32] = {
+  0xee, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 
+  0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
+  };
+
+  TEST("fe_isreduced", 
+      (fe_isreduced(unreduced1) == 0) && 
+      (fe_isreduced(unreduced2) == 0) &&
+      (fe_isreduced(unreduced3) == 1)
+      );
+
+  TEST("sc_isreduced", 
+      (sc_isreduced(q) == 0) && 
+      (sc_isreduced(qminus1) == 1) &&
+      (sc_isreduced(qplus1) == 0)
+      );
+  return 0;
+}
+
+int ge_fast_test(int silent)
+{
+
+  const unsigned char B_bytes[] = {
+    0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+  };
+
+  const unsigned char misc_bytes[] = {
+    0x57, 0x17, 0xfa, 0xce, 0xca, 0xb9, 0xdf, 0x0e, 
+    0x90, 0x67, 0xaa, 0x46, 0xba, 0x83, 0x2f, 0xeb, 
+    0x1c, 0x49, 0xd0, 0x21, 0xb1, 0x33, 0xff, 0x11, 
+    0xc9, 0x7a, 0xb8, 0xcf, 0xe3, 0x29, 0x46, 0x17,
+  };
+
+  unsigned char q_scalar[32] = {
+  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 
+  0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
+  };
+
+  unsigned char c_scalar[32] = {
+  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
+  };
+
+  unsigned char neutral_bytes[] = {
+  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
+  };
+
+/*  unsigned char one_scalar[32] = {
+  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  };
+
+  const unsigned char B_bytes[] = {
+    0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
+    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+  };
+  */
+
+  ge_p3 point1, point2, B_point, misc_point, miscneg_point;
+
+  unsigned char output1[32], output2[32];
+
+  if (ge_frombytes_negate_vartime(&B_point, B_bytes) != 0)
+    TEST("Failure to parse point #1", 0);
+  if (ge_frombytes_negate_vartime(&miscneg_point, misc_bytes) != 0)
+    TEST("Failure to parse point #2", 0);
+  ge_neg(&B_point, &B_point);
+  ge_neg(&misc_point, &miscneg_point);
+
+  /* q*B == neutral */
+  ge_scalarmult_base(&point1,  q_scalar);
+  ge_scalarmult(&point2, q_scalar, &B_point);
+  ge_p3_tobytes(output1, &point1);
+  ge_p3_tobytes(output2, &point2);
+
+  TEST("qB == qB", memcmp(output1, output2, 32) == 0 && memcmp(output1, neutral_bytes, 32) == 0);
+  TEST("qB isneutral", ge_isneutral(&point1 ) && ge_isneutral(&point2) && !ge_isneutral(&B_point));
+
+  /* cB == cB, cX == cX */
+  ge_scalarmult_cofactor(&point1, &B_point);
+  ge_scalarmult_base(&point2, c_scalar);
+  ge_p3_tobytes(output1, &point1);
+  ge_p3_tobytes(output2, &point2);
+  TEST("cB == cB", memcmp(output1, output2, 32) == 0);
+  ge_scalarmult_cofactor(&point1, &misc_point);
+  ge_scalarmult(&point2, c_scalar, &misc_point);
+  ge_p3_tobytes(output1, &point1);
+  ge_p3_tobytes(output2, &point2);
+  TEST("cX == cX", memcmp(output1, output2, 32) == 0);
+
+  /* */
+  ge_p3_add(&point1, &misc_point, &miscneg_point);
+  TEST("X + -X isneutral", ge_isneutral(&point1));
+
+  return 0;
+}
+
+int elligator_fast_test(int silent)
+{
+  unsigned char elligator_correct_output[32] = 
+  {
+  0x5f, 0x35, 0x20, 0x00, 0x1c, 0x6c, 0x99, 0x36, 
+  0xa3, 0x12, 0x06, 0xaf, 0xe7, 0xc7, 0xac, 0x22, 
+  0x4e, 0x88, 0x61, 0x61, 0x9b, 0xf9, 0x88, 0x72, 
+  0x44, 0x49, 0x15, 0x89, 0x9d, 0x95, 0xf4, 0x6e
+  };
+
+  unsigned char hashtopoint_correct_output1[32] = 
+  {
+  0xce, 0x89, 0x9f, 0xb2, 0x8f, 0xf7, 0x20, 0x91,
+  0x5e, 0x14, 0xf5, 0xb7, 0x99, 0x08, 0xab, 0x17,
+  0xaa, 0x2e, 0xe2, 0x45, 0xb4, 0xfc, 0x2b, 0xf6,
+  0x06, 0x36, 0x29, 0x40, 0xed, 0x7d, 0xe7, 0xed
+  };
+
+  unsigned char hashtopoint_correct_output2[32] = 
+  {
+  0xa0, 0x35, 0xbb, 0xa9, 0x4d, 0x30, 0x55, 0x33, 
+  0x0d, 0xce, 0xc2, 0x7f, 0x83, 0xde, 0x79, 0xd0, 
+  0x89, 0x67, 0x72, 0x4c, 0x07, 0x8d, 0x68, 0x9d, 
+  0x61, 0x52, 0x1d, 0xf9, 0x2c, 0x5c, 0xba, 0x77
+  };
+
+  int count;
+  fe in, out;
+  unsigned char bytes[32];
+  fe_0(in);
+  fe_0(out);
+  for (count = 0; count < 32; count++) {
+    bytes[count] = count;
+  }
+  fe_frombytes(in, bytes);
+  elligator(out, in);
+  fe_tobytes(bytes, out);
+  TEST("Elligator vector", memcmp(bytes, elligator_correct_output, 32) == 0);
+
+  /* Elligator(0) == 0 test */
+  fe_0(in);
+  elligator(out, in);
+  TEST("Elligator(0) == 0", memcmp(in, out, 32) == 0);
+
+  /* ge_montx_to_p3(0) -> order2 point test */
+  fe one, negone, zero;
+  fe_1(one);
+  fe_0(zero);
+  fe_sub(negone, zero, one);
+  ge_p3 p3;
+  ge_montx_to_p3(&p3, zero, 0);
+  TEST("ge_montx_to_p3(0) == order 2 point", 
+      fe_isequal(p3.X, zero) &&
+      fe_isequal(p3.Y, negone) &&
+      fe_isequal(p3.Z, one) && 
+      fe_isequal(p3.T, zero));
+
+  /* Hash to point vector test */
+  unsigned char htp[32];
+  
+  for (count=0; count < 32; count++) {
+    htp[count] = count;
+  }
+
+  hash_to_point(&p3, htp, 32);
+  ge_p3_tobytes(htp, &p3);
+  TEST("hash_to_point #1", memcmp(htp, hashtopoint_correct_output1, 32) == 0);
+
+  for (count=0; count < 32; count++) {
+    htp[count] = count+1;
+  }
+
+  hash_to_point(&p3, htp, 32);
+  ge_p3_tobytes(htp, &p3);
+  TEST("hash_to_point #2", memcmp(htp, hashtopoint_correct_output2, 32) == 0);
+
+  return 0;
+}
+
+int curvesigs_fast_test(int silent)
+{
+  unsigned char signature_correct[64] = {
+    0xcf, 0x87, 0x3d, 0x03, 0x79, 0xac, 0x20, 0xe8, 
+    0x89, 0x3e, 0x55, 0x67, 0xee, 0x0f, 0x89, 0x51, 
+    0xf8, 0xdb, 0x84, 0x0d, 0x26, 0xb2, 0x43, 0xb4, 
+    0x63, 0x52, 0x66, 0x89, 0xd0, 0x1c, 0xa7, 0x18, 
+    0xac, 0x18, 0x9f, 0xb1, 0x67, 0x85, 0x74, 0xeb, 
+    0xdd, 0xe5, 0x69, 0x33, 0x06, 0x59, 0x44, 0x8b, 
+    0x0b, 0xd6, 0xc1, 0x97, 0x3f, 0x7d, 0x78, 0x0a, 
+    0xb3, 0x95, 0x18, 0x62, 0x68, 0x03, 0xd7, 0x82,
+  };
+  const int MSG_LEN  = 200;
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char signature[64];
+  unsigned char msg[MSG_LEN];
+  unsigned char random[64];
+
+  memset(privkey, 0, 32);
+  memset(pubkey, 0, 32);
+  memset(signature, 0, 64);
+  memset(msg, 0, MSG_LEN);
+  memset(random, 0, 64);
+
+  privkey[8] = 189; /* just so there's some bits set */
+  sc_clamp(privkey);
+  
+  /* Signature vector test */
+  curve25519_keygen(pubkey, privkey);
+
+  curve25519_sign(signature, privkey, msg, MSG_LEN, random);
+
+  TEST("Curvesig sign", memcmp(signature, signature_correct, 64) == 0);
+  TEST("Curvesig verify #1", curve25519_verify(signature, pubkey, msg, MSG_LEN) == 0);
+  signature[0] ^= 1;
+  TEST("Curvesig verify #2", curve25519_verify(signature, pubkey, msg, MSG_LEN) != 0);
+  return 0;
+}
+
+int xeddsa_fast_test(int silent)
+{
+  unsigned char signature_correct[64] = {
+  0x11, 0xc7, 0xf3, 0xe6, 0xc4, 0xdf, 0x9e, 0x8a, 
+  0x51, 0x50, 0xe1, 0xdb, 0x3b, 0x30, 0xf9, 0x2d, 
+  0xe3, 0xa3, 0xb3, 0xaa, 0x43, 0x86, 0x56, 0x54, 
+  0x5f, 0xa7, 0x39, 0x0f, 0x4b, 0xcc, 0x7b, 0xb2, 
+  0x6c, 0x43, 0x1d, 0x9e, 0x90, 0x64, 0x3e, 0x4f, 
+  0x0e, 0xaa, 0x0e, 0x9c, 0x55, 0x77, 0x66, 0xfa, 
+  0x69, 0xad, 0xa5, 0x76, 0xd6, 0x3d, 0xca, 0xf2, 
+  0xac, 0x32, 0x6c, 0x11, 0xd0, 0xb9, 0x77, 0x02,
+  };
+  const int MSG_LEN  = 200;
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char signature[64];
+  unsigned char msg[MSG_LEN];
+  unsigned char random[64];
+
+  memset(privkey, 0, 32);
+  memset(pubkey, 0, 32);
+  memset(signature, 0, 64);
+  memset(msg, 0, MSG_LEN);
+  memset(random, 0, 64);
+
+  privkey[8] = 189; /* just so there's some bits set */
+  sc_clamp(privkey);
+  
+  /* Signature vector test */
+  curve25519_keygen(pubkey, privkey);
+
+  xed25519_sign(signature, privkey, msg, MSG_LEN, random);
+  TEST("XEdDSA sign", memcmp(signature, signature_correct, 64) == 0);
+  TEST("XEdDSA verify #1", xed25519_verify(signature, pubkey, msg, MSG_LEN) == 0);
+  signature[0] ^= 1;
+  TEST("XEdDSA verify #2", xed25519_verify(signature, pubkey, msg, MSG_LEN) != 0);
+  memset(pubkey, 0xFF, 32);
+  TEST("XEdDSA verify #3", xed25519_verify(signature, pubkey, msg, MSG_LEN) != 0);
+  return 0;
+}
+
+int generalized_xeddsa_fast_test(int silent)
+{
+  unsigned char signature1[64];
+  unsigned char signature2[64];
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char msg1[1000];
+  unsigned char msg2[1000];
+  unsigned char random[64];
+
+  memset(signature1, 0, 64);
+  memset(signature2, 0, 64);
+  memset(privkey, 0xF0, 32);
+  memset(pubkey, 2, 32);
+  memset(msg1, 0x10, 1000);
+  memset(msg2, 0x20, 1000);
+  memset(random, 0xBC, 64);
+
+  sc_clamp(privkey);
+  curve25519_keygen(pubkey, privkey);
+
+  msg2[0] = 1;
+  TEST("generalized xeddsa sign #1", generalized_xeddsa_25519_sign(signature1, privkey, msg1, 100, random, NULL, 0) == 0);
+  TEST("generalized xeddsa sign #2", generalized_xeddsa_25519_sign(signature2, privkey, msg2, 100, random, NULL, 0) == 0);
+
+  TEST("generalized (old) xeddsa verify #1", xed25519_verify(signature1, pubkey, msg1, 100) == 0);
+  TEST("generalized (old) xeddsa verify #2", xed25519_verify(signature2, pubkey, msg2, 100) == 0);
+  TEST("generalized (old) xeddsa verify #3", xed25519_verify(signature1, pubkey, msg2, 100) != 0);
+  TEST("generalized (old) xeddsa verify #4", xed25519_verify(signature2, pubkey, msg1, 100) != 0);
+
+  TEST("generalized xeddsa verify #1", generalized_xeddsa_25519_verify(signature1, pubkey, msg1, 100, NULL, 0) == 0);
+  TEST("generalized xeddsa verify #2", generalized_xeddsa_25519_verify(signature2, pubkey, msg2, 100, NULL, 0) == 0);
+  TEST("generalized xeddsa verify #3", generalized_xeddsa_25519_verify(signature1, pubkey, msg2, 100, NULL, 0) != 0);
+  TEST("generalized xeddsa verify #4", generalized_xeddsa_25519_verify(signature2, pubkey, msg1, 100, NULL, 0) != 0);
+  return 0;
+}
+
+int generalized_xveddsa_fast_test(int silent)
+{
+  unsigned char signature1[96];
+  unsigned char signature2[96];
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char msg1[1000];
+  unsigned char msg2[1000];
+  unsigned char random[64];
+  unsigned char vrf[32];
+
+  memset(signature1, 0, 64);
+  memset(signature2, 0, 64);
+  memset(privkey, 1, 32);
+  memset(pubkey, 2, 32);
+  memset(msg1, 0x11, 1000);
+  memset(msg2, 0x22, 1000);
+  memset(random, 0xAB, 64);
+
+  sc_clamp(privkey);
+  curve25519_keygen(pubkey, privkey);
+
+  msg2[0] ^= 1;
+  TEST("generalized xveddsa sign #1", generalized_xveddsa_25519_sign(signature1, privkey, msg1, 100, random, NULL, 0) == 0);
+  TEST("generalized xveddsa sign #2", generalized_xveddsa_25519_sign(signature2, privkey, msg2, 100, random, (unsigned char*)"abc", 3) == 0);
+
+  TEST("generalized xveddsa verify #1", generalized_xveddsa_25519_verify(vrf, signature1, pubkey, msg1, 100, NULL, 0) == 0);
+  TEST("generalized xveddsa verify #2", generalized_xveddsa_25519_verify(vrf, signature2, pubkey, msg2, 100, (unsigned char*)"abc", 3) == 0);
+  TEST("generalized xveddsa verify #3", generalized_xveddsa_25519_verify(vrf, signature1, pubkey, msg2, 100, NULL, 0) != 0);
+  TEST("generalized xveddsa verify #4", generalized_xveddsa_25519_verify(vrf, signature2, pubkey, msg1, 100, (unsigned char*)"abc", 3) != 0);
+
+
+  unsigned char signature3[96];
+  unsigned char vrf3[96];
+  random[0] ^= 1;
+  TEST("generalized xveddsa sign #3", generalized_xveddsa_25519_sign(signature3, privkey, msg1, 100, random, NULL, 0) == 0);
+  TEST("generalized xveddsa verify #5", generalized_xveddsa_25519_verify(vrf, signature1, pubkey, msg1, 100, NULL, 0) == 0);
+  TEST("generalized xveddsa verify #6", generalized_xveddsa_25519_verify(vrf3, signature3, pubkey, msg1, 100, NULL, 0) == 0);
+  TEST("generalized xveddsa VRFs equal", memcmp(vrf, vrf3, 32) == 0);
+  TEST("generalized xveddsa Kv equal", memcmp(signature1+0, signature3+0, 32) == 0);
+  TEST("generalized xveddsa h not equal", memcmp(signature1+32, signature3+32, 32) != 0);
+  TEST("generalized xveddsa s not equal", memcmp(signature1+64, signature3+64, 32) != 0);
+  return 0;
+}
+
+int all_fast_tests(int silent)
+{
+  int result;
+  if ((result = sha512_fast_test(silent)) != 0)
+    return -1;
+  if ((result = strict_fast_test(silent)) != 0)
+    return -2;
+  if ((result = ge_fast_test(silent)) != 0)
+    return -3;
+  if ((result = elligator_fast_test(silent)) != 0)
+    return -3;
+  if ((result = curvesigs_fast_test(silent)) != 0)
+    return -4;
+  if ((result = xeddsa_fast_test(silent)) != 0)
+    return -5;
+  if ((result = generalized_xeddsa_fast_test(silent)) != 0)
+    return -6;
+  if ((result = generalized_xveddsa_fast_test(silent)) != 0)
+    return -7;
+
+  return 0;
+}
+
diff --git a/src/curve25519/ed25519/tests/internal_fast_tests.h b/src/curve25519/ed25519/tests/internal_fast_tests.h
new file mode 100644
index 0000000..47f1175
--- /dev/null
+++ b/src/curve25519/ed25519/tests/internal_fast_tests.h
@@ -0,0 +1,19 @@
+#ifndef __INTERNAL_FAST_TESTS_H__
+#define __INTERNAL_FAST_TESTS_H__
+
+/* silent = 0 : prints info+error messages to stdout, abort() on test failure
+ * silent = 1 : returns 0 for success, anything else for failure 
+ */
+
+int sha512_fast_test(int silent);
+int strict_fast_test(int silent);
+int elligator_fast_test(int silent);
+int curvesigs_fast_test(int silent);
+int xeddsa_fast_test(int silent);
+int vxeddsa_fast_test(int silent);
+int generalized_xeddsa_fast_test(int silent);
+int generalized_xveddsa_fast_test(int silent);
+
+int all_fast_tests(int silent);
+
+#endif
diff --git a/src/curve25519/ed25519/tests/internal_slow_tests.c b/src/curve25519/ed25519/tests/internal_slow_tests.c
new file mode 100644
index 0000000..740ddbe
--- /dev/null
+++ b/src/curve25519/ed25519/tests/internal_slow_tests.c
@@ -0,0 +1,371 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "crypto_hash_sha512.h"
+#include "keygen.h"
+#include "curve_sigs.h"
+#include "xeddsa.h"
+#include "crypto_additions.h"
+#include "ge.h"
+#include "utility.h"
+#include "gen_x.h"
+#include "internal_slow_tests.h"
+#include <assert.h>
+
+
+#define ERROR(...) do {if (!silent) { printf(__VA_ARGS__); abort(); } else return -1; } while (0)
+#define INFO(...) do {if (!silent) printf(__VA_ARGS__);} while (0)
+
+#define TEST(msg, cond) \
+  do {  \
+    if ((cond)) { \
+      INFO("%s good\n", msg); \
+    } \
+    else { \
+      ERROR("%s BAD!!!\n", msg); \
+    } \
+  } while (0)
+
+
+
+int curvesigs_slow_test(int silent, int iterations)
+{
+
+  unsigned char signature_10k_correct[64] = {
+  0xfc, 0xba, 0x55, 0xc4, 0x85, 0x4a, 0x42, 0x25, 
+  0x19, 0xab, 0x08, 0x8d, 0xfe, 0xb5, 0x13, 0xb6, 
+  0x0d, 0x24, 0xbb, 0x16, 0x27, 0x55, 0x71, 0x48, 
+  0xdd, 0x20, 0xb1, 0xcd, 0x2a, 0xd6, 0x7e, 0x35, 
+  0xef, 0x33, 0x4c, 0x7b, 0x6d, 0x94, 0x6f, 0x52, 
+  0xec, 0x43, 0xd7, 0xe6, 0x35, 0x24, 0xcd, 0x5b, 
+  0x5d, 0xdc, 0xb2, 0x32, 0xc6, 0x22, 0x53, 0xf3, 
+  0x38, 0x02, 0xf8, 0x28, 0x28, 0xc5, 0x65, 0x05,
+  };
+
+  int count;  
+  const int MSG_LEN  = 200;
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char signature[64];
+  unsigned char msg[MSG_LEN];
+  unsigned char random[64];
+
+  memset(privkey, 0, 32);
+  memset(pubkey, 0, 32);
+  memset(signature, 0, 64);
+  memset(msg, 0, MSG_LEN);
+  memset(random, 0, 64);
+
+  /* Signature random test */
+  INFO("Pseudorandom curvesigs...\n");
+  for (count = 1; count <= iterations; count++) {
+    unsigned char b[64];
+    crypto_hash_sha512(b, signature, 64);
+    memmove(privkey, b, 32);
+    crypto_hash_sha512(b, privkey, 32);
+    memmove(random, b, 64);
+
+    sc_clamp(privkey);
+    curve25519_keygen(pubkey, privkey);
+
+    curve25519_sign(signature, privkey, msg, MSG_LEN, random);
+
+    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) != 0)
+      ERROR("Curvesig verify failure #1 %d\n", count);
+
+    if (b[63] & 1)
+      signature[count % 64] ^= 1;
+    else
+      msg[count % MSG_LEN] ^= 1;
+    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) == 0)
+      ERROR("Curvesig verify failure #2 %d\n", count);
+      
+    if (count == 10000) {
+      if (memcmp(signature, signature_10k_correct, 64) != 0)
+        ERROR("Curvesig signature 10K doesn't match %d\n", count);
+    }
+    if (count == 100000)
+      print_bytes("100K curvesigs", signature, 64);
+    if (count == 1000000)
+      print_bytes("1M curvesigs", signature, 64);
+    if (count == 10000000)
+      print_bytes("10M curvesigs", signature, 64);
+  }
+  INFO("good\n");
+  return 0;
+}
+
+int xeddsa_slow_test(int silent, int iterations)
+{
+
+  unsigned char signature_10k_correct[64] = {
+  0x15, 0x29, 0x03, 0x38, 0x66, 0x16, 0xcd, 0x26, 
+  0xbb, 0x3e, 0xec, 0xe2, 0x9f, 0x72, 0xa2, 0x5c, 
+  0x7d, 0x05, 0xc9, 0xcb, 0x84, 0x3f, 0x92, 0x96, 
+  0xb3, 0xfb, 0xb9, 0xdd, 0xd6, 0xed, 0x99, 0x04, 
+  0xc1, 0xa8, 0x02, 0x16, 0xcf, 0x49, 0x3f, 0xf1, 
+  0xbe, 0x69, 0xf9, 0xf1, 0xcc, 0x16, 0xd7, 0xdc, 
+  0x6e, 0xd3, 0x78, 0xaa, 0x04, 0xeb, 0x71, 0x51, 
+  0x9d, 0xe8, 0x7a, 0x5b, 0xd8, 0x49, 0x7b, 0x05, 
+  };
+
+  int count;  
+  const int MSG_LEN  = 200;
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char signature[96];
+  unsigned char msg[MSG_LEN];
+  unsigned char random[64];
+
+  memset(privkey, 0, 32);
+  memset(pubkey, 0, 32);
+  memset(signature, 1, 64);
+  memset(msg, 0, MSG_LEN);
+  memset(random, 0, 64);
+
+  /* Signature random test */
+  INFO("Pseudorandom XEdDSA...\n");
+  for (count = 1; count <= iterations; count++) {
+    unsigned char b[64];
+    crypto_hash_sha512(b, signature, 64);
+    memmove(privkey, b, 32);
+    crypto_hash_sha512(b, privkey, 32);
+    memmove(random, b, 64);
+
+    sc_clamp(privkey);
+    curve25519_keygen(pubkey, privkey);
+
+    xed25519_sign(signature, privkey, msg, MSG_LEN, random);
+
+    if (xed25519_verify(signature, pubkey, msg, MSG_LEN) != 0)
+      ERROR("XEdDSA verify failure #1 %d\n", count);
+
+    if (b[63] & 1)
+      signature[count % 64] ^= 1;
+    else
+      msg[count % MSG_LEN] ^= 1;
+    if (xed25519_verify(signature, pubkey, msg, MSG_LEN) == 0)
+      ERROR("XEdDSA verify failure #2 %d\n", count);
+
+    if (count == 10000) {
+      if (memcmp(signature, signature_10k_correct, 64) != 0)
+        ERROR("XEDSA signature 10K doesn't match %d\n", count);
+    }
+    if (count == 100000)
+      print_bytes("100K XEdDSA", signature, 64);
+    if (count == 1000000)
+      print_bytes("1M XEdDSA", signature, 64);
+    if (count == 10000000)
+      print_bytes("10M XEdDSA", signature, 64);
+  }
+  INFO("good\n");
+  return 0;
+}
+
+int xeddsa_to_curvesigs_slow_test(int silent, int iterations)
+{
+  unsigned char signature_10k_correct[64] = {
+  0x33, 0x50, 0xa8, 0x68, 0xcd, 0x9e, 0x74, 0x99, 
+  0xa3, 0x5c, 0x33, 0x75, 0x2b, 0x22, 0x03, 0xf8, 
+  0xb5, 0x0f, 0xea, 0x8c, 0x33, 0x1c, 0x68, 0x8b, 
+  0xbb, 0xf3, 0x31, 0xcf, 0x7c, 0x42, 0x37, 0x35,  
+  0xa0, 0x0e, 0x15, 0xb8, 0x5d, 0x2b, 0xe1, 0xa2, 
+  0x03, 0x77, 0x94, 0x3d, 0x13, 0x5c, 0xd4, 0x9b, 
+  0x6a, 0x31, 0xf4, 0xdc, 0xfe, 0x24, 0xad, 0x54, 
+  0xeb, 0xd2, 0x98, 0x47, 0xf1, 0xcc, 0xbf, 0x0d
+  
+  };
+
+  int count;  
+  const int MSG_LEN  = 200;
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char signature[96];
+  unsigned char msg[MSG_LEN];
+  unsigned char random[64];
+
+  memset(privkey, 0, 32);
+  memset(pubkey, 0, 32);
+  memset(signature, 2, 64);
+  memset(msg, 0, MSG_LEN);
+  memset(random, 0, 64);
+
+  /* Signature random test */
+  INFO("Pseudorandom XEdDSA/Curvesigs...\n");
+  for (count = 1; count <= iterations; count++) {
+    unsigned char b[64];
+    crypto_hash_sha512(b, signature, 64);
+    memmove(privkey, b, 32);
+    crypto_hash_sha512(b, privkey, 32);
+    memmove(random, b, 64);
+
+    sc_clamp(privkey);
+    curve25519_keygen(pubkey, privkey);
+
+    xed25519_sign(signature, privkey, msg, MSG_LEN, random);
+
+    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) != 0)
+      ERROR("XEdDSA/Curvesigs verify failure #1 %d\n", count);
+
+    if (b[63] & 1)
+      signature[count % 64] ^= 1;
+    else
+      msg[count % MSG_LEN] ^= 1;
+    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) == 0)
+      ERROR("XEdDSA/Curvesigs verify failure #2 %d\n", count);
+
+    if (count == 10000) {
+      if (memcmp(signature, signature_10k_correct, 64) != 0)
+        ERROR("XEdDSA/Curvesigs signature 10K doesn't match %d\n", count);
+    }
+    if (count == 100000)
+      print_bytes("100K XEdDSA/C", signature, 64);
+    if (count == 1000000)
+      print_bytes("1M XEdDSA/C", signature, 64);
+    if (count == 10000000)
+      print_bytes("10M XEdDSA/C", signature, 64);
+  }
+  INFO("good\n");
+  return 0;
+}
+
+int generalized_xveddsa_slow_test(int silent, int iterations)
+{
+  unsigned char signature_10k_correct[96] = {
+    0x89, 0x21, 0xf5, 0x2f, 0x37, 0x72, 0x08, 0x55, 
+    0x18, 0x9d, 0x24, 0xed, 0x86, 0xb1, 0x7a, 0x02, 
+    0xbf, 0x29, 0x5e, 0xa7, 0x45, 0xdc, 0x80, 0x03, 
+    0x7f, 0x4f, 0xca, 0x79, 0xe0, 0x95, 0xd0, 0xa1, 
+    0xb5, 0x99, 0xbe, 0xbd, 0xef, 0xbe, 0xa4, 0xdc, 
+    0x0c, 0x07, 0x6a, 0xf7, 0x7f, 0xe1, 0x1c, 0xb8, 
+    0x18, 0x84, 0xb8, 0xb4, 0xcf, 0x38, 0x7d, 0x98, 
+    0x37, 0xd8, 0x40, 0x23, 0x42, 0x12, 0x70, 0x06, 
+    0xb0, 0xd1, 0x0c, 0xc0, 0x1c, 0xa6, 0x9a, 0x2f, 
+    0xb4, 0x02, 0xd6, 0x37, 0x22, 0xe9, 0xfb, 0x00, 
+    0x22, 0x02, 0x5a, 0xf4, 0x40, 0x43, 0xb8, 0xe9, 
+    0xf4, 0x13, 0x44, 0x16, 0x19, 0x8d, 0x7e, 0x02,
+  };
+  unsigned char signature_100k_correct[96] = {
+    0xc4, 0x99, 0x64, 0x1f, 0x94, 0x95, 0xf4, 0x57, 
+    0xa0, 0xb9, 0x3d, 0xc3, 0xb5, 0x2e, 0x1e, 0xdd, 
+    0x92, 0xf2, 0x4c, 0xb2, 0x01, 0x36, 0x3d, 0xf2, 
+    0xea, 0x2c, 0xdc, 0x32, 0x21, 0x5f, 0xc5, 0xd2, 
+    0xff, 0x16, 0x41, 0x71, 0x3a, 0x77, 0x79, 0xeb, 
+    0x67, 0x20, 0xc4, 0xec, 0x39, 0xe1, 0x54, 0x2d, 
+    0x40, 0x10, 0xf9, 0xca, 0xc5, 0x21, 0x0a, 0x47, 
+    0x63, 0x99, 0x23, 0x04, 0x9d, 0x03, 0x1a, 0x06, 
+    0x00, 0xb9, 0x56, 0x7e, 0xef, 0xee, 0x0b, 0x40, 
+    0x59, 0xc1, 0x86, 0xd9, 0xa7, 0x87, 0x70, 0xec, 
+    0x05, 0x89, 0xbe, 0x71, 0x43, 0xd1, 0xf5, 0x61, 
+    0x5e, 0x00, 0x41, 0xde, 0x1f, 0x41, 0x2d, 0x0e,
+  };
+
+
+/*
+  unsigned char signature_1m_correct[96] = {
+  0xf8, 0xb1, 0x20, 0xf2, 0x1e, 0x5c, 0xbf, 0x5f, 
+  0xea, 0x07, 0xcb, 0xb5, 0x77, 0xb8, 0x03, 0xbc, 
+  0xcb, 0x6d, 0xf1, 0xc1, 0xa5, 0x03, 0x05, 0x7b, 
+  0x01, 0x63, 0x9b, 0xf9, 0xed, 0x3e, 0x57, 0x47, 
+  0xd2, 0x5b, 0xf4, 0x7e, 0x7c, 0x45, 0xce, 0xfc, 
+  0x06, 0xb3, 0xf4, 0x05, 0x81, 0x9f, 0x53, 0xb0, 
+  0x18, 0xe3, 0xfa, 0xcb, 0xb2, 0x52, 0x3e, 0x57, 
+  0xcb, 0x34, 0xcc, 0x81, 0x60, 0xb9, 0x0b, 0x04, 
+  0x07, 0x79, 0xc0, 0x53, 0xad, 0xc4, 0x4b, 0xd0, 
+  0xb5, 0x7d, 0x95, 0x4e, 0xbe, 0xa5, 0x75, 0x0c, 
+  0xd4, 0xbf, 0xa7, 0xc0, 0xcf, 0xba, 0xe7, 0x7c, 
+  0xe2, 0x90, 0xef, 0x61, 0xa9, 0x29, 0x66, 0x0d,
+  };
+
+  unsigned char signature_10m_correct[96] = {
+  0xf5, 0xa4, 0xbc, 0xec, 0xc3, 0x3d, 0xd0, 0x43, 
+  0xd2, 0x81, 0x27, 0x9e, 0xf0, 0x4c, 0xbe, 0xf3, 
+  0x77, 0x01, 0x56, 0x41, 0x0e, 0xff, 0x0c, 0xb9, 
+  0x66, 0xec, 0x4d, 0xe0, 0xb7, 0x25, 0x63, 0x6b, 
+  0x5c, 0x08, 0x39, 0x80, 0x4e, 0x37, 0x1b, 0x2c, 
+  0x46, 0x6f, 0x86, 0x99, 0x1c, 0x4e, 0x31, 0x60, 
+  0xdb, 0x4c, 0xfe, 0xc5, 0xa2, 0x4d, 0x71, 0x2b, 
+  0xd6, 0xd0, 0xc3, 0x98, 0x88, 0xdb, 0x0e, 0x0c, 
+  0x68, 0x4a, 0xd3, 0xc7, 0x56, 0xac, 0x8d, 0x95, 
+  0x7b, 0xbd, 0x99, 0x50, 0xe8, 0xd3, 0xea, 0xf3, 
+  0x7b, 0x26, 0xf2, 0xa2, 0x2b, 0x02, 0x58, 0xca, 
+  0xbd, 0x2c, 0x2b, 0xf7, 0x77, 0x58, 0xfe, 0x09,
+  };
+  */
+
+  int count;  
+  const int MSG_LEN  = 200;
+  unsigned char privkey[32];
+  unsigned char pubkey[32];
+  unsigned char signature[96];
+  unsigned char msg[MSG_LEN];
+  unsigned char random[64];
+  unsigned char vrf_out[32];
+
+  memset(privkey, 0, 32);
+  memset(pubkey, 0, 32);
+  memset(signature, 3, 96);
+  memset(msg, 0, MSG_LEN);
+  memset(random, 0, 64);
+
+  INFO("Pseudorandom XVEdDSA...\n");
+  for (count = 1; count <= iterations; count++) {
+    unsigned char b[64];
+    crypto_hash_sha512(b, signature, 96);
+    memmove(privkey, b, 32);
+    crypto_hash_sha512(b, privkey, 32);
+    memmove(random, b, 64);
+
+    sc_clamp(privkey);
+    curve25519_keygen(pubkey, privkey);
+
+    generalized_xveddsa_25519_sign(signature, privkey, msg, MSG_LEN, random, NULL, 0);
+
+    if (generalized_xveddsa_25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN, NULL, 0) != 0)
+      ERROR("XVEdDSA verify failure #1 %d\n", count);
+
+    if (b[63] & 1)
+      signature[count % 96] ^= 1;
+    else
+      msg[count % MSG_LEN] ^= 1;
+
+    if (generalized_xveddsa_25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN, NULL, 0) == 0)
+      ERROR("XVEdDSA verify failure #2 %d\n", count);
+
+    if (count == 10000)
+      print_bytes("10K XVEdDSA", signature, 96);
+    if (count == 100000)
+      print_bytes("100K XVEdDSA", signature, 96);
+    if (count == 1000000)
+      print_bytes("1M XVEdDSA", signature, 96);
+    if (count == 10000000)
+      print_bytes("10M XVEdDSA", signature, 96);
+    if (count == 100000000)
+      print_bytes("100M XVEdDSA", signature, 96);
+
+    if (count == 10000) {
+      if (memcmp(signature, signature_10k_correct, 96) != 0)
+        ERROR("XVEDDSA 10K doesn't match %d\n", count);
+    }
+    if (count == 100000) {
+      if (memcmp(signature, signature_100k_correct, 96) != 0)
+        ERROR("XVEDDSA 100K doesn't match %d\n", count);
+    }
+    /*
+    if (count == 1000000) {
+      if (memcmp(signature, signature_1m_correct, 96) != 0)
+        ERROR("XVEDDSA 1m doesn't match %d\n", count);
+    }
+    if (count == 10000000) {
+      if (memcmp(signature, signature_10m_correct, 96) != 0)
+        ERROR("XVEDDSA 10m doesn't match %d\n", count);
+    }
+    if (count == 100000000) {
+      if (memcmp(signature, signature_100m_correct, 96) != 0)
+        ERROR("XVEDDSA 100m doesn't match %d\n", count);
+    }
+    */
+  }
+  INFO("good\n");
+  return 0;
+}
diff --git a/src/curve25519/ed25519/tests/tests.h b/src/curve25519/ed25519/tests/internal_slow_tests.h
similarity index 57%
rename from src/curve25519/ed25519/tests/tests.h
rename to src/curve25519/ed25519/tests/internal_slow_tests.h
index 1623268..5a680c6 100644
--- a/src/curve25519/ed25519/tests/tests.h
+++ b/src/curve25519/ed25519/tests/internal_slow_tests.h
@@ -1,22 +1,15 @@
-#ifndef __TESTS_H__
-#define __TESTS_H__
+#ifndef __INTERNAL_SLOW_TESTS_H__
+#define __INTERNAL_SLOW_TESTS_H__
 
 /* silent = 0 : prints info+error messages to stdout, abort() on test failure
  * silent = 1 : returns 0 for success, anything else for failure 
  * iterations : hardcoded known-good values are at 10000, so run at least this many
  */
 
-int sha512_fast_test(int silent);
-int elligator_fast_test(int silent);
-int curvesigs_fast_test(int silent);
-int xeddsa_fast_test(int silent);
-int vxeddsa_fast_test(int silent);
-
 int curvesigs_slow_test(int silent, int iterations);
 int xeddsa_slow_test(int silent, int iterations);
 int xeddsa_to_curvesigs_slow_test(int silent, int iterations);
-int vxeddsa_slow_test(int silent, int iterations);
+int generalized_xveddsa_slow_test(int silent, int iterations);
 
-int all_fast_tests(int silent);
 
 #endif
diff --git a/src/curve25519/ed25519/tests/tests.c b/src/curve25519/ed25519/tests/tests.c
deleted file mode 100644
index 79adae5..0000000
--- a/src/curve25519/ed25519/tests/tests.c
+++ /dev/null
@@ -1,658 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include "crypto_hash_sha512.h"
-#include "keygen.h"
-#include "curve_sigs.h"
-#include "xeddsa.h"
-#include "vxeddsa.h"
-#include "crypto_additions.h"
-#include "ge.h"
-#include "utility.h"
-#include "tests.h"
-#include <assert.h>
-
-
-#define ERROR(...) do {if (!silent) { printf(__VA_ARGS__); abort(); } else return -1; } while (0)
-#define INFO(...) do {if (!silent) printf(__VA_ARGS__);} while (0)
-
-#define TEST(msg, cond) \
-  do {  \
-    if ((cond)) { \
-      INFO("%s good\n", msg); \
-    } \
-    else { \
-      ERROR("%s BAD!!!\n", msg); \
-    } \
-  } while (0)
-
-
-int sha512_fast_test(int silent)
-{
-  unsigned char sha512_input[112] =   
-    "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
-  unsigned char sha512_correct_output[64] =
-    {
-    0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA,
-    0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F,
-    0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1,
-    0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18,
-    0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4,
-    0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A,
-    0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54,
-    0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09
-    };
-  unsigned char sha512_actual_output[64];
-
-  crypto_hash_sha512(sha512_actual_output, sha512_input, sizeof(sha512_input));
-  TEST("SHA512 #1", memcmp(sha512_actual_output, sha512_correct_output, 64) == 0);
-
-  sha512_input[111] ^= 1;
-
-  crypto_hash_sha512(sha512_actual_output, sha512_input, sizeof(sha512_input));
-  TEST("SHA512 #2", memcmp(sha512_actual_output, sha512_correct_output, 64) != 0);
-
-  return 0;
-}
-
-int elligator_fast_test(int silent)
-{
-  unsigned char elligator_correct_output[32] = 
-  {
-  0x5f, 0x35, 0x20, 0x00, 0x1c, 0x6c, 0x99, 0x36, 
-  0xa3, 0x12, 0x06, 0xaf, 0xe7, 0xc7, 0xac, 0x22, 
-  0x4e, 0x88, 0x61, 0x61, 0x9b, 0xf9, 0x88, 0x72, 
-  0x44, 0x49, 0x15, 0x89, 0x9d, 0x95, 0xf4, 0x6e
-  };
-
-  unsigned char hashtopoint_correct_output1[32] = 
-  {
-  0xce, 0x89, 0x9f, 0xb2, 0x8f, 0xf7, 0x20, 0x91,
-  0x5e, 0x14, 0xf5, 0xb7, 0x99, 0x08, 0xab, 0x17,
-  0xaa, 0x2e, 0xe2, 0x45, 0xb4, 0xfc, 0x2b, 0xf6,
-  0x06, 0x36, 0x29, 0x40, 0xed, 0x7d, 0xe7, 0xed
-  };
-
-  unsigned char hashtopoint_correct_output2[32] = 
-  {
-  0xa0, 0x35, 0xbb, 0xa9, 0x4d, 0x30, 0x55, 0x33, 
-  0x0d, 0xce, 0xc2, 0x7f, 0x83, 0xde, 0x79, 0xd0, 
-  0x89, 0x67, 0x72, 0x4c, 0x07, 0x8d, 0x68, 0x9d, 
-  0x61, 0x52, 0x1d, 0xf9, 0x2c, 0x5c, 0xba, 0x77
-  };
-
-  unsigned char calculatev_correct_output[32] = 
-  {
-  0x1b, 0x77, 0xb5, 0xa0, 0x44, 0x84, 0x7e, 0xb9, 
-  0x23, 0xd7, 0x93, 0x18, 0xce, 0xc2, 0xc5, 0xe2, 
-  0x84, 0xd5, 0x79, 0x6f, 0x65, 0x63, 0x1b, 0x60, 
-  0x9b, 0xf1, 0xf8, 0xce, 0x88, 0x0b, 0x50, 0x9c,
-  };
-
-  int count;
-  fe in, out;
-  unsigned char bytes[32];
-  fe_0(in);
-  fe_0(out);
-  for (count = 0; count < 32; count++) {
-    bytes[count] = count;
-  }
-  fe_frombytes(in, bytes);
-  elligator(out, in);
-  fe_tobytes(bytes, out);
-  TEST("Elligator vector", memcmp(bytes, elligator_correct_output, 32) == 0);
-
-  /* Elligator(0) == 0 test */
-  fe_0(in);
-  elligator(out, in);
-  TEST("Elligator(0) == 0", memcmp(in, out, 32) == 0);
-
-  /* ge_montx_to_p3(0) -> order2 point test */
-  fe one, negone, zero;
-  fe_1(one);
-  fe_0(zero);
-  fe_sub(negone, zero, one);
-  ge_p3 p3;
-  ge_montx_to_p3(&p3, zero, 0);
-  TEST("ge_montx_to_p3(0) == order 2 point", 
-      fe_isequal(p3.X, zero) &&
-      fe_isequal(p3.Y, negone) &&
-      fe_isequal(p3.Z, one) && 
-      fe_isequal(p3.T, zero));
-
-  /* Hash to point vector test */
-  unsigned char htp[32];
-  
-  for (count=0; count < 32; count++) {
-    htp[count] = count;
-  }
-
-  hash_to_point(&p3, htp, 32);
-  ge_p3_tobytes(htp, &p3);
-  TEST("hash_to_point #1", memcmp(htp, hashtopoint_correct_output1, 32) == 0);
-
-  for (count=0; count < 32; count++) {
-    htp[count] = count+1;
-  }
-
-  hash_to_point(&p3, htp, 32);
-  ge_p3_tobytes(htp, &p3);
-  TEST("hash_to_point #2", memcmp(htp, hashtopoint_correct_output2, 32) == 0);
-
-  /* calculate_U vector test */
-  ge_p3 Bv;
-  unsigned char V[32];
-  unsigned char Vbuf[200];
-  unsigned char a[32];
-  unsigned char A[32];
-  unsigned char Vmsg[3];
-  Vmsg[0] = 0;
-  Vmsg[1] = 1;
-  Vmsg[2] = 2;
-  for (count=0; count < 32; count++) {
-    a[count] = 8 + count;
-    A[count] = 9 + count;
-  }
-  sc_clamp(a);
-  calculate_Bv_and_V(&Bv, V, Vbuf, a, A, Vmsg, 3);
-  TEST("calculate_Bv_and_V vector", memcmp(V, calculatev_correct_output, 32) == 0);
-  return 0;
-}
-
-int curvesigs_fast_test(int silent)
-{
-  unsigned char signature_correct[64] = {
-    0xcf, 0x87, 0x3d, 0x03, 0x79, 0xac, 0x20, 0xe8, 
-    0x89, 0x3e, 0x55, 0x67, 0xee, 0x0f, 0x89, 0x51, 
-    0xf8, 0xdb, 0x84, 0x0d, 0x26, 0xb2, 0x43, 0xb4, 
-    0x63, 0x52, 0x66, 0x89, 0xd0, 0x1c, 0xa7, 0x18, 
-    0xac, 0x18, 0x9f, 0xb1, 0x67, 0x85, 0x74, 0xeb, 
-    0xdd, 0xe5, 0x69, 0x33, 0x06, 0x59, 0x44, 0x8b, 
-    0x0b, 0xd6, 0xc1, 0x97, 0x3f, 0x7d, 0x78, 0x0a, 
-    0xb3, 0x95, 0x18, 0x62, 0x68, 0x03, 0xd7, 0x82,
-  };
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[64];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 0, 64);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  privkey[8] = 189; /* just so there's some bits set */
-  sc_clamp(privkey);
-  
-  /* Signature vector test */
-  curve25519_keygen(pubkey, privkey);
-
-  curve25519_sign(signature, privkey, msg, MSG_LEN, random);
-
-  TEST("Curvesig sign", memcmp(signature, signature_correct, 64) == 0);
-  TEST("Curvesig verify #1", curve25519_verify(signature, pubkey, msg, MSG_LEN) == 0);
-  signature[0] ^= 1;
-  TEST("Curvesig verify #2", curve25519_verify(signature, pubkey, msg, MSG_LEN) != 0);
-  return 0;
-}
-
-int xeddsa_fast_test(int silent)
-{
-  unsigned char signature_correct[64] = {
-  0x11, 0xc7, 0xf3, 0xe6, 0xc4, 0xdf, 0x9e, 0x8a, 
-  0x51, 0x50, 0xe1, 0xdb, 0x3b, 0x30, 0xf9, 0x2d, 
-  0xe3, 0xa3, 0xb3, 0xaa, 0x43, 0x86, 0x56, 0x54, 
-  0x5f, 0xa7, 0x39, 0x0f, 0x4b, 0xcc, 0x7b, 0xb2, 
-  0x6c, 0x43, 0x1d, 0x9e, 0x90, 0x64, 0x3e, 0x4f, 
-  0x0e, 0xaa, 0x0e, 0x9c, 0x55, 0x77, 0x66, 0xfa, 
-  0x69, 0xad, 0xa5, 0x76, 0xd6, 0x3d, 0xca, 0xf2, 
-  0xac, 0x32, 0x6c, 0x11, 0xd0, 0xb9, 0x77, 0x02,
-  };
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[64];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 0, 64);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  privkey[8] = 189; /* just so there's some bits set */
-  sc_clamp(privkey);
-  
-  /* Signature vector test */
-  curve25519_keygen(pubkey, privkey);
-
-  xed25519_sign(signature, privkey, msg, MSG_LEN, random);
-  TEST("XEdDSA sign", memcmp(signature, signature_correct, 64) == 0);
-  TEST("XEdDSA verify #1", xed25519_verify(signature, pubkey, msg, MSG_LEN) == 0);
-  signature[0] ^= 1;
-  TEST("XEdDSA verify #2", xed25519_verify(signature, pubkey, msg, MSG_LEN) != 0);
-  return 0;
-}
-
-int vxeddsa_fast_test(int silent)
-{
-  unsigned char signature_correct[96] = {
-  0x23, 0xc6, 0xe5, 0x93, 0x3f, 0xcd, 0x56, 0x47, 
-  0x7a, 0x86, 0xc9, 0x9b, 0x76, 0x2c, 0xb5, 0x24, 
-  0xc3, 0xd6, 0x05, 0x55, 0x38, 0x83, 0x4d, 0x4f, 
-  0x8d, 0xb8, 0xf0, 0x31, 0x07, 0xec, 0xeb, 0xa0, 
-  0xa0, 0x01, 0x50, 0xb8, 0x4c, 0xbb, 0x8c, 0xcd, 
-  0x23, 0xdc, 0x65, 0xfd, 0x0e, 0x81, 0xb2, 0x86, 
-  0x06, 0xa5, 0x6b, 0x0c, 0x4f, 0x53, 0x6d, 0xc8, 
-  0x8b, 0x8d, 0xc9, 0x04, 0x6e, 0x4a, 0xeb, 0x08, 
-  0xce, 0x08, 0x71, 0xfc, 0xc7, 0x00, 0x09, 0xa4, 
-  0xd6, 0xc0, 0xfd, 0x2d, 0x1a, 0xe5, 0xb6, 0xc0, 
-  0x7c, 0xc7, 0x22, 0x3b, 0x69, 0x59, 0xa8, 0x26, 
-  0x2b, 0x57, 0x78, 0xd5, 0x46, 0x0e, 0x0f, 0x05, 
-  };
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[96];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-  unsigned char vrf_out[32];
-  unsigned char vrf_outprev[32];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 0, 96);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  privkey[8] = 189; /* just so there's some bits set */
-  sc_clamp(privkey);
-  
-  /* Signature vector test */
-  curve25519_keygen(pubkey, privkey);
-
-  vxed25519_sign(signature, privkey, msg, MSG_LEN, random);
-
-  TEST("VXEdDSA sign", memcmp(signature, signature_correct, 96) == 0);
-  TEST("VXEdDSA verify #1", vxed25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN) == 0);
-  memcpy(vrf_outprev, vrf_out, 32);
-  signature[0] ^= 1;
-  TEST("VXEdDSA verify #2", vxed25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN) != 0);
-
-  /* Test U */
-  unsigned char sigprev[96];
-  memcpy(sigprev, signature, 96);
-  sigprev[0] ^= 1; /* undo prev disturbance */
-
-  random[0] ^= 1; 
-  vxed25519_sign(signature, privkey, msg, MSG_LEN, random);
-  TEST("VXEdDSA verify #3", vxed25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN) == 0);
- 
-  TEST("VXEdDSA VRF value unchanged", memcmp(vrf_out, vrf_outprev, 32) == 0);
-  TEST("VXEdDSA (h, s) changed", memcmp(signature+32, sigprev+32, 64) != 0);
-  return 0;
-}
-
-int curvesigs_slow_test(int silent, int iterations)
-{
-
-  unsigned char signature_10k_correct[64] = {
-  0xfc, 0xba, 0x55, 0xc4, 0x85, 0x4a, 0x42, 0x25, 
-  0x19, 0xab, 0x08, 0x8d, 0xfe, 0xb5, 0x13, 0xb6, 
-  0x0d, 0x24, 0xbb, 0x16, 0x27, 0x55, 0x71, 0x48, 
-  0xdd, 0x20, 0xb1, 0xcd, 0x2a, 0xd6, 0x7e, 0x35, 
-  0xef, 0x33, 0x4c, 0x7b, 0x6d, 0x94, 0x6f, 0x52, 
-  0xec, 0x43, 0xd7, 0xe6, 0x35, 0x24, 0xcd, 0x5b, 
-  0x5d, 0xdc, 0xb2, 0x32, 0xc6, 0x22, 0x53, 0xf3, 
-  0x38, 0x02, 0xf8, 0x28, 0x28, 0xc5, 0x65, 0x05,
-  };
-
-  int count;  
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[64];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 0, 64);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  /* Signature random test */
-  INFO("Pseudorandom curvesigs...\n");
-  for (count = 1; count <= iterations; count++) {
-    unsigned char b[64];
-    crypto_hash_sha512(b, signature, 64);
-    memmove(privkey, b, 32);
-    crypto_hash_sha512(b, privkey, 32);
-    memmove(random, b, 64);
-
-    sc_clamp(privkey);
-    curve25519_keygen(pubkey, privkey);
-
-    curve25519_sign(signature, privkey, msg, MSG_LEN, random);
-
-    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) != 0)
-      ERROR("Curvesig verify failure #1 %d\n", count);
-
-    if (b[63] & 1)
-      signature[count % 64] ^= 1;
-    else
-      msg[count % MSG_LEN] ^= 1;
-    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) == 0)
-      ERROR("Curvesig verify failure #2 %d\n", count);
-      
-    if (count == 10000) {
-      if (memcmp(signature, signature_10k_correct, 64) != 0)
-        ERROR("Curvesig signature 10K doesn't match %d\n", count);
-    }
-    if (count == 100000)
-      print_bytes("100K curvesigs", signature, 64);
-    if (count == 1000000)
-      print_bytes("1M curvesigs", signature, 64);
-    if (count == 10000000)
-      print_bytes("10M curvesigs", signature, 64);
-  }
-  INFO("good\n");
-  return 0;
-}
-
-int xeddsa_slow_test(int silent, int iterations)
-{
-
-  unsigned char signature_10k_correct[64] = {
-  0x15, 0x29, 0x03, 0x38, 0x66, 0x16, 0xcd, 0x26, 
-  0xbb, 0x3e, 0xec, 0xe2, 0x9f, 0x72, 0xa2, 0x5c, 
-  0x7d, 0x05, 0xc9, 0xcb, 0x84, 0x3f, 0x92, 0x96, 
-  0xb3, 0xfb, 0xb9, 0xdd, 0xd6, 0xed, 0x99, 0x04, 
-  0xc1, 0xa8, 0x02, 0x16, 0xcf, 0x49, 0x3f, 0xf1, 
-  0xbe, 0x69, 0xf9, 0xf1, 0xcc, 0x16, 0xd7, 0xdc, 
-  0x6e, 0xd3, 0x78, 0xaa, 0x04, 0xeb, 0x71, 0x51, 
-  0x9d, 0xe8, 0x7a, 0x5b, 0xd8, 0x49, 0x7b, 0x05, 
-  };
-
-  int count;  
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[96];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 1, 64);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  /* Signature random test */
-  INFO("Pseudorandom XEdDSA...\n");
-  for (count = 1; count <= iterations; count++) {
-    unsigned char b[64];
-    crypto_hash_sha512(b, signature, 64);
-    memmove(privkey, b, 32);
-    crypto_hash_sha512(b, privkey, 32);
-    memmove(random, b, 64);
-
-    sc_clamp(privkey);
-    curve25519_keygen(pubkey, privkey);
-
-    xed25519_sign(signature, privkey, msg, MSG_LEN, random);
-
-    if (xed25519_verify(signature, pubkey, msg, MSG_LEN) != 0)
-      ERROR("XEdDSA verify failure #1 %d\n", count);
-
-    if (b[63] & 1)
-      signature[count % 64] ^= 1;
-    else
-      msg[count % MSG_LEN] ^= 1;
-    if (xed25519_verify(signature, pubkey, msg, MSG_LEN) == 0)
-      ERROR("XEdDSA verify failure #2 %d\n", count);
-
-    if (count == 10000) {
-      if (memcmp(signature, signature_10k_correct, 64) != 0)
-        ERROR("XEDSA signature 10K doesn't match %d\n", count);
-    }
-    if (count == 100000)
-      print_bytes("100K XEdDSA", signature, 64);
-    if (count == 1000000)
-      print_bytes("1M XEdDSA", signature, 64);
-    if (count == 10000000)
-      print_bytes("10M XEdDSA", signature, 64);
-  }
-  INFO("good\n");
-  return 0;
-}
-
-int xeddsa_to_curvesigs_slow_test(int silent, int iterations)
-{
-
-  unsigned char signature_10k_correct[64] = {
-  0x33, 0x50, 0xa8, 0x68, 0xcd, 0x9e, 0x74, 0x99, 
-  0xa3, 0x5c, 0x33, 0x75, 0x2b, 0x22, 0x03, 0xf8, 
-  0xb5, 0x0f, 0xea, 0x8c, 0x33, 0x1c, 0x68, 0x8b, 
-  0xbb, 0xf3, 0x31, 0xcf, 0x7c, 0x42, 0x37, 0x35,  
-  0xa0, 0x0e, 0x15, 0xb8, 0x5d, 0x2b, 0xe1, 0xa2, 
-  0x03, 0x77, 0x94, 0x3d, 0x13, 0x5c, 0xd4, 0x9b, 
-  0x6a, 0x31, 0xf4, 0xdc, 0xfe, 0x24, 0xad, 0x54, 
-  0xeb, 0xd2, 0x98, 0x47, 0xf1, 0xcc, 0xbf, 0x0d
-  
-  };
-
-  int count;  
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[96];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 2, 64);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  /* Signature random test */
-  INFO("Pseudorandom XEdDSA/Curvesigs...\n");
-  for (count = 1; count <= iterations; count++) {
-    unsigned char b[64];
-    crypto_hash_sha512(b, signature, 64);
-    memmove(privkey, b, 32);
-    crypto_hash_sha512(b, privkey, 32);
-    memmove(random, b, 64);
-
-    sc_clamp(privkey);
-    curve25519_keygen(pubkey, privkey);
-
-    xed25519_sign(signature, privkey, msg, MSG_LEN, random);
-
-    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) != 0)
-      ERROR("XEdDSA/Curvesigs verify failure #1 %d\n", count);
-
-    if (b[63] & 1)
-      signature[count % 64] ^= 1;
-    else
-      msg[count % MSG_LEN] ^= 1;
-    if (curve25519_verify(signature, pubkey, msg, MSG_LEN) == 0)
-      ERROR("XEdDSA/Curvesigs verify failure #2 %d\n", count);
-
-    if (count == 10000) {
-      if (memcmp(signature, signature_10k_correct, 64) != 0)
-        ERROR("XEdDSA/Curvesigs signature 10K doesn't match %d\n", count);
-    }
-    if (count == 100000)
-      print_bytes("100K XEdDSA/C", signature, 64);
-    if (count == 1000000)
-      print_bytes("1M XEdDSA/C", signature, 64);
-    if (count == 10000000)
-      print_bytes("10M XEdDSA/C", signature, 64);
-  }
-  INFO("good\n");
-  return 0;
-}
-
-int vxeddsa_slow_test(int silent, int iterations)
-{
-
-  unsigned char signature_10k_correct[96] = {
-  0xa1, 0x96, 0x96, 0xe5, 0x87, 0x3f, 0x6e, 0x5c, 
-  0x2e, 0xd3, 0x73, 0xab, 0x04, 0x0c, 0x1f, 0x26, 
-  0x3c, 0xca, 0x52, 0xc4, 0x7e, 0x49, 0xaa, 0xce, 
-  0xb5, 0xd6, 0xa2, 0x29, 0x46, 0x3f, 0x1b, 0x54, 
-  0x45, 0x94, 0x9b, 0x6c, 0x27, 0xf9, 0x2a, 0xed, 
-  0x17, 0xa4, 0x72, 0xbf, 0x35, 0x37, 0xc1, 0x90, 
-  0xac, 0xb3, 0xfd, 0x2d, 0xf1, 0x01, 0x05, 0xbe, 
-  0x56, 0x5c, 0xaf, 0x63, 0x65, 0xad, 0x38, 0x04, 
-  0x70, 0x53, 0xdf, 0x2b, 0xc1, 0x45, 0xc8, 0xee, 
-  0x02, 0x0d, 0x2b, 0x22, 0x23, 0x7a, 0xbf, 0xfa, 
-  0x43, 0x31, 0xb3, 0xac, 0x26, 0xd9, 0x76, 0xfc, 
-  0xfe, 0x30, 0xa1, 0x7c, 0xce, 0x10, 0x67, 0x0e, 
-  };
-
-  unsigned char signature_100k_correct[96] = {
-  0xc9, 0x11, 0x2b, 0x55, 0xfa, 0xc4, 0xb2, 0xfe, 
-  0x00, 0x7d, 0xf6, 0x45, 0xcb, 0xd2, 0x73, 0xc9, 
-  0x43, 0xba, 0x20, 0xf6, 0x9c, 0x18, 0x84, 0xef, 
-  0x6c, 0x65, 0x7a, 0xdb, 0x49, 0xfc, 0x1e, 0xbe, 
-  0x31, 0xb3, 0xe6, 0xa4, 0x68, 0x2f, 0xd0, 0x30, 
-  0x81, 0xfc, 0x0d, 0xcd, 0x2d, 0x00, 0xab, 0xae, 
-  0x9f, 0x08, 0xf0, 0x99, 0xff, 0x9f, 0xdc, 0x2d, 
-  0x68, 0xd6, 0xe7, 0xe8, 0x44, 0x2a, 0x5b, 0x0e, 
-  0x48, 0x67, 0xe2, 0x41, 0x4a, 0xd9, 0x0c, 0x2a, 
-  0x2b, 0x4e, 0x66, 0x09, 0x87, 0xa0, 0x6b, 0x3b, 
-  0xd1, 0xd9, 0xa3, 0xe3, 0xa5, 0x69, 0xed, 0xc1, 
-  0x42, 0x03, 0x93, 0x0d, 0xbc, 0x7e, 0xe9, 0x08,
-  };
-
-  unsigned char signature_1m_correct[96] = {
-  0xf8, 0xb1, 0x20, 0xf2, 0x1e, 0x5c, 0xbf, 0x5f, 
-  0xea, 0x07, 0xcb, 0xb5, 0x77, 0xb8, 0x03, 0xbc, 
-  0xcb, 0x6d, 0xf1, 0xc1, 0xa5, 0x03, 0x05, 0x7b, 
-  0x01, 0x63, 0x9b, 0xf9, 0xed, 0x3e, 0x57, 0x47, 
-  0xd2, 0x5b, 0xf4, 0x7e, 0x7c, 0x45, 0xce, 0xfc, 
-  0x06, 0xb3, 0xf4, 0x05, 0x81, 0x9f, 0x53, 0xb0, 
-  0x18, 0xe3, 0xfa, 0xcb, 0xb2, 0x52, 0x3e, 0x57, 
-  0xcb, 0x34, 0xcc, 0x81, 0x60, 0xb9, 0x0b, 0x04, 
-  0x07, 0x79, 0xc0, 0x53, 0xad, 0xc4, 0x4b, 0xd0, 
-  0xb5, 0x7d, 0x95, 0x4e, 0xbe, 0xa5, 0x75, 0x0c, 
-  0xd4, 0xbf, 0xa7, 0xc0, 0xcf, 0xba, 0xe7, 0x7c, 
-  0xe2, 0x90, 0xef, 0x61, 0xa9, 0x29, 0x66, 0x0d,
-  };
-
-  unsigned char signature_10m_correct[96] = {
-  0xf5, 0xa4, 0xbc, 0xec, 0xc3, 0x3d, 0xd0, 0x43, 
-  0xd2, 0x81, 0x27, 0x9e, 0xf0, 0x4c, 0xbe, 0xf3, 
-  0x77, 0x01, 0x56, 0x41, 0x0e, 0xff, 0x0c, 0xb9, 
-  0x66, 0xec, 0x4d, 0xe0, 0xb7, 0x25, 0x63, 0x6b, 
-  0x5c, 0x08, 0x39, 0x80, 0x4e, 0x37, 0x1b, 0x2c, 
-  0x46, 0x6f, 0x86, 0x99, 0x1c, 0x4e, 0x31, 0x60, 
-  0xdb, 0x4c, 0xfe, 0xc5, 0xa2, 0x4d, 0x71, 0x2b, 
-  0xd6, 0xd0, 0xc3, 0x98, 0x88, 0xdb, 0x0e, 0x0c, 
-  0x68, 0x4a, 0xd3, 0xc7, 0x56, 0xac, 0x8d, 0x95, 
-  0x7b, 0xbd, 0x99, 0x50, 0xe8, 0xd3, 0xea, 0xf3, 
-  0x7b, 0x26, 0xf2, 0xa2, 0x2b, 0x02, 0x58, 0xca, 
-  0xbd, 0x2c, 0x2b, 0xf7, 0x77, 0x58, 0xfe, 0x09,
-  };
-
-  int count;  
-  const int MSG_LEN  = 200;
-  unsigned char privkey[32];
-  unsigned char pubkey[32];
-  unsigned char signature[96];
-  unsigned char msg[MSG_LEN];
-  unsigned char random[64];
-  unsigned char vrf_out[32];
-
-  memset(privkey, 0, 32);
-  memset(pubkey, 0, 32);
-  memset(signature, 3, 96);
-  memset(msg, 0, MSG_LEN);
-  memset(random, 0, 64);
-
-  INFO("Pseudorandom VXEdDSA...\n");
-  for (count = 1; count <= iterations; count++) {
-    unsigned char b[64];
-    crypto_hash_sha512(b, signature, 96);
-    memmove(privkey, b, 32);
-    crypto_hash_sha512(b, privkey, 32);
-    memmove(random, b, 64);
-
-    sc_clamp(privkey);
-    curve25519_keygen(pubkey, privkey);
-
-    vxed25519_sign(signature, privkey, msg, MSG_LEN, random);
-
-    if (vxed25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN) != 0)
-      ERROR("VXEdDSA verify failure #1 %d\n", count);
-
-    if (b[63] & 1)
-      signature[count % 96] ^= 1;
-    else
-      msg[count % MSG_LEN] ^= 1;
-
-    if (vxed25519_verify(vrf_out, signature, pubkey, msg, MSG_LEN) == 0)
-      ERROR("VXEdDSA verify failure #2 %d\n", count);
-
-    if (count == 10000)
-      print_bytes("10K VXEdDSA", signature, 96);
-    if (count == 100000)
-      print_bytes("100K VXEdDSA", signature, 96);
-    if (count == 1000000)
-      print_bytes("1M VXEdDSA", signature, 96);
-    if (count == 10000000)
-      print_bytes("10M VXEdDSA", signature, 96);
-    if (count == 100000000)
-      print_bytes("100M VXEdDSA", signature, 96);
-
-    if (count == 10000) {
-      if (memcmp(signature, signature_10k_correct, 96) != 0)
-        ERROR("VXEDDSA 10K doesn't match %d\n", count);
-    }
-    if (count == 100000) {
-      if (memcmp(signature, signature_100k_correct, 96) != 0)
-        ERROR("VXEDDSA 100K doesn't match %d\n", count);
-    }
-    if (count == 1000000) {
-      if (memcmp(signature, signature_1m_correct, 96) != 0)
-        ERROR("VXEDDSA 1m doesn't match %d\n", count);
-    }
-    if (count == 10000000) {
-      if (memcmp(signature, signature_10m_correct, 96) != 0)
-        ERROR("VXEDDSA 10m doesn't match %d\n", count);
-    }
-    /*
-    if (count == 100000000) {
-      if (memcmp(signature, signature_100m_correct, 96) != 0)
-        ERROR("VXEDDSA 100m doesn't match %d\n", count);
-    }
-    */
-  }
-  INFO("good\n");
-  return 0;
-}
-
-int all_fast_tests(int silent)
-{
-  int result;
-  if ((result = sha512_fast_test(silent)) != 0)
-    return result;
-  if ((result = elligator_fast_test(silent)) != 0)
-    return result;
-  if ((result = curvesigs_fast_test(silent)) != 0)
-    return result;
-  if ((result = xeddsa_fast_test(silent)) != 0)
-    return result;
-  if ((result = vxeddsa_fast_test(silent)) != 0)
-    return result;
-
-  return 0;
-}
-
diff --git a/src/device_consistency.c b/src/device_consistency.c
index eabcf09..a079d11 100644
--- a/src/device_consistency.c
+++ b/src/device_consistency.c
@@ -641,16 +641,18 @@ int device_consistency_signature_list_sort_comparator(const void *a, const void
     int result;
     const device_consistency_signature *sig1 = *((const device_consistency_signature **)a);
     const device_consistency_signature *sig2 = *((const device_consistency_signature **)b);
-    signal_buffer *buf1 = device_consistency_signature_get_signature(sig1);
-    signal_buffer *buf2 = device_consistency_signature_get_signature(sig2);
+    signal_buffer *buf1 = device_consistency_signature_get_vrf_output(sig1);
+    signal_buffer *buf2 = device_consistency_signature_get_vrf_output(sig2);
     size_t len1 = signal_buffer_len(buf1);
     size_t len2 = signal_buffer_len(buf2);
 
     if(len1 == len2) {
         result = memcmp(signal_buffer_data(buf1), signal_buffer_data(buf2), len1);
     }
-    else {
-        result = len1 - len2;
+    else if (len1 < len2) {
+        result = -1;
+    } else {
+        result = 1;
     }
 
     return result;
diff --git a/src/fingerprint.c b/src/fingerprint.c
index 4282782..1058e90 100644
--- a/src/fingerprint.c
+++ b/src/fingerprint.c
@@ -5,9 +5,10 @@
 
 #include "FingerprintProtocol.pb-c.h"
 #include "signal_protocol_internal.h"
+#include "vpool.h"
 
-#define VERSION 0
-#define SHA512_DIGEST_LENGTH 64
+#define FINGERPRINT_VERSION 0
+#define FINGERPRINT_LENGTH 30
 
 #define MAX(a,b) (((a)>(b))?(a):(b))
 
@@ -31,26 +32,44 @@ struct scannable_fingerprint
     signal_type_base base;
     uint32_t version;
     char *local_stable_identifier;
-    ec_public_key *local_identity_key;
+    signal_buffer *local_fingerprint;
     char *remote_stable_identifier;
-    ec_public_key *remote_identity_key;
+    signal_buffer *remote_fingerprint;
 };
 
 struct fingerprint_generator
 {
     int iterations;
+    int scannable_version;
     signal_context *global_context;
 };
 
-static int fingerprint_generator_create_display_string(fingerprint_generator *generator, char **display_string,
-        const char *local_stable_identifier, ec_public_key *identity_key);
+static int fingerprint_generator_get_logical_key_bytes(signal_buffer **key_bytes,
+        const ec_public_key_list *unsorted_key_list);
 
-int fingerprint_generator_create(fingerprint_generator **generator, int iterations, signal_context *global_context)
+static int fingerprint_generator_create_for_impl(fingerprint_generator *generator,
+        const char *local_stable_identifier, const signal_buffer *local_identity_buffer,
+        const char *remote_stable_identifier, const signal_buffer *remote_identity_buffer,
+        fingerprint **fingerprint_val);
+
+static int fingerprint_generator_get_fingerprint(fingerprint_generator *generator, signal_buffer **fingerprint_buffer,
+        const char *stable_identifier, const signal_buffer *identity_buffer);
+
+static int fingerprint_generator_create_display_string(fingerprint_generator *generator,
+        char **display_string, signal_buffer *fingerprint_buffer);
+
+int fingerprint_generator_create(fingerprint_generator **generator,
+        int iterations, int scannable_version,
+        signal_context *global_context)
 {
     fingerprint_generator *result_generator;
 
     assert(global_context);
 
+    if(scannable_version < 0 || scannable_version > 1) {
+        return SG_ERR_INVAL;
+    }
+
     result_generator = malloc(sizeof(fingerprint_generator));
     if(!result_generator) {
         return SG_ERR_NOMEM;
@@ -58,6 +77,7 @@ int fingerprint_generator_create(fingerprint_generator **generator, int iteratio
     memset(result_generator, 0, sizeof(fingerprint_generator));
 
     result_generator->iterations = iterations;
+    result_generator->scannable_version = scannable_version;
     result_generator->global_context = global_context;
 
     *generator = result_generator;
@@ -65,25 +85,99 @@ int fingerprint_generator_create(fingerprint_generator **generator, int iteratio
 }
 
 int fingerprint_generator_create_for(fingerprint_generator *generator,
-        const char *local_stable_identifier, ec_public_key *local_identity_key,
-        const char *remote_stable_identifier, ec_public_key *remote_identity_key,
+        const char *local_stable_identifier, const ec_public_key *local_identity_key,
+        const char *remote_stable_identifier, const ec_public_key *remote_identity_key,
+        fingerprint **fingerprint_val)
+{
+    int result = 0;
+    signal_buffer *local_key_buffer = 0;
+    signal_buffer *remote_key_buffer = 0;
+
+    result = ec_public_key_serialize(&local_key_buffer, local_identity_key);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = ec_public_key_serialize(&remote_key_buffer, remote_identity_key);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fingerprint_generator_create_for_impl(generator,
+            local_stable_identifier, local_key_buffer,
+            remote_stable_identifier, remote_key_buffer,
+            fingerprint_val);
+
+complete:
+    signal_buffer_free(local_key_buffer);
+    signal_buffer_free(remote_key_buffer);
+    return result;
+}
+
+int fingerprint_generator_create_for_list(fingerprint_generator *generator,
+        const char *local_stable_identifier, const ec_public_key_list *local_identity_key_list,
+        const char *remote_stable_identifier, const ec_public_key_list *remote_identity_key_list,
+        fingerprint **fingerprint_val)
+{
+    int result = 0;
+    signal_buffer *local_key_buffer = 0;
+    signal_buffer *remote_key_buffer = 0;
+
+    result = fingerprint_generator_get_logical_key_bytes(&local_key_buffer, local_identity_key_list);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fingerprint_generator_get_logical_key_bytes(&remote_key_buffer, remote_identity_key_list);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fingerprint_generator_create_for_impl(generator,
+            local_stable_identifier, local_key_buffer,
+            remote_stable_identifier, remote_key_buffer,
+            fingerprint_val);
+
+complete:
+    signal_buffer_free(local_key_buffer);
+    signal_buffer_free(remote_key_buffer);
+    return result;
+}
+
+int fingerprint_generator_create_for_impl(fingerprint_generator *generator,
+        const char *local_stable_identifier, const signal_buffer *local_identity_buffer,
+        const char *remote_stable_identifier, const signal_buffer *remote_identity_buffer,
         fingerprint **fingerprint_val)
 {
     int result = 0;
     fingerprint *result_fingerprint = 0;
+    signal_buffer *local_fingerprint_buffer = 0;
+    signal_buffer *remote_fingerprint_buffer = 0;
     displayable_fingerprint *displayable = 0;
     char *displayable_local = 0;
     char *displayable_remote = 0;
     scannable_fingerprint *scannable = 0;
 
+    result = fingerprint_generator_get_fingerprint(generator,
+            &local_fingerprint_buffer, local_stable_identifier, local_identity_buffer);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fingerprint_generator_get_fingerprint(generator,
+            &remote_fingerprint_buffer, remote_stable_identifier, remote_identity_buffer);
+    if(result < 0) {
+        goto complete;
+    }
+
     result = fingerprint_generator_create_display_string(generator, &displayable_local,
-            local_stable_identifier, local_identity_key);
+            local_fingerprint_buffer);
     if(result < 0) {
         goto complete;
     }
 
     result = fingerprint_generator_create_display_string(generator, &displayable_remote,
-            remote_stable_identifier, remote_identity_key);
+            remote_fingerprint_buffer);
     if(result < 0) {
         goto complete;
     }
@@ -93,9 +187,19 @@ int fingerprint_generator_create_for(fingerprint_generator *generator,
         goto complete;
     }
 
-    result = scannable_fingerprint_create(&scannable, VERSION,
-            local_stable_identifier, local_identity_key,
-            remote_stable_identifier, remote_identity_key);
+    if(generator->scannable_version == 0) {
+        result = scannable_fingerprint_create(&scannable, 0,
+                local_stable_identifier, local_identity_buffer,
+                remote_stable_identifier, remote_identity_buffer);
+    }
+    else if(generator->scannable_version == 1) {
+        result = scannable_fingerprint_create(&scannable, 1,
+                0, local_fingerprint_buffer,
+                0, remote_fingerprint_buffer);
+    }
+    else {
+        result = SG_ERR_INVAL;
+    }
     if(result < 0) {
         goto complete;
     }
@@ -103,6 +207,8 @@ int fingerprint_generator_create_for(fingerprint_generator *generator,
     result = fingerprint_create(&result_fingerprint, displayable, scannable);
 
 complete:
+    signal_buffer_free(local_fingerprint_buffer);
+    signal_buffer_free(remote_fingerprint_buffer);
     if(displayable_local) {
         free(displayable_local);
     }
@@ -117,13 +223,69 @@ complete:
     return result;
 }
 
-int fingerprint_generator_create_display_string(fingerprint_generator *generator, char **display_string,
-        const char *stable_identifier, ec_public_key *identity_key)
+int fingerprint_generator_get_logical_key_bytes(signal_buffer **key_bytes,
+        const ec_public_key_list *unsorted_key_list)
+{
+    int result = 0;
+    ec_public_key_list *sorted_key_list = 0;
+    ec_public_key *key_element = 0;
+    unsigned int list_size = 0;
+    unsigned int i = 0;
+    struct vpool vp;
+    signal_buffer *buffer = 0;
+
+    vpool_init(&vp, 1024, 0);
+
+    sorted_key_list = ec_public_key_list_copy(unsorted_key_list);
+    if(!sorted_key_list) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    ec_public_key_list_sort(sorted_key_list);
+    list_size = ec_public_key_list_size(sorted_key_list);
+
+    for(i = 0; i < list_size; i++) {
+        key_element = ec_public_key_list_at(sorted_key_list, i);
+
+        result = ec_public_key_serialize(&buffer, key_element);
+        if (result < 0) {
+            goto complete;
+        }
+
+        if(!vpool_insert(&vp, vpool_get_length(&vp),
+                signal_buffer_data(buffer), signal_buffer_len(buffer))) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+
+        signal_buffer_free(buffer);
+        buffer = 0;
+    }
+
+    buffer = signal_buffer_create(vpool_get_buf(&vp), vpool_get_length(&vp));
+    if(!buffer) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+complete:
+    ec_public_key_list_free(sorted_key_list);
+    vpool_final(&vp);
+    if(result >= 0) {
+        *key_bytes = buffer;
+    }
+    else {
+        signal_buffer_free(buffer);
+    }
+    return result;
+}
+
+int fingerprint_generator_get_fingerprint(fingerprint_generator *generator, signal_buffer **fingerprint_buffer,
+        const char *stable_identifier, const signal_buffer *identity_buffer)
 {
     int result = 0;
-    char *result_string = 0;
     void *digest_context = 0;
-    signal_buffer *identity_buffer = 0;
     signal_buffer *hash_buffer = 0;
     signal_buffer *hash_out_buffer = 0;
     uint8_t *data = 0;
@@ -132,18 +294,13 @@ int fingerprint_generator_create_display_string(fingerprint_generator *generator
 
     assert(generator);
     assert(stable_identifier);
-    assert(identity_key);
+    assert(identity_buffer);
 
     result = signal_sha512_digest_init(generator->global_context, &digest_context);
     if(result < 0) {
         goto complete;
     }
 
-    result = ec_public_key_serialize(&identity_buffer, identity_key);
-    if(result < 0) {
-        goto complete;
-    }
-
     len = 2 + signal_buffer_len(identity_buffer) + strlen(stable_identifier);
 
     hash_buffer = signal_buffer_alloc(len);
@@ -157,8 +314,8 @@ int fingerprint_generator_create_display_string(fingerprint_generator *generator
     memset(data, 0, len);
 
     data[0] = 0;
-    data[1] = (uint8_t)VERSION;
-    memcpy(data + 2, signal_buffer_data(identity_buffer), signal_buffer_len(identity_buffer));
+    data[1] = (uint8_t)FINGERPRINT_VERSION;
+    memcpy(data + 2, signal_buffer_const_data(identity_buffer), signal_buffer_len(identity_buffer));
     memcpy(data + 2 + signal_buffer_len(identity_buffer), stable_identifier, strlen(stable_identifier));
 
     for(i = 0; i < generator->iterations; i++) {
@@ -173,7 +330,7 @@ int fingerprint_generator_create_display_string(fingerprint_generator *generator
 
         result = signal_sha512_digest_update(generator->global_context,
                 digest_context,
-                signal_buffer_data(identity_buffer),
+                signal_buffer_const_data(identity_buffer),
                 signal_buffer_len(identity_buffer));
         if(result < 0) {
             goto complete;
@@ -190,21 +347,53 @@ int fingerprint_generator_create_display_string(fingerprint_generator *generator
         hash_out_buffer = 0;
     }
 
-    data = signal_buffer_data(hash_buffer);
     len = signal_buffer_len(hash_buffer);
 
-    if(len < 30) {
+    if(len < FINGERPRINT_LENGTH) {
         result = SG_ERR_UNKNOWN;
         goto complete;
     }
 
-    result_string = malloc(31);
+complete:
+    if(digest_context) {
+        signal_sha512_digest_cleanup(generator->global_context, digest_context);
+    }
+    if(result >= 0) {
+        *fingerprint_buffer = hash_buffer;
+    }
+    else {
+        signal_buffer_free(hash_buffer);
+    }
+    return result;
+}
+
+int fingerprint_generator_create_display_string(fingerprint_generator *generator,
+        char **display_string, signal_buffer *fingerprint_buffer)
+{
+    int result = 0;
+    char *result_string = 0;
+    uint8_t *data = 0;
+    size_t len = 0;
+    int i = 0;
+
+    assert(generator);
+    assert(fingerprint_buffer);
+
+    data = signal_buffer_data(fingerprint_buffer);
+    len = signal_buffer_len(fingerprint_buffer);
+
+    if(len < FINGERPRINT_LENGTH) {
+        result = SG_ERR_UNKNOWN;
+        goto complete;
+    }
+
+    result_string = malloc(FINGERPRINT_LENGTH+1);
     if(!result_string) {
         result = SG_ERR_NOMEM;
         goto complete;
     }
 
-    for(i = 0; i < 30; i += 5) {
+    for(i = 0; i < FINGERPRINT_LENGTH; i += 5) {
         uint64_t chunk = ((uint64_t)data[i] & 0xFFL) << 32 |
                 ((uint64_t)data[i + 1] & 0xFFL) << 24 |
                 ((uint64_t)data[i + 2] & 0xFFL) << 16 |
@@ -218,12 +407,6 @@ int fingerprint_generator_create_display_string(fingerprint_generator *generator
     }
 
 complete:
-    if(digest_context) {
-        signal_sha512_digest_cleanup(generator->global_context, digest_context);
-    }
-    signal_buffer_free(identity_buffer);
-    signal_buffer_free(hash_buffer);
-    signal_buffer_free(hash_out_buffer);
     if(result >= 0) {
         *display_string = result_string;
     }
@@ -260,13 +443,13 @@ int fingerprint_create(fingerprint **fingerprint_val, displayable_fingerprint *d
     return 0;
 }
 
-displayable_fingerprint *fingerprint_get_displayable(fingerprint *fingerprint_val)
+displayable_fingerprint *fingerprint_get_displayable(const fingerprint *fingerprint_val)
 {
     assert(fingerprint_val);
     return fingerprint_val->displayable;
 }
 
-scannable_fingerprint *fingerprint_get_scannable(fingerprint *fingerprint_val)
+scannable_fingerprint *fingerprint_get_scannable(const fingerprint *fingerprint_val)
 {
     assert(fingerprint_val);
     return fingerprint_val->scannable;
@@ -343,19 +526,19 @@ complete:
     return result;
 }
 
-const char *displayable_fingerprint_local(displayable_fingerprint *displayable)
+const char *displayable_fingerprint_local(const displayable_fingerprint *displayable)
 {
     assert(displayable);
     return displayable->local_fingerprint;
 }
 
-const char *displayable_fingerprint_remote(displayable_fingerprint *displayable)
+const char *displayable_fingerprint_remote(const displayable_fingerprint *displayable)
 {
     assert(displayable);
     return displayable->remote_fingerprint;
 }
 
-const char *displayable_fingerprint_text(displayable_fingerprint *displayable)
+const char *displayable_fingerprint_text(const displayable_fingerprint *displayable)
 {
     assert(displayable);
     return displayable->display_text;
@@ -378,14 +561,17 @@ void displayable_fingerprint_destroy(signal_type_base *type)
 
 int scannable_fingerprint_create(scannable_fingerprint **scannable,
         uint32_t version,
-        const char *local_stable_identifier, ec_public_key *local_identity_key,
-        const char *remote_stable_identifier, ec_public_key *remote_identity_key)
+        const char *local_stable_identifier, const signal_buffer *local_fingerprint,
+        const char *remote_stable_identifier, const signal_buffer *remote_fingerprint)
 {
     int result = 0;
     scannable_fingerprint *result_scannable = 0;
 
-    if(!local_stable_identifier || !local_identity_key ||
-            !remote_stable_identifier || !remote_identity_key) {
+    if(version == 0 && (!local_stable_identifier || !remote_stable_identifier)) {
+        return SG_ERR_INVAL;
+    }
+
+    if(!local_fingerprint || !remote_fingerprint) {
         return SG_ERR_INVAL;
     }
 
@@ -399,24 +585,44 @@ int scannable_fingerprint_create(scannable_fingerprint **scannable,
 
     result_scannable->version = version;
 
-    result_scannable->local_stable_identifier = strdup(local_stable_identifier);
-    if(!result_scannable->local_stable_identifier) {
+    if(version == 0 && local_stable_identifier) {
+        result_scannable->local_stable_identifier = strdup(local_stable_identifier);
+        if(!result_scannable->local_stable_identifier) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+    }
+
+    if(version == 0) {
+        result_scannable->local_fingerprint = signal_buffer_copy(local_fingerprint);
+    }
+    else {
+        result_scannable->local_fingerprint = signal_buffer_n_copy(local_fingerprint, 32);
+    }
+    if(!result_scannable->local_fingerprint) {
         result = SG_ERR_NOMEM;
         goto complete;
     }
 
-    result_scannable->local_identity_key = local_identity_key;
-    SIGNAL_REF(local_identity_key);
+    if(version == 0 && remote_stable_identifier) {
+        result_scannable->remote_stable_identifier = strdup(remote_stable_identifier);
+        if(!result_scannable->remote_stable_identifier) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+    }
 
-    result_scannable->remote_stable_identifier = strdup(remote_stable_identifier);
-    if(!result_scannable->remote_stable_identifier) {
+    if(version == 0) {
+        result_scannable->remote_fingerprint = signal_buffer_copy(remote_fingerprint);
+    }
+    else {
+        result_scannable->remote_fingerprint = signal_buffer_n_copy(remote_fingerprint, 32);
+    }
+    if(!result_scannable->remote_fingerprint) {
         result = SG_ERR_NOMEM;
         goto complete;
     }
 
-    result_scannable->remote_identity_key = remote_identity_key;
-    SIGNAL_REF(remote_identity_key);
-
 complete:
     if(result < 0) {
         SIGNAL_UNREF(result_scannable);
@@ -433,42 +639,42 @@ int scannable_fingerprint_serialize(signal_buffer **buffer, const scannable_fing
     int result = 0;
     size_t result_size = 0;
     signal_buffer *result_buf = 0;
-    Textsecure__CombinedFingerprint combined_fingerprint = TEXTSECURE__COMBINED_FINGERPRINT__INIT;
-    Textsecure__FingerprintData local_fingerprint = TEXTSECURE__FINGERPRINT_DATA__INIT;
-    Textsecure__FingerprintData remote_fingerprint = TEXTSECURE__FINGERPRINT_DATA__INIT;
+    Textsecure__CombinedFingerprints combined_fingerprint = TEXTSECURE__COMBINED_FINGERPRINTS__INIT;
+    Textsecure__LogicalFingerprint local_fingerprint = TEXTSECURE__LOGICAL_FINGERPRINT__INIT;
+    Textsecure__LogicalFingerprint remote_fingerprint = TEXTSECURE__LOGICAL_FINGERPRINT__INIT;
     size_t len = 0;
     uint8_t *data = 0;
 
     combined_fingerprint.version = scannable->version;
     combined_fingerprint.has_version = 1;
 
-    if(scannable->local_stable_identifier && scannable->local_identity_key) {
-        signal_protocol_str_serialize_protobuf(&local_fingerprint.identifier, scannable->local_stable_identifier);
-        local_fingerprint.has_identifier = 1;
-
-        result = ec_public_key_serialize_protobuf(&local_fingerprint.publickey, scannable->local_identity_key);
-        if(result < 0) {
-            goto complete;
+    if(scannable->local_fingerprint) {
+        if(scannable->version == 0 && scannable->local_stable_identifier) {
+            signal_protocol_str_serialize_protobuf(&local_fingerprint.identifier, scannable->local_stable_identifier);
+            local_fingerprint.has_identifier = 1;
         }
-        local_fingerprint.has_publickey = 1;
+
+        local_fingerprint.content.data = signal_buffer_data(scannable->local_fingerprint);
+        local_fingerprint.content.len = signal_buffer_len(scannable->local_fingerprint);
+        local_fingerprint.has_content = 1;
 
         combined_fingerprint.localfingerprint = &local_fingerprint;
     }
 
-    if(scannable->remote_stable_identifier && scannable->remote_identity_key) {
-        signal_protocol_str_serialize_protobuf(&remote_fingerprint.identifier, scannable->remote_stable_identifier);
-        remote_fingerprint.has_identifier = 1;
-
-        result = ec_public_key_serialize_protobuf(&remote_fingerprint.publickey, scannable->remote_identity_key);
-        if(result < 0) {
-            goto complete;
+    if(scannable->remote_fingerprint) {
+        if(scannable->version == 0 && scannable->remote_stable_identifier) {
+            signal_protocol_str_serialize_protobuf(&remote_fingerprint.identifier, scannable->remote_stable_identifier);
+            remote_fingerprint.has_identifier = 1;
         }
-        remote_fingerprint.has_publickey = 1;
+
+        remote_fingerprint.content.data = signal_buffer_data(scannable->remote_fingerprint);
+        remote_fingerprint.content.len = signal_buffer_len(scannable->remote_fingerprint);
+        remote_fingerprint.has_content = 1;
 
         combined_fingerprint.remotefingerprint = &remote_fingerprint;
     }
 
-    len = textsecure__combined_fingerprint__get_packed_size(&combined_fingerprint);
+    len = textsecure__combined_fingerprints__get_packed_size(&combined_fingerprint);
 
     result_buf = signal_buffer_alloc(len);
     if(!result_buf) {
@@ -477,7 +683,7 @@ int scannable_fingerprint_serialize(signal_buffer **buffer, const scannable_fing
     }
 
     data = signal_buffer_data(result_buf);
-    result_size = textsecure__combined_fingerprint__pack(&combined_fingerprint, data);
+    result_size = textsecure__combined_fingerprints__pack(&combined_fingerprint, data);
     if(result_size != len) {
         signal_buffer_free(result_buf);
         result = SG_ERR_INVALID_PROTO_BUF;
@@ -486,12 +692,6 @@ int scannable_fingerprint_serialize(signal_buffer **buffer, const scannable_fing
     }
 
 complete:
-    if(local_fingerprint.publickey.data) {
-        free(local_fingerprint.publickey.data);
-    }
-    if(remote_fingerprint.publickey.data) {
-        free(remote_fingerprint.publickey.data);
-    }
     if(result >= 0) {
         *buffer = result_buf;
     }
@@ -501,14 +701,14 @@ complete:
 int scannable_fingerprint_deserialize(scannable_fingerprint **scannable, const uint8_t *data, size_t len, signal_context *global_context)
 {
     int result = 0;
-    Textsecure__CombinedFingerprint *combined_fingerprint = 0;
+    Textsecure__CombinedFingerprints *combined_fingerprint = 0;
     uint32_t version = 0;
     char *local_stable_identifier = 0;
-    ec_public_key *local_identity_key = 0;
+    signal_buffer *local_fingerprint = 0;
     char *remote_stable_identifier = 0;
-    ec_public_key *remote_identity_key = 0;
+    signal_buffer *remote_fingerprint = 0;
 
-    combined_fingerprint = textsecure__combined_fingerprint__unpack(0, len, data);
+    combined_fingerprint = textsecure__combined_fingerprints__unpack(0, len, data);
     if(!combined_fingerprint) {
         result = SG_ERR_INVALID_PROTO_BUF;
         goto complete;
@@ -526,12 +726,12 @@ int scannable_fingerprint_deserialize(scannable_fingerprint **scannable, const u
                 goto complete;
             }
         }
-        if(combined_fingerprint->localfingerprint->has_publickey) {
-            result = curve_decode_point(&local_identity_key,
-                    combined_fingerprint->localfingerprint->publickey.data,
-                    combined_fingerprint->localfingerprint->publickey.len,
-                    global_context);
-            if(result < 0) {
+        if(combined_fingerprint->localfingerprint->has_content) {
+            local_fingerprint = signal_buffer_create(
+                    combined_fingerprint->localfingerprint->content.data,
+                    combined_fingerprint->localfingerprint->content.len);
+            if(!local_fingerprint) {
+                result = SG_ERR_NOMEM;
                 goto complete;
             }
         }
@@ -545,90 +745,88 @@ int scannable_fingerprint_deserialize(scannable_fingerprint **scannable, const u
                 goto complete;
             }
         }
-        if(combined_fingerprint->remotefingerprint->has_publickey) {
-            result = curve_decode_point(&remote_identity_key,
-                    combined_fingerprint->remotefingerprint->publickey.data,
-                    combined_fingerprint->remotefingerprint->publickey.len,
-                    global_context);
-            if(result < 0) {
+        if(combined_fingerprint->remotefingerprint->has_content) {
+            remote_fingerprint = signal_buffer_create(
+                    combined_fingerprint->remotefingerprint->content.data,
+                    combined_fingerprint->remotefingerprint->content.len);
+            if(!remote_fingerprint) {
+                result = SG_ERR_NOMEM;
                 goto complete;
             }
         }
     }
 
     result = scannable_fingerprint_create(scannable, version,
-            local_stable_identifier, local_identity_key,
-            remote_stable_identifier, remote_identity_key);
+            local_stable_identifier, local_fingerprint,
+            remote_stable_identifier, remote_fingerprint);
 
 complete:
     if(combined_fingerprint) {
-        textsecure__combined_fingerprint__free_unpacked(combined_fingerprint, 0);
+        textsecure__combined_fingerprints__free_unpacked(combined_fingerprint, 0);
     }
     if(local_stable_identifier) {
         free(local_stable_identifier);
     }
-    if(local_identity_key) {
-        SIGNAL_UNREF(local_identity_key);
-    }
     if(remote_stable_identifier) {
         free(remote_stable_identifier);
     }
-    if(remote_identity_key) {
-        SIGNAL_UNREF(remote_identity_key);
-    }
+    signal_buffer_free(local_fingerprint);
+    signal_buffer_free(remote_fingerprint);
     return result;
 }
 
-uint32_t scannable_fingerprint_get_version(scannable_fingerprint *scannable)
+uint32_t scannable_fingerprint_get_version(const scannable_fingerprint *scannable)
 {
     assert(scannable);
     return scannable->version;
 }
 
-const char *scannable_fingerprint_get_local_stable_identifier(scannable_fingerprint *scannable)
+const char *scannable_fingerprint_get_local_stable_identifier(const scannable_fingerprint *scannable)
 {
     assert(scannable);
     return scannable->local_stable_identifier;
 }
 
-ec_public_key *scannable_fingerprint_get_local_identity_key(scannable_fingerprint *scannable)
+signal_buffer *scannable_fingerprint_get_local_fingerprint(const scannable_fingerprint *scannable)
 {
     assert(scannable);
-    return scannable->local_identity_key;
+    return scannable->local_fingerprint;
 }
 
-const char *scannable_fingerprint_get_remote_stable_identifier(scannable_fingerprint *scannable)
+const char *scannable_fingerprint_get_remote_stable_identifier(const scannable_fingerprint *scannable)
 {
     assert(scannable);
     return scannable->remote_stable_identifier;
 }
 
-ec_public_key *scannable_fingerprint_get_remote_identity_key(scannable_fingerprint *scannable)
+signal_buffer *scannable_fingerprint_get_remote_fingerprint(const scannable_fingerprint *scannable)
 {
     assert(scannable);
-    return scannable->remote_identity_key;
+    return scannable->remote_fingerprint;
 }
 
-int scannable_fingerprint_compare(scannable_fingerprint *scannable, const scannable_fingerprint *other_scannable)
+int scannable_fingerprint_compare(const scannable_fingerprint *scannable, const scannable_fingerprint *other_scannable)
 {
-    if(!other_scannable->remote_identity_key || !other_scannable->local_identity_key ||
+    if(!other_scannable->remote_fingerprint || !other_scannable->local_fingerprint ||
             other_scannable->version != scannable->version) {
         return SG_ERR_FP_VERSION_MISMATCH;
     }
 
-    if(strcmp(scannable->local_stable_identifier, other_scannable->remote_stable_identifier) != 0) {
-        return SG_ERR_FP_IDENT_MISMATCH;
-    }
+    if(scannable->version == 0) {
+        if(strcmp(scannable->local_stable_identifier, other_scannable->remote_stable_identifier) != 0) {
+            return SG_ERR_FP_IDENT_MISMATCH;
+        }
 
-    if(strcmp(scannable->remote_stable_identifier, other_scannable->local_stable_identifier) != 0) {
-        return SG_ERR_FP_IDENT_MISMATCH;
+        if(strcmp(scannable->remote_stable_identifier, other_scannable->local_stable_identifier) != 0) {
+            return SG_ERR_FP_IDENT_MISMATCH;
+        }
     }
 
-    if(ec_public_key_compare(scannable->local_identity_key, other_scannable->remote_identity_key) != 0) {
+    if(signal_buffer_compare(scannable->local_fingerprint, other_scannable->remote_fingerprint) != 0) {
         return 0;
     }
 
-    if(ec_public_key_compare(scannable->remote_identity_key, other_scannable->local_identity_key) != 0) {
+    if(signal_buffer_compare(scannable->remote_fingerprint, other_scannable->local_fingerprint) != 0) {
         return 0;
     }
 
@@ -642,14 +840,12 @@ void scannable_fingerprint_destroy(signal_type_base *type)
     if(scannable->local_stable_identifier) {
         free(scannable->local_stable_identifier);
     }
-
-    SIGNAL_UNREF(scannable->local_identity_key);
-
     if(scannable->remote_stable_identifier) {
         free(scannable->remote_stable_identifier);
     }
 
-    SIGNAL_UNREF(scannable->remote_identity_key);
+    signal_buffer_free(scannable->local_fingerprint);
+    signal_buffer_free(scannable->remote_fingerprint);
 
     free(scannable);
 }
diff --git a/src/fingerprint.h b/src/fingerprint.h
index 4d61e4f..9bc434e 100644
--- a/src/fingerprint.h
+++ b/src/fingerprint.h
@@ -16,14 +16,16 @@ extern "C" {
  *                   across all clients.
  *
  *                   The higher the iteration count, the higher the security level:
- *
  *                   - 1024 ~ 109.7 bits
  *                   - 1400 > 110 bits
  *                   - 5200 > 112 bits
+ * @param scannable_version The format version for the scannable fingerprint (0 or 1)
  * @param global_context the global library context
  * @return 0 on success, or negative on failure
  */
-int fingerprint_generator_create(fingerprint_generator **generator, int iterations, signal_context *global_context);
+int fingerprint_generator_create(fingerprint_generator **generator,
+        int iterations, int scannable_version,
+        signal_context *global_context);
 
 /**
  * Generate a scannable and displayble fingerprint.
@@ -36,35 +38,50 @@ int fingerprint_generator_create(fingerprint_generator **generator, int iteratio
  * @return 0 on success, or negative on failure
  */
 int fingerprint_generator_create_for(fingerprint_generator *generator,
-        const char *local_stable_identifier, ec_public_key *local_identity_key,
-        const char *remote_stable_identifier, ec_public_key *remote_identity_key,
+        const char *local_stable_identifier, const ec_public_key *local_identity_key,
+        const char *remote_stable_identifier, const ec_public_key *remote_identity_key,
+        fingerprint **fingerprint_val);
+
+/**
+ * Generate a scannable and displayble fingerprint for a list of keys
+ *
+ * @param local_stable_identifier The client's "stable" identifier.
+ * @param local_identity_key_list The client's identity key list.
+ * @param remote_stable_identifier The remote party's "stable" identifier.
+ * @param remote_identity_key_list The remote party's identity key list.
+ * @param fingerprint Set to a freshly allocated unique fingerprint for this conversation
+ * @return 0 on success, or negative on failure
+ */
+int fingerprint_generator_create_for_list(fingerprint_generator *generator,
+        const char *local_stable_identifier, const ec_public_key_list *local_identity_key_list,
+        const char *remote_stable_identifier, const ec_public_key_list *remote_identity_key_list,
         fingerprint **fingerprint_val);
 
 void fingerprint_generator_free(fingerprint_generator *generator);
 
 int fingerprint_create(fingerprint **fingerprint_val, displayable_fingerprint *displayable, scannable_fingerprint *scannable);
-displayable_fingerprint *fingerprint_get_displayable(fingerprint *fingerprint_val);
-scannable_fingerprint *fingerprint_get_scannable(fingerprint *fingerprint_val);
+displayable_fingerprint *fingerprint_get_displayable(const fingerprint *fingerprint_val);
+scannable_fingerprint *fingerprint_get_scannable(const fingerprint *fingerprint_val);
 void fingerprint_destroy(signal_type_base *type);
 
 int displayable_fingerprint_create(displayable_fingerprint **displayable, const char *local_fingerprint, const char *remote_fingerprint);
-const char *displayable_fingerprint_local(displayable_fingerprint *displayable);
-const char *displayable_fingerprint_remote(displayable_fingerprint *displayable);
-const char *displayable_fingerprint_text(displayable_fingerprint *displayable);
+const char *displayable_fingerprint_local(const displayable_fingerprint *displayable);
+const char *displayable_fingerprint_remote(const displayable_fingerprint *displayable);
+const char *displayable_fingerprint_text(const displayable_fingerprint *displayable);
 void displayable_fingerprint_destroy(signal_type_base *type);
 
 int scannable_fingerprint_create(scannable_fingerprint **scannable,
         uint32_t version,
-        const char *local_stable_identifier, ec_public_key *local_identity_key,
-        const char *remote_stable_identifier, ec_public_key *remote_identity_key);
+        const char *local_stable_identifier, const signal_buffer *local_fingerprint,
+        const char *remote_stable_identifier, const signal_buffer *remote_fingerprint);
 
 int scannable_fingerprint_serialize(signal_buffer **buffer, const scannable_fingerprint *scannable);
 int scannable_fingerprint_deserialize(scannable_fingerprint **scannable, const uint8_t *data, size_t len, signal_context *global_context);
-uint32_t scannable_fingerprint_get_version(scannable_fingerprint *scannable);
-const char *scannable_fingerprint_get_local_stable_identifier(scannable_fingerprint *scannable);
-ec_public_key *scannable_fingerprint_get_local_identity_key(scannable_fingerprint *scannable);
-const char *scannable_fingerprint_get_remote_stable_identifier(scannable_fingerprint *scannable);
-ec_public_key *scannable_fingerprint_get_remote_identity_key(scannable_fingerprint *scannable);
+uint32_t scannable_fingerprint_get_version(const scannable_fingerprint *scannable);
+const char *scannable_fingerprint_get_local_stable_identifier(const scannable_fingerprint *scannable);
+signal_buffer *scannable_fingerprint_get_local_fingerprint(const scannable_fingerprint *scannable);
+const char *scannable_fingerprint_get_remote_stable_identifier(const scannable_fingerprint *scannable);
+signal_buffer *scannable_fingerprint_get_remote_fingerprint(const scannable_fingerprint *scannable);
 
 /**
  * Compare a scanned QR code with what we expect.
@@ -75,7 +92,7 @@ ec_public_key *scannable_fingerprint_get_remote_identity_key(scannable_fingerpri
  * @retval SG_ERR_FP_VERSION_MISMATCH if the scanned fingerprint is the wrong version
  * @retval SG_ERR_FP_IDENT_MISMATCH if the scanned fingerprint is for the wrong stable identifier
  */
-int scannable_fingerprint_compare(scannable_fingerprint *scannable, const scannable_fingerprint *other_scannable);
+int scannable_fingerprint_compare(const scannable_fingerprint *scannable, const scannable_fingerprint *other_scannable);
 
 void scannable_fingerprint_destroy(signal_type_base *type);
 
diff --git a/src/key_helper.c b/src/key_helper.c
index 80deb6a..e2de8d4 100644
--- a/src/key_helper.c
+++ b/src/key_helper.c
@@ -201,29 +201,6 @@ void signal_protocol_key_helper_key_list_free(signal_protocol_key_helper_pre_key
     }
 }
 
-int signal_protocol_key_helper_generate_last_resort_pre_key(session_pre_key **pre_key, signal_context *global_context)
-{
-    int result = 0;
-    session_pre_key *result_pre_key = 0;
-    ec_key_pair *ec_pair = 0;
-
-    assert(global_context);
-
-    result = curve_generate_key_pair(global_context, &ec_pair);
-    if(result < 0) {
-        goto complete;
-    }
-
-    result = session_pre_key_create(&result_pre_key, PRE_KEY_MEDIUM_MAX_VALUE, ec_pair);
-
-complete:
-    SIGNAL_UNREF(ec_pair);
-    if(result >= 0) {
-        *pre_key = result_pre_key;
-    }
-    return result;
-}
-
 int signal_protocol_key_helper_generate_signed_pre_key(session_signed_pre_key **signed_pre_key,
         const ratchet_identity_key_pair *identity_key_pair,
         uint32_t signed_pre_key_id,
diff --git a/src/key_helper.h b/src/key_helper.h
index be3ef84..9ec765b 100644
--- a/src/key_helper.h
+++ b/src/key_helper.h
@@ -32,10 +32,10 @@ int signal_protocol_key_helper_generate_identity_key_pair(ratchet_identity_key_p
 int signal_protocol_key_helper_generate_registration_id(uint32_t *registration_id, int extended_range, signal_context *global_context);
 
 /**
- * Generate a random number bounded by the provided maximum
+ * Generate a random number between 0 (inclusive) and the provided maximum (exclusive).
  *
  * @param value set to the next random number
- * @param max the maximum value of the random number
+ * @param max the maximum bound on the value of the random number
  * @return 0 on success, or negative on failure
  */
 int signal_protocol_key_helper_get_random_sequence(int *value, int max, signal_context *global_context);
@@ -83,15 +83,6 @@ signal_protocol_key_helper_pre_key_list_node *signal_protocol_key_helper_key_lis
  */
 void signal_protocol_key_helper_key_list_free(signal_protocol_key_helper_pre_key_list_node *head);
 
-/**
- * Generate the last resort pre key.  Clients should do this only once, at
- * install time, and durably store it for the length of the install.
- *
- * @param pre_key set to the generated pre key
- * @return 0 on success, or negative on failure
- */
-int signal_protocol_key_helper_generate_last_resort_pre_key(session_pre_key **pre_key, signal_context *global_context);
-
 /**
  * Generate a signed pre key
  *
diff --git a/src/libsignal-protocol-c.pc.in b/src/libsignal-protocol-c.pc.in
new file mode 100644
index 0000000..af838f7
--- /dev/null
+++ b/src/libsignal-protocol-c.pc.in
@@ -0,0 +1,13 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=@LIB_INSTALL_DIR@
+sharedlibdir=@LIB_INSTALL_DIR@
+includedir=@INCLUDE_INSTALL_DIR@
+
+Name: @PROJECT_NAME@
+Description: Signal Protocol C Library
+Version: @SIGNAL_PROTOCOL_C_VERSION@
+
+Requires:
+Libs: -L${libdir} -L${sharedlibdir} -l@PROJECT_NAME@
+Cflags: -I${includedir}/signal
\ No newline at end of file
diff --git a/src/sender_key_record.c b/src/sender_key_record.c
index 9c7a2be..e6057ae 100644
--- a/src/sender_key_record.c
+++ b/src/sender_key_record.c
@@ -19,6 +19,7 @@ struct sender_key_record
 {
     signal_type_base base;
     sender_key_state_node *sender_key_states_head;
+    signal_buffer *user_record;
     signal_context *global_context;
 };
 
@@ -174,6 +175,7 @@ complete:
 int sender_key_record_copy(sender_key_record **record, sender_key_record *other_record, signal_context *global_context)
 {
     int result = 0;
+    sender_key_record *result_record = 0;
     signal_buffer *buffer = 0;
     uint8_t *data;
     size_t len;
@@ -189,15 +191,28 @@ int sender_key_record_copy(sender_key_record **record, sender_key_record *other_
     data = signal_buffer_data(buffer);
     len = signal_buffer_len(buffer);
 
-    result = sender_key_record_deserialize(record, data, len, global_context);
+    result = sender_key_record_deserialize(&result_record, data, len, global_context);
     if(result < 0) {
         goto complete;
     }
+    if(other_record->user_record) {
+        result_record->user_record = signal_buffer_copy(other_record->user_record);
+        if(!result_record->user_record) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+    }
 
 complete:
     if(buffer) {
         signal_buffer_free(buffer);
     }
+    if(result >= 0) {
+        *record = result_record;
+    }
+    else {
+        SIGNAL_UNREF(result_record);
+    }
     return result;
 }
 
@@ -324,6 +339,21 @@ int sender_key_record_set_sender_key_state(sender_key_record *record,
     return result;
 }
 
+signal_buffer *sender_key_record_get_user_record(const sender_key_record *record)
+{
+    assert(record);
+    return record->user_record;
+}
+
+void sender_key_record_set_user_record(sender_key_record *record, signal_buffer *user_record)
+{
+    assert(record);
+    if(record->user_record) {
+        signal_buffer_free(record->user_record);
+    }
+    record->user_record = user_record;
+}
+
 void sender_key_record_destroy(signal_type_base *type)
 {
     sender_key_record *record = (sender_key_record *)type;
@@ -339,5 +369,9 @@ void sender_key_record_destroy(signal_type_base *type)
     }
     record->sender_key_states_head = 0;
 
+    if(record->user_record) {
+        signal_buffer_free(record->user_record);
+    }
+
     free(record);
 }
diff --git a/src/sender_key_record.h b/src/sender_key_record.h
index 4cc4f92..f1113ce 100644
--- a/src/sender_key_record.h
+++ b/src/sender_key_record.h
@@ -21,6 +21,9 @@ int sender_key_record_add_sender_key_state(sender_key_record *record,
 int sender_key_record_set_sender_key_state(sender_key_record *record,
         uint32_t id, uint32_t iteration, signal_buffer *chain_key, ec_key_pair *signature_key_pair);
 
+signal_buffer *sender_key_record_get_user_record(const sender_key_record *record);
+void sender_key_record_set_user_record(sender_key_record *record, signal_buffer *user_record);
+
 void sender_key_record_destroy(signal_type_base *type);
 
 #ifdef __cplusplus
diff --git a/src/session_record.c b/src/session_record.c
index 0f72e90..71b61ce 100644
--- a/src/session_record.c
+++ b/src/session_record.c
@@ -23,6 +23,7 @@ struct session_record
     session_state *state;
     session_record_state_node *previous_states_head;
     int is_fresh;
+    signal_buffer *user_record;
     signal_context *global_context;
 };
 
@@ -239,6 +240,7 @@ complete:
 int session_record_copy(session_record **record, session_record *other_record, signal_context *global_context)
 {
     int result = 0;
+    session_record *result_record;
     signal_buffer *buffer = 0;
     size_t len = 0;
     uint8_t *data = 0;
@@ -254,15 +256,28 @@ int session_record_copy(session_record **record, session_record *other_record, s
     data = signal_buffer_data(buffer);
     len = signal_buffer_len(buffer);
 
-    result = session_record_deserialize(record, data, len, global_context);
+    result = session_record_deserialize(&result_record, data, len, global_context);
     if(result < 0) {
         goto complete;
     }
+    if(other_record->user_record) {
+        result_record->user_record = signal_buffer_copy(other_record->user_record);
+        if(!result_record->user_record) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+    }
 
 complete:
     if(buffer) {
         signal_buffer_free(buffer);
     }
+    if(result >= 0) {
+        *record = result_record;
+    }
+    else {
+        SIGNAL_UNREF(result_record);
+    }
     return result;
 }
 
@@ -419,6 +434,21 @@ static void session_record_free_previous_states(session_record *record)
     record->previous_states_head = 0;
 }
 
+signal_buffer *session_record_get_user_record(const session_record *record)
+{
+    assert(record);
+    return record->user_record;
+}
+
+void session_record_set_user_record(session_record *record, signal_buffer *user_record)
+{
+    assert(record);
+    if(record->user_record) {
+        signal_buffer_free(record->user_record);
+    }
+    record->user_record = user_record;
+}
+
 void session_record_destroy(signal_type_base *type)
 {
     session_record *record = (session_record *)type;
@@ -428,5 +458,9 @@ void session_record_destroy(signal_type_base *type)
     }
     session_record_free_previous_states(record);
 
+    if(record->user_record) {
+        signal_buffer_free(record->user_record);
+    }
+
     free(record);
 }
diff --git a/src/session_record.h b/src/session_record.h
index 581e232..ec21d08 100644
--- a/src/session_record.h
+++ b/src/session_record.h
@@ -41,6 +41,9 @@ int session_record_archive_current_state(session_record *record);
 
 int session_record_promote_state(session_record *record, session_state *promoted_state);
 
+signal_buffer *session_record_get_user_record(const session_record *record);
+void session_record_set_user_record(session_record *record, signal_buffer *user_record);
+
 void session_record_destroy(signal_type_base *type);
 
 #ifdef __cplusplus
diff --git a/src/session_state.c b/src/session_state.c
index 94cf9d3..a4dfb9a 100644
--- a/src/session_state.c
+++ b/src/session_state.c
@@ -24,7 +24,6 @@ typedef struct session_state_sender_chain
 {
     ec_key_pair *sender_ratchet_key_pair;
     ratchet_chain_key *chain_key;
-    message_keys_node *message_keys_head;
 } session_state_sender_chain;
 
 typedef struct session_state_receiver_chain
@@ -405,13 +404,6 @@ static int session_state_serialize_prepare_sender_chain(
         }
     }
 
-    if(chain->message_keys_head) {
-        result = session_state_serialize_prepare_chain_message_keys_list(chain->message_keys_head, chain_structure);
-        if(result < 0) {
-            goto complete;
-        }
-    }
-
 complete:
     return result;
 }
@@ -1790,17 +1782,6 @@ static void session_state_free_sender_chain(session_state *state)
         SIGNAL_UNREF(state->sender_chain.chain_key);
         state->sender_chain.chain_key = 0;
     }
-
-    if(state->sender_chain.message_keys_head) {
-        message_keys_node *cur_node;
-        message_keys_node *tmp_node;
-        DL_FOREACH_SAFE(state->sender_chain.message_keys_head, cur_node, tmp_node) {
-            DL_DELETE(state->sender_chain.message_keys_head, cur_node);
-            signal_explicit_bzero(&cur_node->message_key, sizeof(ratchet_message_keys));
-            free(cur_node);
-        }
-        state->sender_chain.message_keys_head = 0;
-    }
 }
 
 static void session_state_free_receiver_chain_node(session_state_receiver_chain *node)
diff --git a/src/signal_protocol.c b/src/signal_protocol.c
index 11b0c51..d9ea5b5 100644
--- a/src/signal_protocol.c
+++ b/src/signal_protocol.c
@@ -20,6 +20,8 @@ int type_ref_count = 0;
 int type_unref_count = 0;
 #endif
 
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
 struct signal_protocol_store_context {
     signal_context *global_context;
     signal_protocol_session_store session_store;
@@ -107,6 +109,12 @@ signal_buffer *signal_buffer_copy(const signal_buffer *buffer)
     return signal_buffer_create(buffer->data, buffer->len);
 }
 
+signal_buffer *signal_buffer_n_copy(const signal_buffer *buffer, size_t n)
+{
+    size_t len = MIN(buffer->len, n);
+    return signal_buffer_create(buffer->data, len);
+}
+
 signal_buffer *signal_buffer_append(signal_buffer *buffer, const uint8_t *data, size_t len)
 {
     signal_buffer *tmp_buffer;
@@ -132,7 +140,12 @@ uint8_t *signal_buffer_data(signal_buffer *buffer)
     return buffer->data;
 }
 
-size_t signal_buffer_len(signal_buffer *buffer)
+const uint8_t *signal_buffer_const_data(const signal_buffer *buffer)
+{
+    return buffer->data;
+}
+
+size_t signal_buffer_len(const signal_buffer *buffer)
 {
     return buffer->len;
 }
@@ -229,7 +242,7 @@ signal_buffer_list *signal_buffer_list_copy(const signal_buffer_list *list)
     for(i = 0; i < list_size; i++) {
         signal_buffer **buffer = (signal_buffer**)utarray_eltptr(list->values, i);
         buffer_copy = signal_buffer_copy(*buffer);
-        utarray_push_back(list->values, &buffer_copy);
+        utarray_push_back(result_list->values, &buffer_copy);
         buffer_copy = 0;
     }
 
@@ -700,13 +713,14 @@ int signal_protocol_session_load_session(signal_protocol_store_context *context,
 {
     int result = 0;
     signal_buffer *buffer = 0;
+    signal_buffer *user_buffer = 0;
     session_record *result_record = 0;
 
     assert(context);
     assert(context->session_store.load_session_func);
 
     result = context->session_store.load_session_func(
-            &buffer, address,
+            &buffer, &user_buffer, address,
             context->session_store.user_data);
     if(result < 0) {
         goto complete;
@@ -736,8 +750,14 @@ complete:
         signal_buffer_free(buffer);
     }
     if(result >= 0) {
+        if(user_buffer) {
+            session_record_set_user_record(result_record, user_buffer);
+        }
         *record = result_record;
     }
+    else {
+        signal_buffer_free(user_buffer);
+    }
     return result;
 }
 
@@ -755,6 +775,9 @@ int signal_protocol_session_store_session(signal_protocol_store_context *context
 {
     int result = 0;
     signal_buffer *buffer = 0;
+    signal_buffer *user_buffer = 0;
+    uint8_t *user_buffer_data = 0;
+    size_t user_buffer_len = 0;
 
     assert(context);
     assert(context->session_store.store_session_func);
@@ -765,9 +788,16 @@ int signal_protocol_session_store_session(signal_protocol_store_context *context
         goto complete;
     }
 
+    user_buffer = session_record_get_user_record(record);
+    if(user_buffer) {
+        user_buffer_data = signal_buffer_data(user_buffer);
+        user_buffer_len = signal_buffer_len(user_buffer);
+    }
+
     result = context->session_store.store_session_func(
             address,
             signal_buffer_data(buffer), signal_buffer_len(buffer),
+            user_buffer_data, user_buffer_len,
             context->session_store.user_data);
 
 complete:
@@ -1114,6 +1144,9 @@ int signal_protocol_sender_key_store_key(signal_protocol_store_context *context,
 {
     int result = 0;
     signal_buffer *buffer = 0;
+    signal_buffer *user_buffer = 0;
+    uint8_t *user_buffer_data = 0;
+    size_t user_buffer_len = 0;
 
     assert(context);
     assert(context->sender_key_store.store_sender_key);
@@ -1124,9 +1157,16 @@ int signal_protocol_sender_key_store_key(signal_protocol_store_context *context,
         goto complete;
     }
 
+    user_buffer = sender_key_record_get_user_record(record);
+    if(user_buffer) {
+        user_buffer_data = signal_buffer_data(user_buffer);
+        user_buffer_len = signal_buffer_len(user_buffer);
+    }
+
     result = context->sender_key_store.store_sender_key(
             sender_key_name,
             signal_buffer_data(buffer), signal_buffer_len(buffer),
+            user_buffer_data, user_buffer_len,
             context->sender_key_store.user_data);
 
 complete:
@@ -1141,13 +1181,14 @@ int signal_protocol_sender_key_load_key(signal_protocol_store_context *context,
 {
     int result = 0;
     signal_buffer *buffer = 0;
+    signal_buffer *user_buffer = 0;
     sender_key_record *result_record = 0;
 
     assert(context);
     assert(context->sender_key_store.load_sender_key);
 
     result = context->sender_key_store.load_sender_key(
-            &buffer, sender_key_name,
+            &buffer, &user_buffer, sender_key_name,
             context->sender_key_store.user_data);
     if(result < 0) {
         goto complete;
@@ -1177,7 +1218,13 @@ complete:
         signal_buffer_free(buffer);
     }
     if(result >= 0) {
+        if(user_buffer) {
+            sender_key_record_set_user_record(result_record, user_buffer);
+        }
         *record = result_record;
     }
+    else {
+        signal_buffer_free(user_buffer);
+    }
     return result;
 }
diff --git a/src/signal_protocol.h b/src/signal_protocol.h
index e2ff5d6..4e71355 100644
--- a/src/signal_protocol.h
+++ b/src/signal_protocol.h
@@ -102,6 +102,15 @@ signal_buffer *signal_buffer_create(const uint8_t *data, size_t len);
  */
 signal_buffer *signal_buffer_copy(const signal_buffer *buffer);
 
+/**
+ * Create a copy of an existing buffer.
+ *
+ * @param buffer the existing buffer to copy
+ * @param n the maximum number of bytes to copy
+ * @return pointer to the updated buffer, or 0 on failure
+ */
+signal_buffer *signal_buffer_n_copy(const signal_buffer *buffer, size_t n);
+
 /**
  * Append the provided data to an existing buffer.
  * Note: The underlying buffer is only expanded by an amount sufficient
@@ -124,13 +133,22 @@ signal_buffer *signal_buffer_append(signal_buffer *buffer, const uint8_t *data,
  */
 uint8_t *signal_buffer_data(signal_buffer *buffer);
 
+/**
+ * Gets the data pointer for the buffer.
+ * This can be used to read and write data stored in the buffer.
+ *
+ * @param buffer pointer to the buffer instance
+ * @return data pointer
+ */
+const uint8_t *signal_buffer_const_data(const signal_buffer *buffer);
+
 /**
  * Gets the length of the data stored within the buffer.
  *
  * @param buffer pointer to the buffer instance
  * @return data length
  */
-size_t signal_buffer_len(signal_buffer *buffer);
+size_t signal_buffer_len(const signal_buffer *buffer);
 
 /**
  * Compare two buffers.
@@ -400,10 +418,14 @@ typedef struct signal_protocol_session_store {
      * @param record pointer to a freshly allocated buffer containing the
      *     serialized session record. Unset if no record was found.
      *     The Signal Protocol library is responsible for freeing this buffer.
+     * @param user_record pointer to a freshly allocated buffer containing
+     *     application specific data stored alongside the serialized session
+     *     record. If no such data exists, then this pointer may be left unset.
+     *     The Signal Protocol library is responsible for freeing this buffer.
      * @param address the address of the remote client
      * @return 1 if the session was loaded, 0 if the session was not found, negative on failure
      */
-    int (*load_session_func)(signal_buffer **record, const signal_protocol_address *address, void *user_data);
+    int (*load_session_func)(signal_buffer **record, signal_buffer **user_record, const signal_protocol_address *address, void *user_data);
 
     /**
      * Returns all known devices with active sessions for a recipient
@@ -423,9 +445,13 @@ typedef struct signal_protocol_session_store {
      * @param record pointer to a buffer containing the serialized session
      *     record for the remote client
      * @param record_len length of the serialized session record
+     * @param user_record pointer to a buffer containing application specific
+     *     data to be stored alongside the serialized session record for the
+     *     remote client. If no such data exists, then this pointer will be null.
+     * @param user_record_len length of the application specific data
      * @return 0 on success, negative on failure
      */
-    int (*store_session_func)(const signal_protocol_address *address, uint8_t *record, size_t record_len, void *user_data);
+    int (*store_session_func)(const signal_protocol_address *address, uint8_t *record, size_t record_len, uint8_t *user_record, size_t user_record_len, void *user_data);
 
     /**
      * Determine whether there is a committed session record for a
@@ -640,9 +666,13 @@ typedef struct signal_protocol_sender_key_store {
      * @param sender_key_name the (groupId + senderId + deviceId) tuple
      * @param record pointer to a buffer containing the serialized record
      * @param record_len length of the serialized record
+     * @param user_record pointer to a buffer containing application specific
+     *     data to be stored alongside the serialized record. If no such
+     *     data exists, then this pointer will be null.
+     * @param user_record_len length of the application specific data
      * @return 0 on success, negative on failure
      */
-    int (*store_sender_key)(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, void *user_data);
+    int (*store_sender_key)(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, uint8_t *user_record, size_t user_record_len, void *user_data);
 
     /**
      * Returns a copy of the sender key record corresponding to the
@@ -651,10 +681,14 @@ typedef struct signal_protocol_sender_key_store {
      * @param record pointer to a newly allocated buffer containing the record,
      *     if found. Unset if no record was found.
      *     The Signal Protocol library is responsible for freeing this buffer.
+     * @param user_record pointer to a newly allocated buffer containing
+     *     application-specific data stored alongside the record. If no such
+     *     data exists, then this pointer may be left unset.
+     *     The Signal Protocol library is responsible for freeing this buffer.
      * @param sender_key_name the (groupId + senderId + deviceId) tuple
      * @return 1 if the record was loaded, 0 if the record was not found, negative on failure
      */
-    int (*load_sender_key)(signal_buffer **record, const signal_protocol_sender_key_name *sender_key_name, void *user_data);
+    int (*load_sender_key)(signal_buffer **record, signal_buffer **user_record, const signal_protocol_sender_key_name *sender_key_name, void *user_data);
 
     /**
      * Function called to perform cleanup when the data store context is being
diff --git a/src/vpool.h b/src/vpool.h
index 04707cb..9a54e42 100644
--- a/src/vpool.h
+++ b/src/vpool.h
@@ -21,18 +21,6 @@
 #define _VPOOL_H_
 
 #include <sys/types.h>
-#if !defined(_WINDOWS) && !defined(__sun__)
-#include <sys/cdefs.h>
-#else
-#ifdef __cplusplus
-#define __BEGIN_DECLS extern "C" {
-#define __END_DECLS }
-#else
-#define __BEGIN_DECLS
-#define __END_DECLS
-#endif /* __cplusplus */
-#endif /* _WINDOWS */
-
 #include <limits.h>
 
 struct vpool {
@@ -49,8 +37,6 @@ struct vpool {
 enum vpool_trunc {VPOOL_EXCLUDE, VPOOL_INCLUDE};
 #define VPOOL_TAIL	UINT_MAX
 
-__BEGIN_DECLS
-
 void	vpool_init(struct vpool *pool, size_t blksize, size_t limit);
 void	vpool_final(struct vpool *pool);
 
@@ -71,6 +57,4 @@ int	vpool_truncate(struct vpool *pool,
 
 void	vpool_export(struct vpool *pool, void **buf, size_t *size);
 
-__END_DECLS
-
 #endif /* !_VPOOL_H_ */
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index aff9523..f54ccb4 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -35,6 +35,7 @@ set(LIBS ${LIBS}
 	${CHECK_LDFLAGS}
 	${OPENSSL_LIBRARIES}
 	${CMAKE_THREAD_LIBS_INIT}
+	${CMAKE_DL_LIBS}
 	signal-protocol-c
 )
 
diff --git a/tests/test_common.c b/tests/test_common.c
index 13a3400..f15003c 100644
--- a/tests/test_common.c
+++ b/tests/test_common.c
@@ -197,7 +197,7 @@ typedef struct {
     test_session_store_session *sessions;
 } test_session_store_data;
 
-int test_session_store_load_session(signal_buffer **record, const signal_protocol_address *address, void *user_data)
+int test_session_store_load_session(signal_buffer **record, signal_buffer **user_record, const signal_protocol_address *address, void *user_data)
 {
     test_session_store_data *data = user_data;
 
@@ -242,7 +242,7 @@ int test_session_store_get_sub_device_sessions(signal_int_list **sessions, const
     return 0;
 }
 
-int test_session_store_store_session(const signal_protocol_address *address, uint8_t *record, size_t record_len, void *user_data)
+int test_session_store_store_session(const signal_protocol_address *address, uint8_t *record, size_t record_len, uint8_t *user_record_data, size_t user_record_len, void *user_data)
 {
     test_session_store_data *data = user_data;
 
@@ -753,7 +753,7 @@ typedef struct {
     test_sender_key_store_record *records;
 } test_sender_key_store_data;
 
-int test_sender_key_store_store_sender_key(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, void *user_data)
+int test_sender_key_store_store_sender_key(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, uint8_t *user_record_data, size_t user_record_len, void *user_data)
 {
     test_sender_key_store_data *data = user_data;
 
@@ -793,14 +793,14 @@ int test_sender_key_store_store_sender_key(const signal_protocol_sender_key_name
     return 0;
 }
 
-int test_sender_key_store_load_sender_key(signal_buffer **record, const signal_protocol_sender_key_name *sender_key_name, void *user_data)
+int test_sender_key_store_load_sender_key(signal_buffer **record, signal_buffer **user_record, const signal_protocol_sender_key_name *sender_key_name, void *user_data)
 {
     test_sender_key_store_data *data = user_data;
 
     test_sender_key_store_record *s;
 
     test_sender_key_store_record l;
-    memset(&l, 0, sizeof(test_session_store_session));
+    memset(&l, 0, sizeof(test_sender_key_store_record));
     l.key.group_id = jenkins_hash(sender_key_name->group_id, sender_key_name->group_id_len);
     l.key.recipient_id = jenkins_hash(sender_key_name->sender.name, sender_key_name->sender.name_len);
     l.key.device_id = sender_key_name->sender.device_id;
diff --git a/tests/test_common.h b/tests/test_common.h
index df95613..66ddc6a 100644
--- a/tests/test_common.h
+++ b/tests/test_common.h
@@ -45,9 +45,9 @@ void setup_test_crypto_provider(signal_context *context);
 void setup_test_store_context(signal_protocol_store_context **context, signal_context *global_context);
 
 /* Test session store */
-int test_session_store_load_session(signal_buffer **record, const signal_protocol_address *address, void *user_data);
+int test_session_store_load_session(signal_buffer **record, signal_buffer **user_record, const signal_protocol_address *address, void *user_data);
 int test_session_store_get_sub_device_sessions(signal_int_list **sessions, const char *name, size_t name_len, void *user_data);
-int test_session_store_store_session(const signal_protocol_address *address, uint8_t *record, size_t record_len, void *user_data);
+int test_session_store_store_session(const signal_protocol_address *address, uint8_t *record, size_t record_len, uint8_t *user_record_data, size_t user_record_len, void *user_data);
 int test_session_store_contains_session(const signal_protocol_address *address, void *user_data);
 int test_session_store_delete_session(const signal_protocol_address *address, void *user_data);
 int test_session_store_delete_all_sessions(const char *name, size_t name_len, void *user_data);
@@ -79,8 +79,8 @@ void test_identity_key_store_destroy(void *user_data);
 void setup_test_identity_key_store(signal_protocol_store_context *context, signal_context *global_context);
 
 /* Test sender key store */
-int test_sender_key_store_store_sender_key(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, void *user_data);
-int test_sender_key_store_load_sender_key(signal_buffer **record, const signal_protocol_sender_key_name *sender_key_name, void *user_data);
+int test_sender_key_store_store_sender_key(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, uint8_t *user_record_data, size_t user_record_len, void *user_data);
+int test_sender_key_store_load_sender_key(signal_buffer **record, signal_buffer **user_record, const signal_protocol_sender_key_name *sender_key_name, void *user_data);
 void test_sender_key_store_destroy(void *user_data);
 void setup_test_sender_key_store(signal_protocol_store_context *context, signal_context *global_context);
 
diff --git a/tests/test_common_openssl.c b/tests/test_common_openssl.c
index da3fb87..abcb208 100644
--- a/tests/test_common_openssl.c
+++ b/tests/test_common_openssl.c
@@ -1,5 +1,6 @@
 #include "test_common.h"
 
+#include <openssl/opensslv.h>
 #include <openssl/evp.h>
 #include <openssl/hmac.h>
 #include <openssl/rand.h>
@@ -17,11 +18,19 @@ int test_random_generator(uint8_t *data, size_t len, void *user_data)
 
 int test_hmac_sha256_init(void **hmac_context, const uint8_t *key, size_t key_len, void *user_data)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+    HMAC_CTX *ctx = HMAC_CTX_new();
+    if(!ctx) {
+        return SG_ERR_NOMEM;
+    }
+#else
     HMAC_CTX *ctx = malloc(sizeof(HMAC_CTX));
     if(!ctx) {
         return SG_ERR_NOMEM;
     }
     HMAC_CTX_init(ctx);
+#endif
+
     *hmac_context = ctx;
 
     if(HMAC_Init_ex(ctx, key, key_len, EVP_sha256(), 0) != 1) {
@@ -65,8 +74,12 @@ void test_hmac_sha256_cleanup(void *hmac_context, void *user_data)
 {
     if(hmac_context) {
         HMAC_CTX *ctx = hmac_context;
+#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+        HMAC_CTX_free(ctx);
+#else
         HMAC_CTX_cleanup(ctx);
         free(ctx);
+#endif
     }
 }
 
@@ -188,6 +201,7 @@ int test_encrypt(signal_buffer **output,
         void *user_data)
 {
     int result = 0;
+    EVP_CIPHER_CTX *ctx = 0;
     uint8_t *out_buf = 0;
 
     const EVP_CIPHER *evp_cipher = aes_cipher(cipher, key_len);
@@ -206,10 +220,22 @@ int test_encrypt(signal_buffer **output,
         return SG_ERR_UNKNOWN;
     }
 
-    EVP_CIPHER_CTX ctx;
-    EVP_CIPHER_CTX_init(&ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+    ctx = EVP_CIPHER_CTX_new();
+    if(!ctx) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+#else
+    ctx = malloc(sizeof(EVP_CIPHER_CTX));
+    if(!ctx) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+    EVP_CIPHER_CTX_init(ctx);
+#endif
 
-    result = EVP_EncryptInit_ex(&ctx, evp_cipher, 0, key, iv);
+    result = EVP_EncryptInit_ex(ctx, evp_cipher, 0, key, iv);
     if(!result) {
         fprintf(stderr, "cannot initialize cipher\n");
         result = SG_ERR_UNKNOWN;
@@ -217,7 +243,7 @@ int test_encrypt(signal_buffer **output,
     }
 
     if(cipher == SG_CIPHER_AES_CTR_NOPADDING) {
-        result = EVP_CIPHER_CTX_set_padding(&ctx, 0);
+        result = EVP_CIPHER_CTX_set_padding(ctx, 0);
         if(!result) {
             fprintf(stderr, "cannot set padding\n");
             result = SG_ERR_UNKNOWN;
@@ -233,7 +259,7 @@ int test_encrypt(signal_buffer **output,
     }
 
     int out_len = 0;
-    result = EVP_EncryptUpdate(&ctx,
+    result = EVP_EncryptUpdate(ctx,
         out_buf, &out_len, plaintext, plaintext_len);
     if(!result) {
         fprintf(stderr, "cannot encrypt plaintext\n");
@@ -242,7 +268,7 @@ int test_encrypt(signal_buffer **output,
     }
 
     int final_len = 0;
-    result = EVP_EncryptFinal_ex(&ctx, out_buf + out_len, &final_len);
+    result = EVP_EncryptFinal_ex(ctx, out_buf + out_len, &final_len);
     if(!result) {
         fprintf(stderr, "cannot finish encrypting plaintext\n");
         result = SG_ERR_UNKNOWN;
@@ -252,7 +278,14 @@ int test_encrypt(signal_buffer **output,
     *output = signal_buffer_create(out_buf, out_len + final_len);
 
 complete:
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    if(ctx) {
+#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+        EVP_CIPHER_CTX_free(ctx);
+#else
+        EVP_CIPHER_CTX_cleanup(ctx);
+        free(ctx);
+#endif
+    }
     if(out_buf) {
         free(out_buf);
     }
@@ -267,6 +300,7 @@ int test_decrypt(signal_buffer **output,
         void *user_data)
 {
     int result = 0;
+    EVP_CIPHER_CTX *ctx = 0;
     uint8_t *out_buf = 0;
 
     const EVP_CIPHER *evp_cipher = aes_cipher(cipher, key_len);
@@ -285,10 +319,22 @@ int test_decrypt(signal_buffer **output,
         return SG_ERR_UNKNOWN;
     }
 
-    EVP_CIPHER_CTX ctx;
-    EVP_CIPHER_CTX_init(&ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+    ctx = EVP_CIPHER_CTX_new();
+    if(!ctx) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+#else
+    ctx = malloc(sizeof(EVP_CIPHER_CTX));
+    if(!ctx) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+    EVP_CIPHER_CTX_init(ctx);
+#endif
 
-    result = EVP_DecryptInit_ex(&ctx, evp_cipher, 0, key, iv);
+    result = EVP_DecryptInit_ex(ctx, evp_cipher, 0, key, iv);
     if(!result) {
         fprintf(stderr, "cannot initialize cipher\n");
         result = SG_ERR_UNKNOWN;
@@ -296,7 +342,7 @@ int test_decrypt(signal_buffer **output,
     }
 
     if(cipher == SG_CIPHER_AES_CTR_NOPADDING) {
-        result = EVP_CIPHER_CTX_set_padding(&ctx, 0);
+        result = EVP_CIPHER_CTX_set_padding(ctx, 0);
         if(!result) {
             fprintf(stderr, "cannot set padding\n");
             result = SG_ERR_UNKNOWN;
@@ -312,7 +358,7 @@ int test_decrypt(signal_buffer **output,
     }
 
     int out_len = 0;
-    result = EVP_DecryptUpdate(&ctx,
+    result = EVP_DecryptUpdate(ctx,
         out_buf, &out_len, ciphertext, ciphertext_len);
     if(!result) {
         fprintf(stderr, "cannot decrypt ciphertext\n");
@@ -321,7 +367,7 @@ int test_decrypt(signal_buffer **output,
     }
 
     int final_len = 0;
-    result = EVP_DecryptFinal_ex(&ctx, out_buf + out_len, &final_len);
+    result = EVP_DecryptFinal_ex(ctx, out_buf + out_len, &final_len);
     if(!result) {
         fprintf(stderr, "cannot finish decrypting ciphertext\n");
         result = SG_ERR_UNKNOWN;
@@ -331,7 +377,14 @@ int test_decrypt(signal_buffer **output,
     *output = signal_buffer_create(out_buf, out_len + final_len);
 
 complete:
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    if(ctx) {
+#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+        EVP_CIPHER_CTX_free(ctx);
+#else
+        EVP_CIPHER_CTX_cleanup(ctx);
+        free(ctx);
+#endif
+    }
     if(out_buf) {
         free(out_buf);
     }
diff --git a/tests/test_curve25519.c b/tests/test_curve25519.c
index 9d10675..4c4bf0a 100644
--- a/tests/test_curve25519.c
+++ b/tests/test_curve25519.c
@@ -25,6 +25,12 @@ void test_teardown()
     signal_context_destroy(global_context);
 }
 
+START_TEST(test_internal)
+{
+    ck_assert_int_eq(curve_internal_fast_tests(1), 0);
+}
+END_TEST
+
 START_TEST(test_curve25519_agreement)
 {
     int result;
@@ -433,10 +439,11 @@ START_TEST(test_unique_signature_vector)
             0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
             0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x2e};
     uint8_t vrf[] = {
-            0x75, 0xad, 0x49, 0xbc, 0x95, 0x5f, 0x38, 0xdc,
-            0xf6, 0x5f, 0xb6, 0x72, 0x08, 0x6b, 0xd5, 0x09,
-            0xcb, 0x4b, 0x4c, 0x41, 0x04, 0x7d, 0xb1, 0x7e,
-            0xfd, 0xaf, 0xee, 0xbc, 0x33, 0x03, 0x71, 0xe6};
+            0x45, 0xDC, 0x7B, 0x81, 0x6B, 0x01, 0xB3, 0x6C, 
+            0xFA, 0x16, 0x45, 0xDC, 0xAE, 0x8A, 0xC9, 0xBC, 
+            0x8E, 0x52, 0x3C, 0xD8, 0x6D, 0x00, 0x7D, 0x19, 
+            0x95, 0x3F, 0x03, 0xE7, 0xD5, 0x45, 0x54, 0xA0
+            };
 
     int result;
     ec_public_key *public_key = 0;
@@ -475,6 +482,7 @@ Suite *curve25519_suite(void)
     Suite *suite = suite_create("curve25519");
     TCase *tcase = tcase_create("case");
     tcase_add_checked_fixture(tcase, test_setup, test_teardown);
+    tcase_add_test(tcase, test_internal);
     tcase_add_test(tcase, test_curve25519_agreement);
     tcase_add_test(tcase, test_curve25519_generate_public);
     tcase_add_test(tcase, test_curve25519_random_agreements);
diff --git a/tests/test_fingerprint.c b/tests/test_fingerprint.c
index 445dcf3..d92bc17 100644
--- a/tests/test_fingerprint.c
+++ b/tests/test_fingerprint.c
@@ -7,6 +7,77 @@
 
 signal_context *global_context;
 
+static uint8_t ALICE_IDENTITY[] = {
+        0x05, 0x06, 0x86, 0x3b, 0xc6, 0x6d, 0x02, 0xb4,
+        0x0d, 0x27, 0xb8, 0xd4, 0x9c, 0xa7, 0xc0, 0x9e,
+        0x92, 0x39, 0x23, 0x6f, 0x9d, 0x7d, 0x25, 0xd6,
+        0xfc, 0xca, 0x5c, 0xe1, 0x3c, 0x70, 0x64, 0xd8,
+        0x68};
+
+static uint8_t BOB_IDENTITY[] = {
+        0x05, 0xf7, 0x81, 0xb6, 0xfb, 0x32, 0xfe, 0xd9,
+        0xba, 0x1c, 0xf2, 0xde, 0x97, 0x8d, 0x4d, 0x5d,
+        0xa2, 0x8d, 0xc3, 0x40, 0x46, 0xae, 0x81, 0x44,
+        0x02, 0xb5, 0xc0, 0xdb, 0xd9, 0x6f, 0xda, 0x90,
+        0x7b};
+
+static const char *DISPLAYABLE_FINGERPRINT =
+        "300354477692869396892869876765458257569162576843440918079131";
+
+static uint8_t ALICE_SCANNABLE_FINGERPRINT_V0[] = {
+        0x08, 0x00, 0x12, 0x31, 0x0a, 0x21, 0x05, 0x06,
+        0x86, 0x3b, 0xc6, 0x6d, 0x02, 0xb4, 0x0d, 0x27,
+        0xb8, 0xd4, 0x9c, 0xa7, 0xc0, 0x9e, 0x92, 0x39,
+        0x23, 0x6f, 0x9d, 0x7d, 0x25, 0xd6, 0xfc, 0xca,
+        0x5c, 0xe1, 0x3c, 0x70, 0x64, 0xd8, 0x68, 0x12,
+        0x0c, 0x2b, 0x31, 0x34, 0x31, 0x35, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x1a, 0x31, 0x0a,
+        0x21, 0x05, 0xf7, 0x81, 0xb6, 0xfb, 0x32, 0xfe,
+        0xd9, 0xba, 0x1c, 0xf2, 0xde, 0x97, 0x8d, 0x4d,
+        0x5d, 0xa2, 0x8d, 0xc3, 0x40, 0x46, 0xae, 0x81,
+        0x44, 0x02, 0xb5, 0xc0, 0xdb, 0xd9, 0x6f, 0xda,
+        0x90, 0x7b, 0x12, 0x0c, 0x2b, 0x31, 0x34, 0x31,
+        0x35, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33};
+
+static uint8_t BOB_SCANNABLE_FINGERPRINT_V0[] = {
+        0x08, 0x00, 0x12, 0x31, 0x0a, 0x21, 0x05, 0xf7,
+        0x81, 0xb6, 0xfb, 0x32, 0xfe, 0xd9, 0xba, 0x1c,
+        0xf2, 0xde, 0x97, 0x8d, 0x4d, 0x5d, 0xa2, 0x8d,
+        0xc3, 0x40, 0x46, 0xae, 0x81, 0x44, 0x02, 0xb5,
+        0xc0, 0xdb, 0xd9, 0x6f, 0xda, 0x90, 0x7b, 0x12,
+        0x0c, 0x2b, 0x31, 0x34, 0x31, 0x35, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x1a, 0x31, 0x0a,
+        0x21, 0x05, 0x06, 0x86, 0x3b, 0xc6, 0x6d, 0x02,
+        0xb4, 0x0d, 0x27, 0xb8, 0xd4, 0x9c, 0xa7, 0xc0,
+        0x9e, 0x92, 0x39, 0x23, 0x6f, 0x9d, 0x7d, 0x25,
+        0xd6, 0xfc, 0xca, 0x5c, 0xe1, 0x3c, 0x70, 0x64,
+        0xd8, 0x68, 0x12, 0x0c, 0x2b, 0x31, 0x34, 0x31,
+        0x35, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32};
+
+static uint8_t ALICE_SCANNABLE_FINGERPRINT_V1[] = {
+        0x08, 0x01, 0x12, 0x22, 0x0a, 0x20, 0x1e, 0x30,
+        0x1a, 0x03, 0x53, 0xdc, 0xe3, 0xdb, 0xe7, 0x68,
+        0x4c, 0xb8, 0x33, 0x6e, 0x85, 0x13, 0x6c, 0xdc,
+        0x0e, 0xe9, 0x62, 0x19, 0x49, 0x4a, 0xda, 0x30,
+        0x5d, 0x62, 0xa7, 0xbd, 0x61, 0xdf, 0x1a, 0x22,
+        0x0a, 0x20, 0xd6, 0x2c, 0xbf, 0x73, 0xa1, 0x15,
+        0x92, 0x01, 0x5b, 0x6b, 0x9f, 0x16, 0x82, 0xac,
+        0x30, 0x6f, 0xea, 0x3a, 0xaf, 0x38, 0x85, 0xb8,
+        0x4d, 0x12, 0xbc, 0xa6, 0x31, 0xe9, 0xd4, 0xfb,
+        0x3a, 0x4d};
+
+static uint8_t BOB_SCANNABLE_FINGERPRINT_V1[] = {
+        0x08, 0x01, 0x12, 0x22, 0x0a, 0x20, 0xd6, 0x2c,
+        0xbf, 0x73, 0xa1, 0x15, 0x92, 0x01, 0x5b, 0x6b,
+        0x9f, 0x16, 0x82, 0xac, 0x30, 0x6f, 0xea, 0x3a,
+        0xaf, 0x38, 0x85, 0xb8, 0x4d, 0x12, 0xbc, 0xa6,
+        0x31, 0xe9, 0xd4, 0xfb, 0x3a, 0x4d, 0x1a, 0x22,
+        0x0a, 0x20, 0x1e, 0x30, 0x1a, 0x03, 0x53, 0xdc,
+        0xe3, 0xdb, 0xe7, 0x68, 0x4c, 0xb8, 0x33, 0x6e,
+        0x85, 0x13, 0x6c, 0xdc, 0x0e, 0xe9, 0x62, 0x19,
+        0x49, 0x4a, 0xda, 0x30, 0x5d, 0x62, 0xa7, 0xbd,
+        0x61, 0xdf};
+
 void test_setup()
 {
     int result;
@@ -21,24 +92,32 @@ void test_teardown()
     signal_context_destroy(global_context);
 }
 
-START_TEST(test_scannable_fingerprint_serialize)
+static void test_scannable_fingerprint_serialize_impl(int version)
 {
     int result = 0;
     ec_public_key *alice_identity_key = create_test_ec_public_key(global_context);
     ec_public_key *bob_identity_key = create_test_ec_public_key(global_context);
+    signal_buffer *alice_identity_buffer = 0;
+    signal_buffer *bob_identity_buffer = 0;
     scannable_fingerprint *alice_scannable = 0;
     scannable_fingerprint *bob_scannable = 0;
     signal_buffer *buffer = 0;
     scannable_fingerprint *bob_deserialized = 0;
 
-    result = scannable_fingerprint_create(&alice_scannable, 1,
-            "+14152222222", alice_identity_key,
-            "+14153333333", bob_identity_key);
+    result = ec_public_key_serialize(&alice_identity_buffer, alice_identity_key);
     ck_assert_int_eq(result, 0);
 
-    result = scannable_fingerprint_create(&bob_scannable, 1,
-            "+14153333333", bob_identity_key,
-            "+14152222222", alice_identity_key);
+    result = ec_public_key_serialize(&bob_identity_buffer, bob_identity_key);
+    ck_assert_int_eq(result, 0);
+
+    result = scannable_fingerprint_create(&alice_scannable, version,
+            "+14152222222", alice_identity_buffer,
+            "+14153333333", bob_identity_buffer);
+    ck_assert_int_eq(result, 0);
+
+    result = scannable_fingerprint_create(&bob_scannable, version,
+            "+14153333333", bob_identity_buffer,
+            "+14152222222", alice_identity_buffer);
     ck_assert_int_eq(result, 0);
 
     ck_assert_int_eq(scannable_fingerprint_compare(alice_scannable, bob_scannable), 1);
@@ -60,11 +139,24 @@ START_TEST(test_scannable_fingerprint_serialize)
     SIGNAL_UNREF(alice_scannable);
     SIGNAL_UNREF(bob_scannable);
     SIGNAL_UNREF(bob_deserialized);
+    signal_buffer_free(alice_identity_buffer);
+    signal_buffer_free(bob_identity_buffer);
     signal_buffer_free(buffer);
 }
+
+START_TEST(test_scannable_fingerprint_serialize_v0)
+{
+    test_scannable_fingerprint_serialize_impl(0);
+}
+END_TEST
+
+START_TEST(test_scannable_fingerprint_serialize_v1)
+{
+    test_scannable_fingerprint_serialize_impl(1);
+}
 END_TEST
 
-START_TEST(test_vectors)
+static void test_vectors_impl(int version)
 {
     int result = 0;
     ec_public_key *alice_identity_key = 0;
@@ -75,60 +167,13 @@ START_TEST(test_vectors)
     signal_buffer *alice_buffer = 0;
     signal_buffer *bob_buffer = 0;
 
-    uint8_t aliceIdentity[] = {
-            0x05, 0x06, 0x86, 0x3b, 0xc6, 0x6d, 0x02, 0xb4,
-            0x0d, 0x27, 0xb8, 0xd4, 0x9c, 0xa7, 0xc0, 0x9e,
-            0x92, 0x39, 0x23, 0x6f, 0x9d, 0x7d, 0x25, 0xd6,
-            0xfc, 0xca, 0x5c, 0xe1, 0x3c, 0x70, 0x64, 0xd8,
-            0x68};
-
-    uint8_t bobIdentity[] = {
-            0x05, 0xf7, 0x81, 0xb6, 0xfb, 0x32, 0xfe, 0xd9,
-            0xba, 0x1c, 0xf2, 0xde, 0x97, 0x8d, 0x4d, 0x5d,
-            0xa2, 0x8d, 0xc3, 0x40, 0x46, 0xae, 0x81, 0x44,
-            0x02, 0xb5, 0xc0, 0xdb, 0xd9, 0x6f, 0xda, 0x90,
-            0x7b};
-
-    const char *displayableFingerprint =
-            "300354477692869396892869876765458257569162576843440918079131";
-
-    uint8_t aliceScannableFingerprint[] = {
-            0x08, 0x00, 0x12, 0x31, 0x0a, 0x21, 0x05, 0x06,
-            0x86, 0x3b, 0xc6, 0x6d, 0x02, 0xb4, 0x0d, 0x27,
-            0xb8, 0xd4, 0x9c, 0xa7, 0xc0, 0x9e, 0x92, 0x39,
-            0x23, 0x6f, 0x9d, 0x7d, 0x25, 0xd6, 0xfc, 0xca,
-            0x5c, 0xe1, 0x3c, 0x70, 0x64, 0xd8, 0x68, 0x12,
-            0x0c, 0x2b, 0x31, 0x34, 0x31, 0x35, 0x32, 0x32,
-            0x32, 0x32, 0x32, 0x32, 0x32, 0x1a, 0x31, 0x0a,
-            0x21, 0x05, 0xf7, 0x81, 0xb6, 0xfb, 0x32, 0xfe,
-            0xd9, 0xba, 0x1c, 0xf2, 0xde, 0x97, 0x8d, 0x4d,
-            0x5d, 0xa2, 0x8d, 0xc3, 0x40, 0x46, 0xae, 0x81,
-            0x44, 0x02, 0xb5, 0xc0, 0xdb, 0xd9, 0x6f, 0xda,
-            0x90, 0x7b, 0x12, 0x0c, 0x2b, 0x31, 0x34, 0x31,
-            0x35, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33};
-
-    uint8_t bobScannableFingerprint[] = {
-            0x08, 0x00, 0x12, 0x31, 0x0a, 0x21, 0x05, 0xf7,
-            0x81, 0xb6, 0xfb, 0x32, 0xfe, 0xd9, 0xba, 0x1c,
-            0xf2, 0xde, 0x97, 0x8d, 0x4d, 0x5d, 0xa2, 0x8d,
-            0xc3, 0x40, 0x46, 0xae, 0x81, 0x44, 0x02, 0xb5,
-            0xc0, 0xdb, 0xd9, 0x6f, 0xda, 0x90, 0x7b, 0x12,
-            0x0c, 0x2b, 0x31, 0x34, 0x31, 0x35, 0x33, 0x33,
-            0x33, 0x33, 0x33, 0x33, 0x33, 0x1a, 0x31, 0x0a,
-            0x21, 0x05, 0x06, 0x86, 0x3b, 0xc6, 0x6d, 0x02,
-            0xb4, 0x0d, 0x27, 0xb8, 0xd4, 0x9c, 0xa7, 0xc0,
-            0x9e, 0x92, 0x39, 0x23, 0x6f, 0x9d, 0x7d, 0x25,
-            0xd6, 0xfc, 0xca, 0x5c, 0xe1, 0x3c, 0x70, 0x64,
-            0xd8, 0x68, 0x12, 0x0c, 0x2b, 0x31, 0x34, 0x31,
-            0x35, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32};
-
-    result = curve_decode_point(&alice_identity_key, aliceIdentity, sizeof(aliceIdentity), global_context);
-    ck_assert_int_eq(result, 0);
-
-    result = curve_decode_point(&bob_identity_key, bobIdentity, sizeof(bobIdentity), global_context);
-    ck_assert_int_eq(result, 0);
-
-    result = fingerprint_generator_create(&generator, 5200, global_context);
+    result = curve_decode_point(&alice_identity_key, ALICE_IDENTITY, sizeof(ALICE_IDENTITY), global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = curve_decode_point(&bob_identity_key, BOB_IDENTITY, sizeof(BOB_IDENTITY), global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create(&generator, 5200, version, global_context);
     ck_assert_int_eq(result, 0);
 
     result = fingerprint_generator_create_for(generator,
@@ -146,26 +191,39 @@ START_TEST(test_vectors)
     displayable_fingerprint *alice_displayable = fingerprint_get_displayable(alice_fingerprint);
     ck_assert_str_eq(
             displayable_fingerprint_text(alice_displayable),
-            displayableFingerprint);
+            DISPLAYABLE_FINGERPRINT);
 
     displayable_fingerprint *bob_displayable = fingerprint_get_displayable(bob_fingerprint);
     ck_assert_str_eq(
             displayable_fingerprint_text(bob_displayable),
-            displayableFingerprint);
+            DISPLAYABLE_FINGERPRINT);
 
     scannable_fingerprint *alice_scannable = fingerprint_get_scannable(alice_fingerprint);
     scannable_fingerprint_serialize(&alice_buffer, alice_scannable);
     ck_assert_int_eq(result, 0);
 
-    ck_assert_int_eq(signal_buffer_len(alice_buffer), sizeof(aliceScannableFingerprint));
-    ck_assert_int_eq(memcmp(signal_buffer_data(alice_buffer), aliceScannableFingerprint, sizeof(aliceScannableFingerprint)), 0);
-
     scannable_fingerprint *bob_scannable = fingerprint_get_scannable(bob_fingerprint);
     scannable_fingerprint_serialize(&bob_buffer, bob_scannable);
     ck_assert_int_eq(result, 0);
 
-    ck_assert_int_eq(signal_buffer_len(bob_buffer), sizeof(bobScannableFingerprint));
-    ck_assert_int_eq(memcmp(signal_buffer_data(bob_buffer), bobScannableFingerprint, sizeof(bobScannableFingerprint)), 0);
+    if(version == 0) {
+        ck_assert_int_eq(signal_buffer_len(alice_buffer), sizeof(ALICE_SCANNABLE_FINGERPRINT_V0));
+        ck_assert_int_eq(memcmp(signal_buffer_data(alice_buffer),
+                ALICE_SCANNABLE_FINGERPRINT_V0, sizeof(ALICE_SCANNABLE_FINGERPRINT_V0)), 0);
+
+        ck_assert_int_eq(signal_buffer_len(bob_buffer), sizeof(BOB_SCANNABLE_FINGERPRINT_V0));
+        ck_assert_int_eq(memcmp(signal_buffer_data(bob_buffer),
+                BOB_SCANNABLE_FINGERPRINT_V0, sizeof(BOB_SCANNABLE_FINGERPRINT_V0)), 0);
+    }
+    else if(version == 1) {
+        ck_assert_int_eq(signal_buffer_len(alice_buffer), sizeof(ALICE_SCANNABLE_FINGERPRINT_V1));
+        ck_assert_int_eq(memcmp(signal_buffer_data(alice_buffer),
+                ALICE_SCANNABLE_FINGERPRINT_V1, sizeof(ALICE_SCANNABLE_FINGERPRINT_V1)), 0);
+        
+        ck_assert_int_eq(signal_buffer_len(bob_buffer), sizeof(BOB_SCANNABLE_FINGERPRINT_V1));
+        ck_assert_int_eq(memcmp(signal_buffer_data(bob_buffer),
+                BOB_SCANNABLE_FINGERPRINT_V1, sizeof(BOB_SCANNABLE_FINGERPRINT_V1)), 0);
+    }
 
     /* Cleanup */
     signal_buffer_free(alice_buffer);
@@ -176,9 +234,20 @@ START_TEST(test_vectors)
     SIGNAL_UNREF(alice_fingerprint);
     SIGNAL_UNREF(bob_fingerprint);
 }
+
+START_TEST(test_vectors_v0)
+{
+    test_vectors_impl(0);
+}
+END_TEST
+
+START_TEST(test_vectors_v1)
+{
+    test_vectors_impl(1);
+}
 END_TEST
 
-START_TEST(test_matching_fingerprints)
+static void test_matching_fingerprints_impl(int version)
 {
     int result = 0;
     ec_public_key *alice_identity_key = create_test_ec_public_key(global_context);
@@ -187,7 +256,7 @@ START_TEST(test_matching_fingerprints)
     fingerprint *alice_fingerprint = 0;
     fingerprint *bob_fingerprint = 0;
 
-    result = fingerprint_generator_create(&generator, 1024, global_context);
+    result = fingerprint_generator_create(&generator, 1024, version, global_context);
     ck_assert_int_eq(result, 0);
 
     result = fingerprint_generator_create_for(generator,
@@ -224,9 +293,104 @@ START_TEST(test_matching_fingerprints)
     SIGNAL_UNREF(alice_fingerprint);
     SIGNAL_UNREF(bob_fingerprint);
 }
+
+START_TEST(test_matching_fingerprints_v0)
+{
+    test_matching_fingerprints_impl(0);
+}
+END_TEST
+
+START_TEST(test_matching_fingerprints_v1)
+{
+    test_matching_fingerprints_impl(1);
+}
+END_TEST
+
+START_TEST(test_matching_list_fingerprints)
+{
+    int result = 0;
+    ec_public_key *alice_identity_key1 = create_test_ec_public_key(global_context);
+    ec_public_key *alice_identity_key2 = create_test_ec_public_key(global_context);
+    ec_public_key *alice_identity_key3 = create_test_ec_public_key(global_context);
+    ec_public_key *alice_identity_key4 = create_test_ec_public_key(global_context);
+    ec_public_key *bob_identity_key1 = create_test_ec_public_key(global_context);
+    ec_public_key *bob_identity_key2 = create_test_ec_public_key(global_context);
+    ec_public_key *bob_identity_key3 = create_test_ec_public_key(global_context);
+    ec_public_key *bob_identity_key4 = create_test_ec_public_key(global_context);
+    fingerprint_generator *generator = 0;
+    fingerprint *alice_fingerprint = 0;
+    fingerprint *bob_fingerprint = 0;
+
+    ec_public_key_list *alice_key_list = ec_public_key_list_alloc();
+    ck_assert_ptr_ne(alice_key_list, 0);
+    result = ec_public_key_list_push_back(alice_key_list, alice_identity_key1);
+    ck_assert_int_eq(result, 0);
+    result = ec_public_key_list_push_back(alice_key_list, alice_identity_key2);
+    ck_assert_int_eq(result, 0);
+    result = ec_public_key_list_push_back(alice_key_list, alice_identity_key3);
+    ck_assert_int_eq(result, 0);
+    result = ec_public_key_list_push_back(alice_key_list, alice_identity_key4);
+    ck_assert_int_eq(result, 0);
+
+    ec_public_key_list *bob_key_list = ec_public_key_list_alloc();
+    ck_assert_ptr_ne(bob_key_list, 0);
+    result = ec_public_key_list_push_back(bob_key_list, bob_identity_key1);
+    ck_assert_int_eq(result, 0);
+    result = ec_public_key_list_push_back(bob_key_list, bob_identity_key2);
+    ck_assert_int_eq(result, 0);
+    result = ec_public_key_list_push_back(bob_key_list, bob_identity_key3);
+    ck_assert_int_eq(result, 0);
+    result = ec_public_key_list_push_back(bob_key_list, bob_identity_key4);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create(&generator, 1024, 1, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create_for_list(generator,
+            "+14152222222", alice_key_list,
+            "+14153333333", bob_key_list,
+            &alice_fingerprint);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create_for_list(generator,
+            "+14153333333", bob_key_list,
+            "+14152222222", alice_key_list,
+            &bob_fingerprint);
+    ck_assert_int_eq(result, 0);
+
+    displayable_fingerprint *alice_displayable = fingerprint_get_displayable(alice_fingerprint);
+    displayable_fingerprint *bob_displayable = fingerprint_get_displayable(bob_fingerprint);
+
+    ck_assert_str_eq(
+            displayable_fingerprint_text(alice_displayable),
+            displayable_fingerprint_text(bob_displayable));
+
+    scannable_fingerprint *alice_scannable = fingerprint_get_scannable(alice_fingerprint);
+    scannable_fingerprint *bob_scannable = fingerprint_get_scannable(bob_fingerprint);
+
+    ck_assert_int_eq(scannable_fingerprint_compare(alice_scannable, bob_scannable), 1);
+    ck_assert_int_eq(scannable_fingerprint_compare(bob_scannable, alice_scannable), 1);
+
+    ck_assert_int_eq(strlen(displayable_fingerprint_text(alice_displayable)), 60);
+
+    /* Cleanup */
+    fingerprint_generator_free(generator);
+    SIGNAL_UNREF(alice_identity_key1);
+    SIGNAL_UNREF(alice_identity_key2);
+    SIGNAL_UNREF(alice_identity_key3);
+    SIGNAL_UNREF(alice_identity_key4);
+    SIGNAL_UNREF(bob_identity_key1);
+    SIGNAL_UNREF(bob_identity_key2);
+    SIGNAL_UNREF(bob_identity_key3);
+    SIGNAL_UNREF(bob_identity_key4);
+    ec_public_key_list_free(alice_key_list);
+    ec_public_key_list_free(bob_key_list);
+    SIGNAL_UNREF(alice_fingerprint);
+    SIGNAL_UNREF(bob_fingerprint);
+}
 END_TEST
 
-START_TEST(test_mismatching_fingerprints)
+static void test_mismatching_fingerprints_impl(int version)
 {
     int result = 0;
     ec_public_key *alice_identity_key = create_test_ec_public_key(global_context);
@@ -236,7 +400,7 @@ START_TEST(test_mismatching_fingerprints)
     fingerprint *alice_fingerprint = 0;
     fingerprint *bob_fingerprint = 0;
 
-    result = fingerprint_generator_create(&generator, 1024, global_context);
+    result = fingerprint_generator_create(&generator, 1024, version, global_context);
     ck_assert_int_eq(result, 0);
 
     result = fingerprint_generator_create_for(generator,
@@ -272,6 +436,17 @@ START_TEST(test_mismatching_fingerprints)
     SIGNAL_UNREF(alice_fingerprint);
     SIGNAL_UNREF(bob_fingerprint);
 }
+
+START_TEST(test_mismatching_fingerprints_v0)
+{
+    test_mismatching_fingerprints_impl(0);
+}
+END_TEST
+
+START_TEST(test_mismatching_fingerprints_v1)
+{
+    test_mismatching_fingerprints_impl(1);
+}
 END_TEST
 
 START_TEST(test_mismatching_identifiers)
@@ -283,7 +458,7 @@ START_TEST(test_mismatching_identifiers)
     fingerprint *alice_fingerprint = 0;
     fingerprint *bob_fingerprint = 0;
 
-    result = fingerprint_generator_create(&generator, 1024, global_context);
+    result = fingerprint_generator_create(&generator, 1024, 0, global_context);
     ck_assert_int_eq(result, 0);
 
     result = fingerprint_generator_create_for(generator,
@@ -320,17 +495,76 @@ START_TEST(test_mismatching_identifiers)
 }
 END_TEST
 
+START_TEST(test_mismatching_versions)
+{
+    int result = 0;
+    ec_public_key *alice_identity_key = create_test_ec_public_key(global_context);
+    ec_public_key *bob_identity_key = create_test_ec_public_key(global_context);
+    ec_public_key *mitm_identity_key = create_test_ec_public_key(global_context);
+    fingerprint_generator *generator_v0 = 0;
+    fingerprint_generator *generator_v1 = 0;
+    fingerprint *alice_fingerprint = 0;
+    fingerprint *bob_fingerprint = 0;
+
+    result = fingerprint_generator_create(&generator_v0, 1024, 0, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create_for(generator_v0,
+            "+14152222222", alice_identity_key,
+            "+14153333333", mitm_identity_key,
+            &alice_fingerprint);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create(&generator_v1, 1024, 1, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fingerprint_generator_create_for(generator_v1,
+            "+14153333333", bob_identity_key,
+            "+14152222222", alice_identity_key,
+            &bob_fingerprint);
+    ck_assert_int_eq(result, 0);
+
+    displayable_fingerprint *alice_displayable = fingerprint_get_displayable(alice_fingerprint);
+    displayable_fingerprint *bob_displayable = fingerprint_get_displayable(bob_fingerprint);
+
+    ck_assert_str_ne(
+            displayable_fingerprint_text(alice_displayable),
+            displayable_fingerprint_text(bob_displayable));
+
+    scannable_fingerprint *alice_scannable = fingerprint_get_scannable(alice_fingerprint);
+    scannable_fingerprint *bob_scannable = fingerprint_get_scannable(bob_fingerprint);
+
+    ck_assert_int_eq(scannable_fingerprint_compare(alice_scannable, bob_scannable), SG_ERR_FP_VERSION_MISMATCH);
+    ck_assert_int_eq(scannable_fingerprint_compare(bob_scannable, alice_scannable), SG_ERR_FP_VERSION_MISMATCH);
+
+    /* Cleanup */
+    fingerprint_generator_free(generator_v0);
+    fingerprint_generator_free(generator_v1);
+    SIGNAL_UNREF(alice_identity_key);
+    SIGNAL_UNREF(bob_identity_key);
+    SIGNAL_UNREF(mitm_identity_key);
+    SIGNAL_UNREF(alice_fingerprint);
+    SIGNAL_UNREF(bob_fingerprint);
+}
+END_TEST
+
 Suite *fingerprint_suite(void)
 {
     Suite *suite = suite_create("fingerprint");
 
     TCase *tcase = tcase_create("case");
     tcase_add_checked_fixture(tcase, test_setup, test_teardown);
-    tcase_add_test(tcase, test_scannable_fingerprint_serialize);
-    tcase_add_test(tcase, test_vectors);
-    tcase_add_test(tcase, test_matching_fingerprints);
-    tcase_add_test(tcase, test_mismatching_fingerprints);
+    tcase_add_test(tcase, test_scannable_fingerprint_serialize_v0);
+    tcase_add_test(tcase, test_scannable_fingerprint_serialize_v1);
+    tcase_add_test(tcase, test_vectors_v0);
+    tcase_add_test(tcase, test_vectors_v1);
+    tcase_add_test(tcase, test_matching_fingerprints_v0);
+    tcase_add_test(tcase, test_matching_fingerprints_v1);
+    tcase_add_test(tcase, test_matching_list_fingerprints);
+    tcase_add_test(tcase, test_mismatching_fingerprints_v0);
+    tcase_add_test(tcase, test_mismatching_fingerprints_v1);
     tcase_add_test(tcase, test_mismatching_identifiers);
+    tcase_add_test(tcase, test_mismatching_versions);
     suite_add_tcase(suite, tcase);
 
     return suite;
diff --git a/tests/test_group_cipher.c b/tests/test_group_cipher.c
index 9221fba..9c75fa8 100644
--- a/tests/test_group_cipher.c
+++ b/tests/test_group_cipher.c
@@ -63,15 +63,11 @@ START_TEST(test_no_session)
     signal_protocol_store_context *bob_store = 0;
     setup_test_store_context(&bob_store, global_context);
 
-    /* Create the session builders */
+    /* Create the session builder */
     group_session_builder *alice_session_builder = 0;
     result = group_session_builder_create(&alice_session_builder, alice_store, global_context);
     ck_assert_int_eq(result, 0);
 
-    group_session_builder *bob_session_builder = 0;
-    result = group_session_builder_create(&bob_session_builder, bob_store, global_context);
-    ck_assert_int_eq(result, 0);
-
     /* Create the group ciphers */
     group_cipher *alice_group_cipher = 0;
     result = group_cipher_create(&alice_group_cipher, alice_store, &GROUP_SENDER, global_context);
@@ -116,7 +112,6 @@ START_TEST(test_no_session)
     SIGNAL_UNREF(sent_alice_distribution_message);
     group_cipher_free(bob_group_cipher);
     group_cipher_free(alice_group_cipher);
-    group_session_builder_free(bob_session_builder);
     group_session_builder_free(alice_session_builder);
     signal_protocol_store_context_destroy(bob_store);
     signal_protocol_store_context_destroy(alice_store);
@@ -341,7 +336,7 @@ START_TEST(test_late_join)
     signal_protocol_store_context *bob_store = 0;
     setup_test_store_context(&bob_store, global_context);
 
-    /* Create Alice's the session builder */
+    /* Create Alice's session builder */
     group_session_builder *alice_session_builder = 0;
     result = group_session_builder_create(&alice_session_builder, alice_store, global_context);
     ck_assert_int_eq(result, 0);
diff --git a/tests/test_key_helper.c b/tests/test_key_helper.c
index 5721457..0260025 100644
--- a/tests/test_key_helper.c
+++ b/tests/test_key_helper.c
@@ -200,43 +200,6 @@ START_TEST(test_generate_pre_keys)
 }
 END_TEST
 
-START_TEST(test_generate_last_resort_pre_key)
-{
-    uint8_t lastResortPreKey[] = {
-            0x08, 0xff, 0xff, 0xff, 0x07, 0x12, 0x21, 0x05,
-            0x8f, 0x40, 0xc5, 0xad, 0xb6, 0x8f, 0x25, 0x62,
-            0x4a, 0xe5, 0xb2, 0x14, 0xea, 0x76, 0x7a, 0x6e,
-            0xc9, 0x4d, 0x82, 0x9d, 0x3d, 0x7b, 0x5e, 0x1a,
-            0xd1, 0xba, 0x6f, 0x3e, 0x21, 0x38, 0x28, 0x5f,
-            0x1a, 0x20, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
-            0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
-            0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
-            0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
-            0x1e, 0x5f
-    };
-
-    int result = 0;
-    session_pre_key *pre_key = 0;
-    signal_buffer *buffer = 0;
-
-    result = signal_protocol_key_helper_generate_last_resort_pre_key(&pre_key, global_context);
-    ck_assert_int_eq(result, 0);
-
-    result = session_pre_key_serialize(&buffer, pre_key);
-    ck_assert_int_ge(result, 0);
-
-    uint8_t *data = signal_buffer_data(buffer);
-    size_t len = signal_buffer_len(buffer);
-
-    ck_assert_int_eq(len, sizeof(lastResortPreKey));
-    ck_assert_int_eq(memcmp(lastResortPreKey, data, len), 0);
-
-    /* Cleanup */
-    SIGNAL_UNREF(pre_key);
-    signal_buffer_free(buffer);
-}
-END_TEST
-
 START_TEST(test_generate_signed_pre_key)
 {
     int64_t timestamp = 1411152577000LL;
@@ -299,7 +262,6 @@ Suite *key_helper_suite(void)
     tcase_add_checked_fixture(tcase, test_setup, test_teardown);
     tcase_add_test(tcase, test_generate_identity_key_pair);
     tcase_add_test(tcase, test_generate_pre_keys);
-    tcase_add_test(tcase, test_generate_last_resort_pre_key);
     tcase_add_test(tcase, test_generate_signed_pre_key);
     suite_add_tcase(suite, tcase);
 
diff --git a/tests/test_ratchet.c b/tests/test_ratchet.c
index de93bac..8f4014c 100644
--- a/tests/test_ratchet.c
+++ b/tests/test_ratchet.c
@@ -24,14 +24,15 @@ void test_teardown()
     signal_context_destroy(global_context);
 }
 
+static uint8_t seed[] = {
+    0x8a, 0xb7, 0x2d, 0x6f, 0x4c, 0xc5, 0xac, 0x0d,
+    0x38, 0x7e, 0xaf, 0x46, 0x33, 0x78, 0xdd, 0xb2,
+    0x8e, 0xdd, 0x07, 0x38, 0x5b, 0x1c, 0xb0, 0x12,
+    0x50, 0xc7, 0x15, 0x98, 0x2e, 0x7a, 0xd4, 0x8f};
+
 START_TEST(test_chain_key_derivation_v2)
 {
     int result = 0;
-    uint8_t seed[] = {
-            0x8a, 0xb7, 0x2d, 0x6f, 0x4c, 0xc5, 0xac, 0x0d,
-            0x38, 0x7e, 0xaf, 0x46, 0x33, 0x78, 0xdd, 0xb2,
-            0x8e, 0xdd, 0x07, 0x38, 0x5b, 0x1c, 0xb0, 0x12,
-            0x50, 0xc7, 0x15, 0x98, 0x2e, 0x7a, 0xd4, 0x8f};
 
     uint8_t messageKey[] = {
             0x02, 0xa9, 0xaa, 0x6c, 0x7d, 0xbd, 0x64, 0xf9,
@@ -104,11 +105,6 @@ END_TEST
 START_TEST(test_chain_key_derivation_v3)
 {
     int result = 0;
-    uint8_t seed[] = {
-            0x8a, 0xb7, 0x2d, 0x6f, 0x4c, 0xc5, 0xac, 0x0d,
-            0x38, 0x7e, 0xaf, 0x46, 0x33, 0x78, 0xdd, 0xb2,
-            0x8e, 0xdd, 0x07, 0x38, 0x5b, 0x1c, 0xb0, 0x12,
-            0x50, 0xc7, 0x15, 0x98, 0x2e, 0x7a, 0xd4, 0x8f};
 
     uint8_t messageKey[] = {
             0xbf, 0x51, 0xe9, 0xd7, 0x5e, 0x0e, 0x31, 0x03,
@@ -187,13 +183,6 @@ START_TEST(test_root_key_derivation_v2)
             0xa6, 0x23, 0x09, 0x5b, 0x7e, 0xc6, 0x6b, 0x45,
             0xf6, 0x02, 0xd9, 0x35, 0x38, 0x94, 0x2d, 0xcc};
 
-    uint8_t alicePublic[] = {
-            0x05, 0xee, 0x4f, 0xa6, 0xcd, 0xc0, 0x30, 0xdf,
-            0x49, 0xec, 0xd0, 0xba, 0x6c, 0xfc, 0xff, 0xb2,
-            0x33, 0xd3, 0x65, 0xa2, 0x7f, 0xad, 0xbe, 0xff,
-            0x77, 0xe9, 0x63, 0xfc, 0xb1, 0x62, 0x22, 0xe1,
-            0x3a};
-
     uint8_t alicePrivate[] = {
             0x21, 0x68, 0x22, 0xec, 0x67, 0xeb, 0x38, 0x04,
             0x9e, 0xba, 0xe7, 0xb9, 0x39, 0xba, 0xea, 0xeb,
@@ -219,15 +208,9 @@ START_TEST(test_root_key_derivation_v2)
             0xa3, 0xac, 0xe8, 0x0f, 0x4c, 0xca, 0xe2, 0xda,
             0x13, 0x43, 0x0c, 0x5c, 0x55, 0xb5, 0xca, 0x5f};
 
-    ec_public_key *alice_public_key = 0;
     ec_private_key *alice_private_key = 0;
     ec_public_key *bob_public_key = 0;
 
-    /* Initialize Alice's public key */
-    result = curve_decode_point(&alice_public_key, alicePublic, sizeof(alicePublic), global_context);
-    ck_assert_int_eq(result, 0);
-    ck_assert_ptr_ne(alice_public_key, 0);
-
     /* Initialize Alice's private key */
     result = curve_decode_private_point(&alice_private_key, alicePrivate, sizeof(alicePrivate), global_context);
     ck_assert_int_eq(result, 0);
@@ -288,7 +271,6 @@ START_TEST(test_root_key_derivation_v2)
     SIGNAL_UNREF(next_root_key);
     SIGNAL_UNREF(next_chain_key);
     SIGNAL_UNREF(root_key);
-    SIGNAL_UNREF(alice_public_key);
     SIGNAL_UNREF(alice_private_key);
     SIGNAL_UNREF(bob_public_key);
 }
@@ -333,15 +315,50 @@ START_TEST(test_identity_key_serialize)
 }
 END_TEST
 
+static uint8_t bobPublic[] = {
+    0x05, 0x2c, 0xb4, 0x97, 0x76, 0xb8, 0x77, 0x02,
+    0x05, 0x74, 0x5a, 0x3a, 0x6e, 0x24, 0xf5, 0x79,
+    0xcd, 0xb4, 0xba, 0x7a, 0x89, 0x04, 0x10, 0x05,
+    0x92, 0x8e, 0xbb, 0xad, 0xc9, 0xc0, 0x5a, 0xd4,
+    0x58};
+
+static uint8_t bobIdentityPublic[] = {
+    0x05, 0xf1, 0xf4, 0x38, 0x74, 0xf6, 0x96, 0x69,
+    0x56, 0xc2, 0xdd, 0x47, 0x3f, 0x8f, 0xa1, 0x5a,
+    0xde, 0xb7, 0x1d, 0x1c, 0xb9, 0x91, 0xb2, 0x34,
+    0x16, 0x92, 0x32, 0x4c, 0xef, 0xb1, 0xc5, 0xe6,
+    0x26};
+
+static uint8_t aliceBasePublic[] = {
+    0x05, 0x47, 0x2d, 0x1f, 0xb1, 0xa9, 0x86, 0x2c,
+    0x3a, 0xf6, 0xbe, 0xac, 0xa8, 0x92, 0x02, 0x77,
+    0xe2, 0xb2, 0x6f, 0x4a, 0x79, 0x21, 0x3e, 0xc7,
+    0xc9, 0x06, 0xae, 0xb3, 0x5e, 0x03, 0xcf, 0x89,
+    0x50};
+
+static uint8_t aliceIdentityPublic[] = {
+    0x05, 0xb4, 0xa8, 0x45, 0x56, 0x60, 0xad, 0xa6,
+    0x5b, 0x40, 0x10, 0x07, 0xf6, 0x15, 0xe6, 0x54,
+    0x04, 0x17, 0x46, 0x43, 0x2e, 0x33, 0x39, 0xc6,
+    0x87, 0x51, 0x49, 0xbc, 0xee, 0xfc, 0xb4, 0x2b,
+    0x4a};
+
+static uint8_t bobSignedPreKeyPublic[] = {
+    0x05, 0xac, 0x24, 0x8a, 0x8f, 0x26, 0x3b, 0xe6,
+    0x86, 0x35, 0x76, 0xeb, 0x03, 0x62, 0xe2, 0x8c,
+    0x82, 0x8f, 0x01, 0x07, 0xa3, 0x37, 0x9d, 0x34,
+    0xba, 0xb1, 0x58, 0x6b, 0xf8, 0xc7, 0x70, 0xcd,
+    0x67};
+
+static uint8_t receiverAndSenderChain[] = {
+    0x97, 0x97, 0xca, 0xca, 0x53, 0xc9, 0x89, 0xbb,
+    0xe2, 0x29, 0xa4, 0x0c, 0xa7, 0x72, 0x70, 0x10,
+    0xeb, 0x26, 0x04, 0xfc, 0x14, 0x94, 0x5d, 0x77,
+    0x95, 0x8a, 0x0a, 0xed, 0xa0, 0x88, 0xb4, 0x4d};
+
 START_TEST(test_ratcheting_session_as_bob)
 {
     int result = 0;
-    uint8_t bobPublic[] = {
-            0x05, 0x2c, 0xb4, 0x97, 0x76, 0xb8, 0x77, 0x02,
-            0x05, 0x74, 0x5a, 0x3a, 0x6e, 0x24, 0xf5, 0x79,
-            0xcd, 0xb4, 0xba, 0x7a, 0x89, 0x04, 0x10, 0x05,
-            0x92, 0x8e, 0xbb, 0xad, 0xc9, 0xc0, 0x5a, 0xd4,
-            0x58};
 
     uint8_t bobPrivate[] = {
             0xa1, 0xca, 0xb4, 0x8f, 0x7c, 0x89, 0x3f, 0xaf,
@@ -349,59 +366,18 @@ START_TEST(test_ratcheting_session_as_bob)
             0x28, 0xd6, 0x32, 0x95, 0x62, 0xd2, 0x7a, 0x4e,
             0xa4, 0xe2, 0x2e, 0x9f, 0xf1, 0xbd, 0xd6, 0x5a};
 
-    uint8_t bobIdentityPublic[] = {
-            0x05, 0xf1, 0xf4, 0x38, 0x74, 0xf6, 0x96, 0x69,
-            0x56, 0xc2, 0xdd, 0x47, 0x3f, 0x8f, 0xa1, 0x5a,
-            0xde, 0xb7, 0x1d, 0x1c, 0xb9, 0x91, 0xb2, 0x34,
-            0x16, 0x92, 0x32, 0x4c, 0xef, 0xb1, 0xc5, 0xe6,
-            0x26};
-
     uint8_t bobIdentityPrivate[] = {
             0x48, 0x75, 0xcc, 0x69, 0xdd, 0xf8, 0xea, 0x07,
             0x19, 0xec, 0x94, 0x7d, 0x61, 0x08, 0x11, 0x35,
             0x86, 0x8d, 0x5f, 0xd8, 0x01, 0xf0, 0x2c, 0x02,
             0x25, 0xe5, 0x16, 0xdf, 0x21, 0x56, 0x60, 0x5e};
 
-    uint8_t aliceBasePublic[] = {
-            0x05, 0x47, 0x2d, 0x1f, 0xb1, 0xa9, 0x86, 0x2c,
-            0x3a, 0xf6, 0xbe, 0xac, 0xa8, 0x92, 0x02, 0x77,
-            0xe2, 0xb2, 0x6f, 0x4a, 0x79, 0x21, 0x3e, 0xc7,
-            0xc9, 0x06, 0xae, 0xb3, 0x5e, 0x03, 0xcf, 0x89,
-            0x50};
-
-    uint8_t aliceEphemeralPublic[] = {
-            0x05, 0x6c, 0x3e, 0x0d, 0x1f, 0x52, 0x02, 0x83,
-            0xef, 0xcc, 0x55, 0xfc, 0xa5, 0xe6, 0x70, 0x75,
-            0xb9, 0x04, 0x00, 0x7f, 0x18, 0x81, 0xd1, 0x51,
-            0xaf, 0x76, 0xdf, 0x18, 0xc5, 0x1d, 0x29, 0xd3,
-            0x4b};
-
-    uint8_t aliceIdentityPublic[] = {
-            0x05, 0xb4, 0xa8, 0x45, 0x56, 0x60, 0xad, 0xa6,
-            0x5b, 0x40, 0x10, 0x07, 0xf6, 0x15, 0xe6, 0x54,
-            0x04, 0x17, 0x46, 0x43, 0x2e, 0x33, 0x39, 0xc6,
-            0x87, 0x51, 0x49, 0xbc, 0xee, 0xfc, 0xb4, 0x2b,
-            0x4a};
-
-    uint8_t bobSignedPreKeyPublic[] = {
-            0x05, 0xac, 0x24, 0x8a, 0x8f, 0x26, 0x3b, 0xe6,
-            0x86, 0x35, 0x76, 0xeb, 0x03, 0x62, 0xe2, 0x8c,
-            0x82, 0x8f, 0x01, 0x07, 0xa3, 0x37, 0x9d, 0x34,
-            0xba, 0xb1, 0x58, 0x6b, 0xf8, 0xc7, 0x70, 0xcd,
-            0x67};
-
     uint8_t bobSignedPreKeyPrivate[] = {
             0x58, 0x39, 0x00, 0x13, 0x1f, 0xb7, 0x27, 0x99,
             0x8b, 0x78, 0x03, 0xfe, 0x6a, 0xc2, 0x2c, 0xc5,
             0x91, 0xf3, 0x42, 0xe4, 0xe4, 0x2a, 0x8c, 0x8d,
             0x5d, 0x78, 0x19, 0x42, 0x09, 0xb8, 0xd2, 0x53};
 
-    uint8_t senderChain[] = {
-            0x97, 0x97, 0xca, 0xca, 0x53, 0xc9, 0x89, 0xbb,
-            0xe2, 0x29, 0xa4, 0x0c, 0xa7, 0x72, 0x70, 0x10,
-            0xeb, 0x26, 0x04, 0xfc, 0x14, 0x94, 0x5d, 0x77,
-            0x95, 0x8a, 0x0a, 0xed, 0xa0, 0x88, 0xb4, 0x4d};
-
     /* Create Bob's public identity key */
     ec_public_key *bob_identity_key_public;
     result = curve_decode_point(&bob_identity_key_public, bobIdentityPublic, sizeof(bobIdentityPublic), global_context);
@@ -437,10 +413,6 @@ START_TEST(test_ratcheting_session_as_bob)
     SIGNAL_UNREF(bob_ephemeral_key_public);
     SIGNAL_UNREF(bob_ephemeral_key_private);
 
-    /* Assign Bob's base key pair as the same as the ephemeral key pair */
-    ec_key_pair *bob_base_key_pair = bob_ephemeral_key_pair;
-    SIGNAL_REF(bob_ephemeral_key_pair);
-
     /* Create Bob's public signed pre key */
     ec_public_key *bob_signed_pre_key_public;
     result = curve_decode_point(&bob_signed_pre_key_public, bobSignedPreKeyPublic, sizeof(bobSignedPreKeyPublic), global_context);
@@ -463,11 +435,6 @@ START_TEST(test_ratcheting_session_as_bob)
     result = curve_decode_point(&alice_base_key_public, aliceBasePublic, sizeof(aliceBasePublic), global_context);
     ck_assert_int_eq(result, 0);
 
-    /* Create Alice's ephemeral public key */
-    ec_public_key *alice_ephemeral_key_public;
-    result = curve_decode_point(&alice_ephemeral_key_public, aliceEphemeralPublic, sizeof(aliceEphemeralPublic), global_context);
-    ck_assert_int_eq(result, 0);
-
     /* Create Alice's public identity key */
     ec_public_key *alice_identity_key_public;
     result = curve_decode_point(&alice_identity_key_public, aliceIdentityPublic, sizeof(aliceIdentityPublic), global_context);
@@ -483,7 +450,6 @@ START_TEST(test_ratcheting_session_as_bob)
             alice_identity_key_public,
             alice_base_key_public);
     ck_assert_int_eq(result, 0);
-    SIGNAL_UNREF(bob_base_key_pair);
     SIGNAL_UNREF(bob_signed_pre_key_pair);
     SIGNAL_UNREF(bob_ephemeral_key_pair);
     SIGNAL_UNREF(alice_base_key_public);
@@ -514,12 +480,11 @@ START_TEST(test_ratcheting_session_as_bob)
     result = ratchet_chain_key_get_key(sender_chain_key, &sender_chain_key_data);
     ck_assert_int_eq(result, 0);
     int sender_chain_key_size = signal_buffer_len(sender_chain_key_data);
-    ck_assert_int_eq(sender_chain_key_size, sizeof(senderChain));
-    ck_assert_int_eq(memcmp(signal_buffer_data(sender_chain_key_data), senderChain, sizeof(senderChain)), 0);
+    ck_assert_int_eq(sender_chain_key_size, sizeof(receiverAndSenderChain));
+    ck_assert_int_eq(memcmp(signal_buffer_data(sender_chain_key_data), receiverAndSenderChain, sizeof(receiverAndSenderChain)), 0);
     signal_buffer_free(sender_chain_key_data);
 
     /* Cleanup */
-    SIGNAL_UNREF(alice_ephemeral_key_public);
     SIGNAL_UNREF(bob_identity_key_pair);
     SIGNAL_UNREF(alice_identity_key_public);
     SIGNAL_UNREF(bob_parameters);
@@ -530,33 +495,6 @@ END_TEST
 START_TEST(test_ratcheting_session_as_alice)
 {
     int result = 0;
-    uint8_t bobPublic[] = {
-            0x05, 0x2c, 0xb4, 0x97, 0x76, 0xb8, 0x77, 0x02,
-            0x05, 0x74, 0x5a, 0x3a, 0x6e, 0x24, 0xf5, 0x79,
-            0xcd, 0xb4, 0xba, 0x7a, 0x89, 0x04, 0x10, 0x05,
-            0x92, 0x8e, 0xbb, 0xad, 0xc9, 0xc0, 0x5a, 0xd4,
-            0x58};
-
-    uint8_t bobIdentityPublic[] = {
-            0x05, 0xf1, 0xf4, 0x38, 0x74, 0xf6, 0x96, 0x69,
-            0x56, 0xc2, 0xdd, 0x47, 0x3f, 0x8f, 0xa1, 0x5a,
-            0xde, 0xb7, 0x1d, 0x1c, 0xb9, 0x91, 0xb2, 0x34,
-            0x16, 0x92, 0x32, 0x4c, 0xef, 0xb1, 0xc5, 0xe6,
-            0x26};
-
-    uint8_t bobSignedPreKeyPublic[] = {
-            0x05, 0xac, 0x24, 0x8a, 0x8f, 0x26, 0x3b, 0xe6,
-            0x86, 0x35, 0x76, 0xeb, 0x03, 0x62, 0xe2, 0x8c,
-            0x82, 0x8f, 0x01, 0x07, 0xa3, 0x37, 0x9d, 0x34,
-            0xba, 0xb1, 0x58, 0x6b, 0xf8, 0xc7, 0x70, 0xcd,
-            0x67};
-
-    uint8_t aliceBasePublic[] = {
-            0x05, 0x47, 0x2d, 0x1f, 0xb1, 0xa9, 0x86, 0x2c,
-            0x3a, 0xf6, 0xbe, 0xac, 0xa8, 0x92, 0x02, 0x77,
-            0xe2, 0xb2, 0x6f, 0x4a, 0x79, 0x21, 0x3e, 0xc7,
-            0xc9, 0x06, 0xae, 0xb3, 0x5e, 0x03, 0xcf, 0x89,
-            0x50};
 
     uint8_t aliceBasePrivate[] = {
             0x11, 0xae, 0x7c, 0x64, 0xd1, 0xe6, 0x1c, 0xd5,
@@ -564,38 +502,12 @@ START_TEST(test_ratcheting_session_as_alice)
             0x39, 0x1c, 0xae, 0x66, 0xed, 0xbf, 0xcf, 0x07,
             0x3b, 0x4d, 0xa8, 0x05, 0x16, 0xa4, 0x74, 0x49};
 
-    uint8_t aliceEphemeralPublic[] = {
-            0x05, 0x6c, 0x3e, 0x0d, 0x1f, 0x52, 0x02, 0x83,
-            0xef, 0xcc, 0x55, 0xfc, 0xa5, 0xe6, 0x70, 0x75,
-            0xb9, 0x04, 0x00, 0x7f, 0x18, 0x81, 0xd1, 0x51,
-            0xaf, 0x76, 0xdf, 0x18, 0xc5, 0x1d, 0x29, 0xd3,
-            0x4b};
-
-    uint8_t aliceEphemeralPrivate[] = {
-            0xd1, 0xba, 0x38, 0xce, 0xa9, 0x17, 0x43, 0xd3,
-            0x39, 0x39, 0xc3, 0x3c, 0x84, 0x98, 0x65, 0x09,
-            0x28, 0x01, 0x61, 0xb8, 0xb6, 0x0f, 0xc7, 0x87,
-            0x0c, 0x59, 0x9c, 0x1d, 0x46, 0x20, 0x12, 0x48};
-
-    uint8_t aliceIdentityPublic[] = {
-            0x05, 0xb4, 0xa8, 0x45, 0x56, 0x60, 0xad, 0xa6,
-            0x5b, 0x40, 0x10, 0x07, 0xf6, 0x15, 0xe6, 0x54,
-            0x04, 0x17, 0x46, 0x43, 0x2e, 0x33, 0x39, 0xc6,
-            0x87, 0x51, 0x49, 0xbc, 0xee, 0xfc, 0xb4, 0x2b,
-            0x4a};
-
     uint8_t aliceIdentityPrivate[] = {
             0x90, 0x40, 0xf0, 0xd4, 0xe0, 0x9c, 0xf3, 0x8f,
             0x6d, 0xc7, 0xc1, 0x37, 0x79, 0xc9, 0x08, 0xc0,
             0x15, 0xa1, 0xda, 0x4f, 0xa7, 0x87, 0x37, 0xa0,
             0x80, 0xeb, 0x0a, 0x6f, 0x4f, 0x5f, 0x8f, 0x58};
 
-    uint8_t receiverChain[] = {
-            0x97, 0x97, 0xca, 0xca, 0x53, 0xc9, 0x89, 0xbb,
-            0xe2, 0x29, 0xa4, 0x0c, 0xa7, 0x72, 0x70, 0x10,
-            0xeb, 0x26, 0x04, 0xfc, 0x14, 0x94, 0x5d, 0x77,
-            0x95, 0x8a, 0x0a, 0xed, 0xa0, 0x88, 0xb4, 0x4d};
-
     /* Create Bob's public identity key */
     ec_public_key *bob_identity_key_public;
     result = curve_decode_point(&bob_identity_key_public, bobIdentityPublic, sizeof(bobIdentityPublic), global_context);
@@ -611,10 +523,6 @@ START_TEST(test_ratcheting_session_as_alice)
     result = curve_decode_point(&bob_signed_pre_key, bobSignedPreKeyPublic, sizeof(bobSignedPreKeyPublic), global_context);
     ck_assert_int_eq(result, 0);
 
-    /* Create Bob's base public key */
-    ec_public_key *bob_base_key_public = bob_ephemeral_key_public;
-    SIGNAL_REF(bob_base_key_public);
-
     /* Create Alice's base public key */
     ec_public_key *alice_base_public_key;
     result = curve_decode_point(&alice_base_public_key, aliceBasePublic, sizeof(aliceBasePublic), global_context);
@@ -632,23 +540,6 @@ START_TEST(test_ratcheting_session_as_alice)
     SIGNAL_UNREF(alice_base_public_key);
     SIGNAL_UNREF(alice_base_private_key);
 
-    /* Create Alice's ephemeral public key */
-    ec_public_key *alice_ephemeral_public_key;
-    result = curve_decode_point(&alice_ephemeral_public_key, aliceEphemeralPublic, sizeof(aliceEphemeralPublic), global_context);
-    ck_assert_int_eq(result, 0);
-
-    /* Create Alice's ephemeral private key */
-    ec_private_key *alice_ephemeral_private_key;
-    result = curve_decode_private_point(&alice_ephemeral_private_key, aliceEphemeralPrivate, sizeof(aliceEphemeralPrivate), global_context);
-    ck_assert_int_eq(result, 0);
-
-    /* Create Alice's ephemeral key pair */
-    ec_key_pair *alice_ephemeral_key;
-    result = ec_key_pair_create(&alice_ephemeral_key, alice_ephemeral_public_key, alice_ephemeral_private_key);
-    ck_assert_int_eq(result, 0);
-    SIGNAL_UNREF(alice_ephemeral_public_key);
-    SIGNAL_UNREF(alice_ephemeral_private_key);
-
     /* Create Alice's identity public key */
     ec_public_key *alice_identity_public_key;
     result = curve_decode_point(&alice_identity_public_key, aliceIdentityPublic, sizeof(aliceIdentityPublic), global_context);
@@ -699,17 +590,15 @@ START_TEST(test_ratcheting_session_as_alice)
     result = ratchet_chain_key_get_key(receiver_chain_actual, &receiver_chain_actual_data);
     ck_assert_int_eq(result, 0);
     int receiver_chain_actual_data_len = signal_buffer_len(receiver_chain_actual_data);
-    ck_assert_int_eq(receiver_chain_actual_data_len, sizeof(receiverChain));
-    ck_assert_int_eq(memcmp(signal_buffer_data(receiver_chain_actual_data), receiverChain, receiver_chain_actual_data_len), 0);
+    ck_assert_int_eq(receiver_chain_actual_data_len, sizeof(receiverAndSenderChain));
+    ck_assert_int_eq(memcmp(signal_buffer_data(receiver_chain_actual_data), receiverAndSenderChain, receiver_chain_actual_data_len), 0);
     signal_buffer_free(receiver_chain_actual_data);
 
     /* Cleanup */
     SIGNAL_UNREF(bob_identity_key_public);
     SIGNAL_UNREF(bob_ephemeral_key_public);
-    SIGNAL_UNREF(bob_base_key_public);
     SIGNAL_UNREF(bob_signed_pre_key);
     SIGNAL_UNREF(alice_base_key);
-    SIGNAL_UNREF(alice_ephemeral_key);
     SIGNAL_UNREF(alice_identity_key_pair);
     SIGNAL_UNREF(alice_parameters);
     SIGNAL_UNREF(test_session_state);
diff --git a/tests/test_session_cipher.c b/tests/test_session_cipher.c
index 0f7235b..e761fda 100644
--- a/tests/test_session_cipher.c
+++ b/tests/test_session_cipher.c
@@ -102,11 +102,6 @@ void initialize_sessions_v3(session_state *alice_state, session_state *bob_state
     result = curve_generate_key_pair(global_context, &alice_base_key);
     ck_assert_int_eq(result, 0);
 
-    /* Generate Alice's ephemeral key */
-    ec_key_pair *alice_ephemeral_key = 0;
-    result = curve_generate_key_pair(global_context, &alice_ephemeral_key);
-    ck_assert_int_eq(result, 0);
-
     /* Generate Alice's pre-key */
     ec_key_pair *alice_pre_key = alice_base_key;
     SIGNAL_REF(alice_base_key);
@@ -132,11 +127,6 @@ void initialize_sessions_v3(session_state *alice_state, session_state *bob_state
     ec_key_pair *bob_ephemeral_key = bob_base_key;
     SIGNAL_REF(bob_base_key);
 
-    /* Generate Bob's pre-key */
-    ec_key_pair *bob_pre_key;
-    result = curve_generate_key_pair(global_context, &bob_pre_key);
-    ck_assert_int_eq(result, 0);
-
     /* Create Alice's parameters */
     alice_signal_protocol_parameters *alice_parameters = 0;
     result = alice_signal_protocol_parameters_create(&alice_parameters,
@@ -168,12 +158,10 @@ void initialize_sessions_v3(session_state *alice_state, session_state *bob_state
     /* Unref cleanup */
     SIGNAL_UNREF(alice_identity_key);
     SIGNAL_UNREF(alice_base_key);
-    SIGNAL_UNREF(alice_ephemeral_key);
     SIGNAL_UNREF(alice_pre_key);
     SIGNAL_UNREF(bob_identity_key);
     SIGNAL_UNREF(bob_base_key);
     SIGNAL_UNREF(bob_ephemeral_key);
-    SIGNAL_UNREF(bob_pre_key);
     SIGNAL_UNREF(alice_parameters);
     SIGNAL_UNREF(bob_parameters);
 }
@@ -195,7 +183,7 @@ void generate_test_message_collections(session_cipher *cipher, signal_buffer **p
 
     int result = 0;
     int i;
-    for(i = 0; i < 50; i++) {
+    for(i = 0; i < size; i++) {
         /* Generate the plaintext */
         signal_buffer *plain_buf = signal_buffer_create(testMessage, sizeof(testMessage));
         uint8_t *plain_buf_data = signal_buffer_data(plain_buf);
@@ -219,9 +207,9 @@ void generate_test_message_collections(session_cipher *cipher, signal_buffer **p
     /* Randomize the two arrays using the same seed */
     time_t seed = time(0);
     srand(seed);
-    shuffle_buffers(plaintext_messages, 50);
+    shuffle_buffers(plaintext_messages, size);
     srand(seed);
-    shuffle_buffers(ciphertext_messages, 50);
+    shuffle_buffers(ciphertext_messages, size);
 }
 
 void decrypt_and_compare_messages(session_cipher *cipher, signal_buffer *ciphertext, signal_buffer *plaintext)
@@ -269,18 +257,18 @@ void run_interaction(session_record *alice_session_record, session_record *bob_s
     setup_test_store_context(&bob_store, global_context);
 
     /* Store the two sessions in their data stores */
-    result = signal_protocol_session_store_session(alice_store, &alice_address, alice_session_record);
+    result = signal_protocol_session_store_session(alice_store, &bob_address, alice_session_record);
     ck_assert_int_eq(result, 0);
-    result = signal_protocol_session_store_session(bob_store, &bob_address, bob_session_record);
+    result = signal_protocol_session_store_session(bob_store, &alice_address, bob_session_record);
     ck_assert_int_eq(result, 0);
 
     /* Create two session cipher instances */
     session_cipher *alice_cipher = 0;
-    result = session_cipher_create(&alice_cipher, alice_store, &alice_address, global_context);
+    result = session_cipher_create(&alice_cipher, alice_store, &bob_address, global_context);
     ck_assert_int_eq(result, 0);
 
     session_cipher *bob_cipher = 0;
-    result = session_cipher_create(&bob_cipher, bob_store, &bob_address, global_context);
+    result = session_cipher_create(&bob_cipher, bob_store, &alice_address, global_context);
     ck_assert_int_eq(result, 0);
 
     /* Encrypt a test message from Alice */
@@ -290,27 +278,13 @@ void run_interaction(session_record *alice_session_record, session_record *bob_s
     result = session_cipher_encrypt(alice_cipher, (uint8_t *)alice_plaintext, alice_plaintext_len, &alice_message);
     ck_assert_int_eq(result, 0);
 
-    /* Serialize and deserialize the test message to create a fresh instance */
+    /* Serialize the test message to create a fresh instance */
     signal_buffer *alice_message_serialized = ciphertext_message_get_serialized(alice_message);
     ck_assert_ptr_ne(alice_message_serialized, 0);
 
-    signal_message *alice_message_deserialized = 0;
-    result = signal_message_deserialize(&alice_message_deserialized,
-            signal_buffer_data(alice_message_serialized),
-            signal_buffer_len(alice_message_serialized),
-            global_context);
-    ck_assert_int_eq(result, 0);
-
     /* Have Bob decrypt the test message */
-    signal_buffer *bob_plaintext = 0;
-    result = session_cipher_decrypt_signal_message(bob_cipher, alice_message_deserialized, 0, &bob_plaintext);
-    ck_assert_int_eq(result, 0);
-
-    uint8_t *bob_plaintext_data = signal_buffer_data(bob_plaintext);
-    size_t bob_plaintext_len = signal_buffer_len(bob_plaintext);
-
-    ck_assert_int_eq(alice_plaintext_len, bob_plaintext_len);
-    ck_assert_int_eq(memcmp(alice_plaintext, bob_plaintext_data, bob_plaintext_len), 0);
+    signal_buffer *alice_plaintext_buffer = signal_buffer_create((uint8_t*) alice_plaintext, alice_plaintext_len);
+    decrypt_and_compare_messages(bob_cipher, alice_message_serialized, alice_plaintext_buffer);
 
     fprintf(stderr, "Interaction complete: Alice -> Bob\n");
 
@@ -321,28 +295,13 @@ void run_interaction(session_record *alice_session_record, session_record *bob_s
     result = session_cipher_encrypt(bob_cipher, (uint8_t *)bob_reply, bob_reply_len, &reply_message);
     ck_assert_int_eq(result, 0);
 
-    /* Serialize and deserialize the reply message to create a fresh instance */
+    /* Serialize the reply message to create a fresh instance */
     signal_buffer *reply_message_serialized = ciphertext_message_get_serialized(reply_message);
     ck_assert_ptr_ne(reply_message_serialized, 0);
 
-    signal_message *reply_message_deserialized = 0;
-    result = signal_message_deserialize(&reply_message_deserialized,
-            signal_buffer_data(reply_message_serialized),
-            signal_buffer_len(reply_message_serialized),
-            global_context);
-    ck_assert_int_eq(result, 0);
-
     /* Have Alice decrypt the reply message */
-
-    signal_buffer *reply_plaintext = 0;
-    result = session_cipher_decrypt_signal_message(alice_cipher, reply_message_deserialized, 0, &reply_plaintext);
-    ck_assert_int_eq(result, 0);
-
-    uint8_t *reply_plaintext_data = signal_buffer_data(reply_plaintext);
-    size_t reply_plaintext_len = signal_buffer_len(reply_plaintext);
-
-    ck_assert_int_eq(bob_reply_len, reply_plaintext_len);
-    ck_assert_int_eq(memcmp(bob_reply, reply_plaintext_data, reply_plaintext_len), 0);
+    signal_buffer *bob_plaintext_buffer = signal_buffer_create((uint8_t*) bob_reply, bob_reply_len);
+    decrypt_and_compare_messages(alice_cipher, reply_message_serialized, bob_plaintext_buffer);
 
     fprintf(stderr, "Interaction complete: Bob -> Alice\n");
 
@@ -398,10 +357,8 @@ void run_interaction(session_record *alice_session_record, session_record *bob_s
 
     SIGNAL_UNREF(alice_message);
     SIGNAL_UNREF(reply_message);
-    SIGNAL_UNREF(alice_message_deserialized);
-    SIGNAL_UNREF(reply_message_deserialized);
-    signal_buffer_free(reply_plaintext);
-    signal_buffer_free(bob_plaintext);
+    signal_buffer_free(alice_plaintext_buffer);
+    signal_buffer_free(bob_plaintext_buffer);
     session_cipher_free(alice_cipher);
     session_cipher_free(bob_cipher);
     signal_protocol_store_context_destroy(alice_store);
